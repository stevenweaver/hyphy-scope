import {
  Accent_default,
  Blues_default,
  BrBG_default,
  BuGn_default,
  BuPu_default,
  Dark2_default,
  Delaunay,
  GnBu_default,
  Greens_default,
  Greys_default,
  InternMap,
  InternSet,
  OrRd_default,
  Oranges_default,
  PRGn_default,
  Paired_default,
  Pastel1_default,
  Pastel2_default,
  PiYG_default,
  PuBuGn_default,
  PuBu_default,
  PuOr_default,
  PuRd_default,
  Purples_default,
  RdBu_default,
  RdGy_default,
  RdPu_default,
  RdYlBu_default,
  RdYlGn_default,
  Reds_default,
  Set1_default,
  Set2_default,
  Set3_default,
  Spectral_default,
  Tableau10_default,
  YlGnBu_default,
  YlGn_default,
  YlOrBr_default,
  YlOrRd_default,
  albersUsa_default,
  albers_default,
  area_default3 as area_default,
  ascending,
  asterisk_default,
  axisBottom,
  azimuthalEqualArea_default,
  azimuthalEquidistant_default,
  band,
  basisClosed_default2 as basisClosed_default,
  basisOpen_default,
  basis_default2 as basis_default,
  bisect_default,
  bisector,
  blur2,
  blurImage,
  bumpX,
  bumpY,
  bundle_default,
  cardinalClosed_default,
  cardinalOpen_default,
  cardinal_default,
  category10_default,
  catmullRomClosed_default,
  catmullRomOpen_default,
  catmullRom_default,
  centroid_default,
  circle_default3 as circle_default,
  cividis_default,
  clipRectangle,
  cluster_default,
  conicConformal_default,
  conicEqualArea_default,
  conicEquidistant_default,
  contours_default,
  cool,
  count,
  creator_default,
  cross,
  cross_default,
  cubehelix_default2 as cubehelix_default,
  cumsum,
  density_default,
  descending,
  deviation,
  diamond2_default,
  diamond_default,
  diverging,
  divergingLog,
  divergingPow,
  divergingSymlog,
  equalEarth_default,
  equirectangular_default,
  extent,
  format,
  gnomonic_default,
  graticule10,
  greatest,
  group,
  groupSort,
  hcl_default,
  hsl_default,
  identity,
  implicit,
  inferno,
  lab2 as lab,
  lcg,
  least,
  line_default,
  linear2 as linear,
  linearClosed_default,
  linear_default,
  log,
  magma,
  max,
  maxIndex,
  mean,
  median,
  mercator_default,
  min,
  minIndex,
  mode,
  monotoneX,
  monotoneY,
  namespaces_default,
  natural_default,
  nice,
  number_default,
  observable10_default,
  ordinal,
  orthographic_default,
  pairs,
  pathRound,
  path_default,
  piecewise,
  plasma,
  plus_default,
  point,
  pointer_default,
  pow,
  quantile,
  quantile2,
  quantize_default,
  rainbow_default,
  range,
  rank,
  reverse,
  rgb,
  rgb_default,
  rollup,
  rollups,
  round_default,
  scheme,
  scheme10,
  scheme11,
  scheme12,
  scheme13,
  scheme14,
  scheme15,
  scheme16,
  scheme17,
  scheme18,
  scheme19,
  scheme2,
  scheme20,
  scheme21,
  scheme22,
  scheme23,
  scheme24,
  scheme25,
  scheme26,
  scheme27,
  scheme3,
  scheme4,
  scheme5,
  scheme6,
  scheme7,
  scheme8,
  scheme9,
  second,
  select_default,
  sinebow_default,
  sort,
  square2_default,
  square_default,
  star_default,
  stepAfter,
  stepBefore,
  step_default,
  stereographic_default,
  stratify_default,
  stream_default,
  sum,
  symbolsFill,
  symbolsStroke,
  symlog,
  threshold,
  thresholdFreedmanDiaconis,
  thresholdScott,
  thresholdSturges,
  tickIncrement,
  ticks,
  time,
  timeDay,
  timeFormat,
  timeFriday,
  timeHour,
  timeMinute,
  timeMonday,
  timeMonth,
  timeSaturday,
  timeSunday,
  timeThursday,
  timeTuesday,
  timeWednesday,
  timeYear,
  times_default,
  transform_default,
  transverseMercator_default,
  tree_default,
  triangle2_default,
  triangle_default,
  turbo_default,
  unixDay,
  utcFormat,
  utcFriday,
  utcHour,
  utcMinute,
  utcMonday,
  utcMonth,
  utcSaturday,
  utcSunday,
  utcThursday,
  utcTickInterval,
  utcTime,
  utcTuesday,
  utcWednesday,
  utcYear,
  variance,
  viridis_default,
  warm,
  wye_default
} from "./chunk-3P4ERZQU.js";
import {
  __commonJS,
  __toESM
} from "./chunk-B4Q33VKO.js";

// node_modules/binary-search-bounds/search-bounds.js
var require_search_bounds = __commonJS({
  "node_modules/binary-search-bounds/search-bounds.js"(exports, module) {
    "use strict";
    function ge(a, y, c, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p >= 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function gt(a, y, c, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p > 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function lt(a, y, c, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p < 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function le(a, y, c, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p <= 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function eq(a, y, c, l, h) {
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p === 0) {
          return m;
        }
        if (p <= 0) {
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return -1;
    }
    function norm(a, y, c, l, h, f) {
      if (typeof c === "function") {
        return f(a, y, c, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0);
      }
      return f(a, y, void 0, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0);
    }
    module.exports = {
      ge: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, ge);
      },
      gt: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, gt);
      },
      lt: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, lt);
      },
      le: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, le);
      },
      eq: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, eq);
      }
    };
  }
});

// node_modules/interval-tree-1d/interval-tree.js
var require_interval_tree = __commonJS({
  "node_modules/interval-tree-1d/interval-tree.js"(exports, module) {
    "use strict";
    var bounds = require_search_bounds();
    var NOT_FOUND = 0;
    var SUCCESS = 1;
    var EMPTY = 2;
    module.exports = createWrapper;
    function IntervalTreeNode(mid2, left, right, leftPoints, rightPoints) {
      this.mid = mid2;
      this.left = left;
      this.right = right;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
    }
    var proto = IntervalTreeNode.prototype;
    function copy(a, b) {
      a.mid = b.mid;
      a.left = b.left;
      a.right = b.right;
      a.leftPoints = b.leftPoints;
      a.rightPoints = b.rightPoints;
      a.count = b.count;
    }
    function rebuild(node, intervals) {
      var ntree = createIntervalTree(intervals);
      node.mid = ntree.mid;
      node.left = ntree.left;
      node.right = ntree.right;
      node.leftPoints = ntree.leftPoints;
      node.rightPoints = ntree.rightPoints;
      node.count = ntree.count;
    }
    function rebuildWithInterval(node, interval) {
      var intervals = node.intervals([]);
      intervals.push(interval);
      rebuild(node, intervals);
    }
    function rebuildWithoutInterval(node, interval) {
      var intervals = node.intervals([]);
      var idx = intervals.indexOf(interval);
      if (idx < 0) {
        return NOT_FOUND;
      }
      intervals.splice(idx, 1);
      rebuild(node, intervals);
      return SUCCESS;
    }
    proto.intervals = function(result) {
      result.push.apply(result, this.leftPoints);
      if (this.left) {
        this.left.intervals(result);
      }
      if (this.right) {
        this.right.intervals(result);
      }
      return result;
    };
    proto.insert = function(interval) {
      var weight = this.count - this.leftPoints.length;
      this.count += 1;
      if (interval[1] < this.mid) {
        if (this.left) {
          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval);
          } else {
            this.left.insert(interval);
          }
        } else {
          this.left = createIntervalTree([interval]);
        }
      } else if (interval[0] > this.mid) {
        if (this.right) {
          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval);
          } else {
            this.right.insert(interval);
          }
        } else {
          this.right = createIntervalTree([interval]);
        }
      } else {
        var l = bounds.ge(this.leftPoints, interval, compareBegin);
        var r = bounds.ge(this.rightPoints, interval, compareEnd);
        this.leftPoints.splice(l, 0, interval);
        this.rightPoints.splice(r, 0, interval);
      }
    };
    proto.remove = function(interval) {
      var weight = this.count - this.leftPoints;
      if (interval[1] < this.mid) {
        if (!this.left) {
          return NOT_FOUND;
        }
        var rw = this.right ? this.right.count : 0;
        if (4 * rw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval);
        }
        var r = this.left.remove(interval);
        if (r === EMPTY) {
          this.left = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else if (interval[0] > this.mid) {
        if (!this.right) {
          return NOT_FOUND;
        }
        var lw = this.left ? this.left.count : 0;
        if (4 * lw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval);
        }
        var r = this.right.remove(interval);
        if (r === EMPTY) {
          this.right = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else {
        if (this.count === 1) {
          if (this.leftPoints[0] === interval) {
            return EMPTY;
          } else {
            return NOT_FOUND;
          }
        }
        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
          if (this.left && this.right) {
            var p = this;
            var n = this.left;
            while (n.right) {
              p = n;
              n = n.right;
            }
            if (p === this) {
              n.right = this.right;
            } else {
              var l = this.left;
              var r = this.right;
              p.count -= n.count;
              p.right = n.left;
              n.left = l;
              n.right = r;
            }
            copy(this, n);
            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
          } else if (this.left) {
            copy(this, this.left);
          } else {
            copy(this, this.right);
          }
          return SUCCESS;
        }
        for (var l = bounds.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
          if (this.leftPoints[l][0] !== interval[0]) {
            break;
          }
          if (this.leftPoints[l] === interval) {
            this.count -= 1;
            this.leftPoints.splice(l, 1);
            for (var r = bounds.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {
              if (this.rightPoints[r][1] !== interval[1]) {
                break;
              } else if (this.rightPoints[r] === interval) {
                this.rightPoints.splice(r, 1);
                return SUCCESS;
              }
            }
          }
        }
        return NOT_FOUND;
      }
    };
    function reportLeftRange(arr, hi, cb) {
      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRightRange(arr, lo, cb) {
      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRange(arr, cb) {
      for (var i = 0; i < arr.length; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    proto.queryPoint = function(x, cb) {
      if (x < this.mid) {
        if (this.left) {
          var r = this.left.queryPoint(x, cb);
          if (r) {
            return r;
          }
        }
        return reportLeftRange(this.leftPoints, x, cb);
      } else if (x > this.mid) {
        if (this.right) {
          var r = this.right.queryPoint(x, cb);
          if (r) {
            return r;
          }
        }
        return reportRightRange(this.rightPoints, x, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    proto.queryInterval = function(lo, hi, cb) {
      if (lo < this.mid && this.left) {
        var r = this.left.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi > this.mid && this.right) {
        var r = this.right.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi < this.mid) {
        return reportLeftRange(this.leftPoints, hi, cb);
      } else if (lo > this.mid) {
        return reportRightRange(this.rightPoints, lo, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    function compareNumbers(a, b) {
      return a - b;
    }
    function compareBegin(a, b) {
      var d = a[0] - b[0];
      if (d) {
        return d;
      }
      return a[1] - b[1];
    }
    function compareEnd(a, b) {
      var d = a[1] - b[1];
      if (d) {
        return d;
      }
      return a[0] - b[0];
    }
    function createIntervalTree(intervals) {
      if (intervals.length === 0) {
        return null;
      }
      var pts = [];
      for (var i = 0; i < intervals.length; ++i) {
        pts.push(intervals[i][0], intervals[i][1]);
      }
      pts.sort(compareNumbers);
      var mid2 = pts[pts.length >> 1];
      var leftIntervals = [];
      var rightIntervals = [];
      var centerIntervals = [];
      for (var i = 0; i < intervals.length; ++i) {
        var s = intervals[i];
        if (s[1] < mid2) {
          leftIntervals.push(s);
        } else if (mid2 < s[0]) {
          rightIntervals.push(s);
        } else {
          centerIntervals.push(s);
        }
      }
      var leftPoints = centerIntervals;
      var rightPoints = centerIntervals.slice();
      leftPoints.sort(compareBegin);
      rightPoints.sort(compareEnd);
      return new IntervalTreeNode(
        mid2,
        createIntervalTree(leftIntervals),
        createIntervalTree(rightIntervals),
        leftPoints,
        rightPoints
      );
    }
    function IntervalTree2(root) {
      this.root = root;
    }
    var tproto = IntervalTree2.prototype;
    tproto.insert = function(interval) {
      if (this.root) {
        this.root.insert(interval);
      } else {
        this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
      }
    };
    tproto.remove = function(interval) {
      if (this.root) {
        var r = this.root.remove(interval);
        if (r === EMPTY) {
          this.root = null;
        }
        return r !== NOT_FOUND;
      }
      return false;
    };
    tproto.queryPoint = function(p, cb) {
      if (this.root) {
        return this.root.queryPoint(p, cb);
      }
    };
    tproto.queryInterval = function(lo, hi, cb) {
      if (lo <= hi && this.root) {
        return this.root.queryInterval(lo, hi, cb);
      }
    };
    Object.defineProperty(tproto, "count", {
      get: function() {
        if (this.root) {
          return this.root.count;
        }
        return 0;
      }
    });
    Object.defineProperty(tproto, "intervals", {
      get: function() {
        if (this.root) {
          return this.root.intervals([]);
        }
        return [];
      }
    });
    function createWrapper(intervals) {
      if (!intervals || intervals.length === 0) {
        return new IntervalTree2(null);
      }
      return new IntervalTree2(createIntervalTree(intervals));
    }
  }
});

// node_modules/@observablehq/plot/src/defined.js
function defined(x) {
  return x != null && !Number.isNaN(x);
}
function ascendingDefined(a, b) {
  return +defined(b) - +defined(a) || ascending(a, b);
}
function descendingDefined(a, b) {
  return +defined(b) - +defined(a) || descending(a, b);
}
function nonempty(x) {
  return x != null && `${x}` !== "";
}
function finite(x) {
  return isFinite(x) ? x : NaN;
}
function positive(x) {
  return x > 0 && isFinite(x) ? x : NaN;
}
function negative(x) {
  return x < 0 && isFinite(x) ? x : NaN;
}

// node_modules/isoformat/src/format.js
function format2(date, fallback) {
  if (!(date instanceof Date)) date = /* @__PURE__ */ new Date(+date);
  if (isNaN(date)) return typeof fallback === "function" ? fallback(date) : fallback;
  const hours = date.getUTCHours();
  const minutes = date.getUTCMinutes();
  const seconds = date.getUTCSeconds();
  const milliseconds = date.getUTCMilliseconds();
  return `${formatYear(date.getUTCFullYear(), 4)}-${pad(date.getUTCMonth() + 1, 2)}-${pad(date.getUTCDate(), 2)}${hours || minutes || seconds || milliseconds ? `T${pad(hours, 2)}:${pad(minutes, 2)}${seconds || milliseconds ? `:${pad(seconds, 2)}${milliseconds ? `.${pad(milliseconds, 3)}` : ``}` : ``}Z` : ``}`;
}
function formatYear(year) {
  return year < 0 ? `-${pad(-year, 6)}` : year > 9999 ? `+${pad(year, 6)}` : pad(year, 4);
}
function pad(value, width) {
  return `${value}`.padStart(width, "0");
}

// node_modules/isoformat/src/parse.js
var re = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function parse(string2, fallback) {
  if (!re.test(string2 += "")) return typeof fallback === "function" ? fallback(string2) : fallback;
  return new Date(string2);
}

// node_modules/@observablehq/plot/src/order.js
function orderof(values2) {
  if (values2 == null) return;
  const first2 = values2[0];
  const last = values2[values2.length - 1];
  return descending(first2, last);
}

// node_modules/@observablehq/plot/src/time.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;
var tickIntervals = [
  ["millisecond", 1],
  ["2 milliseconds", 2],
  ["5 milliseconds", 5],
  ["10 milliseconds", 10],
  ["20 milliseconds", 20],
  ["50 milliseconds", 50],
  ["100 milliseconds", 100],
  ["200 milliseconds", 200],
  ["500 milliseconds", 500],
  ["second", durationSecond],
  ["5 seconds", 5 * durationSecond],
  ["15 seconds", 15 * durationSecond],
  ["30 seconds", 30 * durationSecond],
  ["minute", durationMinute],
  ["5 minutes", 5 * durationMinute],
  ["15 minutes", 15 * durationMinute],
  ["30 minutes", 30 * durationMinute],
  ["hour", durationHour],
  ["3 hours", 3 * durationHour],
  ["6 hours", 6 * durationHour],
  ["12 hours", 12 * durationHour],
  ["day", durationDay],
  ["2 days", 2 * durationDay],
  ["week", durationWeek],
  ["2 weeks", 2 * durationWeek],
  // https://github.com/d3/d3-time/issues/46
  ["month", durationMonth],
  ["3 months", 3 * durationMonth],
  ["6 months", 6 * durationMonth],
  // https://github.com/d3/d3-time/issues/46
  ["year", durationYear],
  ["2 years", 2 * durationYear],
  ["5 years", 5 * durationYear],
  ["10 years", 10 * durationYear],
  ["20 years", 20 * durationYear],
  ["50 years", 50 * durationYear],
  ["100 years", 100 * durationYear]
  // TODO generalize to longer time scales
];
var durations = /* @__PURE__ */ new Map([
  ["second", durationSecond],
  ["minute", durationMinute],
  ["hour", durationHour],
  ["day", durationDay],
  ["monday", durationWeek],
  ["tuesday", durationWeek],
  ["wednesday", durationWeek],
  ["thursday", durationWeek],
  ["friday", durationWeek],
  ["saturday", durationWeek],
  ["sunday", durationWeek],
  ["week", durationWeek],
  ["month", durationMonth],
  ["year", durationYear]
]);
var timeIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", timeMinute],
  ["hour", timeHour],
  ["day", timeDay],
  // https://github.com/d3/d3-time/issues/62
  ["monday", timeMonday],
  ["tuesday", timeTuesday],
  ["wednesday", timeWednesday],
  ["thursday", timeThursday],
  ["friday", timeFriday],
  ["saturday", timeSaturday],
  ["sunday", timeSunday],
  ["week", timeSunday],
  ["month", timeMonth],
  ["year", timeYear]
]);
var utcIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", utcMinute],
  ["hour", utcHour],
  ["day", unixDay],
  ["monday", utcMonday],
  ["tuesday", utcTuesday],
  ["wednesday", utcWednesday],
  ["thursday", utcThursday],
  ["friday", utcFriday],
  ["saturday", utcSaturday],
  ["sunday", utcSunday],
  ["week", utcSunday],
  ["month", utcMonth],
  ["year", utcYear]
]);
var intervalDuration = Symbol("intervalDuration");
var intervalType = Symbol("intervalType");
for (const [name, interval] of timeIntervals) {
  interval[intervalDuration] = durations.get(name);
  interval[intervalType] = "time";
}
for (const [name, interval] of utcIntervals) {
  interval[intervalDuration] = durations.get(name);
  interval[intervalType] = "utc";
}
var utcFormatIntervals = [
  ["year", utcYear, "utc"],
  ["month", utcMonth, "utc"],
  ["day", unixDay, "utc", 6 * durationMonth],
  ["hour", utcHour, "utc", 3 * durationDay],
  ["minute", utcMinute, "utc", 6 * durationHour],
  ["second", second, "utc", 30 * durationMinute]
];
var timeFormatIntervals = [
  ["year", timeYear, "time"],
  ["month", timeMonth, "time"],
  ["day", timeDay, "time", 6 * durationMonth],
  ["hour", timeHour, "time", 3 * durationDay],
  ["minute", timeMinute, "time", 6 * durationHour],
  ["second", second, "time", 30 * durationMinute]
];
var formatIntervals = [
  utcFormatIntervals[0],
  timeFormatIntervals[0],
  utcFormatIntervals[1],
  timeFormatIntervals[1],
  utcFormatIntervals[2],
  timeFormatIntervals[2],
  // Below day, local time typically has an hourly offset from UTC and hence the
  // two are aligned and indistinguishable; therefore, we only consider UTC, and
  // we don’t consider these if the domain only has a single value.
  ...utcFormatIntervals.slice(3)
];
function parseTimeInterval(input) {
  let name = `${input}`.toLowerCase();
  if (name.endsWith("s")) name = name.slice(0, -1);
  let period = 1;
  const match = /^(?:(\d+)\s+)/.exec(name);
  if (match) {
    name = name.slice(match[0].length);
    period = +match[1];
  }
  switch (name) {
    case "quarter":
      name = "month";
      period *= 3;
      break;
    case "half":
      name = "month";
      period *= 6;
      break;
  }
  let interval = utcIntervals.get(name);
  if (!interval) throw new Error(`unknown interval: ${input}`);
  if (period > 1 && !interval.every) throw new Error(`non-periodic interval: ${name}`);
  return [name, period];
}
function timeInterval(input) {
  return asInterval(parseTimeInterval(input), "time");
}
function utcInterval(input) {
  return asInterval(parseTimeInterval(input), "utc");
}
function asInterval([name, period], type) {
  let interval = (type === "time" ? timeIntervals : utcIntervals).get(name);
  if (period > 1) {
    interval = interval.every(period);
    interval[intervalDuration] = durations.get(name) * period;
    interval[intervalType] = type;
  }
  return interval;
}
function generalizeTimeInterval(interval, n) {
  if (!(n > 1)) return;
  const duration = interval[intervalDuration];
  if (!tickIntervals.some(([, d]) => d === duration)) return;
  if (duration % durationDay === 0 && durationDay < duration && duration < durationMonth) return;
  const [i] = tickIntervals[bisector(([, step]) => Math.log(step)).center(tickIntervals, Math.log(duration * n))];
  return (interval[intervalType] === "time" ? timeInterval : utcInterval)(i);
}
function formatTimeInterval(name, type, anchor) {
  const format3 = type === "time" ? timeFormat : utcFormat;
  if (anchor == null) {
    return format3(
      name === "year" ? "%Y" : name === "month" ? "%Y-%m" : name === "day" ? "%Y-%m-%d" : name === "hour" || name === "minute" ? "%Y-%m-%dT%H:%M" : name === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
    );
  }
  const template2 = getTimeTemplate(anchor);
  switch (name) {
    case "millisecond":
      return formatConditional(format3(".%L"), format3(":%M:%S"), template2);
    case "second":
      return formatConditional(format3(":%S"), format3("%-I:%M"), template2);
    case "minute":
      return formatConditional(format3("%-I:%M"), format3("%p"), template2);
    case "hour":
      return formatConditional(format3("%-I %p"), format3("%b %-d"), template2);
    case "day":
      return formatConditional(format3("%-d"), format3("%b"), template2);
    case "month":
      return formatConditional(format3("%b"), format3("%Y"), template2);
    case "year":
      return format3("%Y");
  }
  throw new Error("unable to format time ticks");
}
function getTimeTemplate(anchor) {
  return anchor === "left" || anchor === "right" ? (f1, f2) => `
${f1}
${f2}` : anchor === "top" ? (f1, f2) => `${f2}
${f1}` : (f1, f2) => `${f1}
${f2}`;
}
function getFormatIntervals(type) {
  return type === "time" ? timeFormatIntervals : type === "utc" ? utcFormatIntervals : formatIntervals;
}
function inferTimeFormat(type, dates, anchor) {
  const step = max(pairs(dates, (a, b) => Math.abs(b - a)));
  if (step < 1e3) return formatTimeInterval("millisecond", "utc", anchor);
  for (const [name, interval, intervalType2, maxStep] of getFormatIntervals(type)) {
    if (step > maxStep) break;
    if (name === "hour" && !step) break;
    if (dates.every((d) => interval.floor(d) >= d)) return formatTimeInterval(name, intervalType2, anchor);
  }
}
function formatConditional(format1, format22, template2) {
  return (x, i, X) => {
    const f1 = format1(x, i);
    const f2 = format22(x, i);
    const j = i - orderof(X);
    return i !== j && X[j] !== void 0 && f2 === format22(X[j], j) ? f1 : template2(f1, f2);
  };
}

// node_modules/@observablehq/plot/src/options.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var objectToString = Object.prototype.toString;
function isArray(value) {
  return value instanceof Array || value instanceof TypedArray;
}
function isNumberArray(value) {
  return value instanceof TypedArray && !isBigIntArray(value);
}
function isNumberType(type) {
  return (type == null ? void 0 : type.prototype) instanceof TypedArray && !isBigIntType(type);
}
function isBigIntArray(value) {
  return value instanceof BigInt64Array || value instanceof BigUint64Array;
}
function isBigIntType(type) {
  return type === BigInt64Array || type === BigUint64Array;
}
var reindex = Symbol("reindex");
function valueof(data, value, type) {
  const valueType = typeof value;
  return valueType === "string" ? isArrowTable(data) ? maybeTypedArrowify(data.getChild(value), type) : maybeTypedMap(data, field(value), type) : valueType === "function" ? maybeTypedMap(data, value, type) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map(data, constant(value), type) : typeof (value == null ? void 0 : value.transform) === "function" ? maybeTypedArrayify(value.transform(data), type) : maybeTake(maybeTypedArrayify(value, type), data == null ? void 0 : data[reindex]);
}
function maybeTake(values2, index) {
  return values2 != null && index ? take(values2, index) : values2;
}
function maybeTypedMap(data, f, type) {
  return map(data, isNumberType(type) ? (d, i) => coerceNumber(f(d, i)) : f, type);
}
function maybeTypedArrayify(data, type) {
  return type === void 0 ? arrayify(data) : isArrowVector(data) ? maybeTypedArrowify(data, type) : data instanceof type ? data : type.from(data, isNumberType(type) && !isNumberArray(data) ? coerceNumber : void 0);
}
function maybeTypedArrowify(vector2, type) {
  return vector2 == null ? vector2 : (type === void 0 || type === Array) && isArrowDateType(vector2.type) ? coerceDates(vectorToArray(vector2)) : maybeTypedArrayify(vectorToArray(vector2), type);
}
function vectorToArray(vector2) {
  return vector2.nullCount ? vector2.toJSON() : vector2.toArray();
}
var singleton = [null];
var field = (name) => (d) => {
  var _a;
  const v = d[name];
  return v === void 0 && d.type === "Feature" ? (_a = d.properties) == null ? void 0 : _a[name] : v;
};
var indexOf = { transform: range2 };
var identity2 = { transform: (d) => d };
var one = () => 1;
var yes = () => true;
var string = (x) => x == null ? x : `${x}`;
var number = (x) => x == null ? x : +x;
var first = (x) => x ? x[0] : void 0;
var second2 = (x) => x ? x[1] : void 0;
var third = (x) => x ? x[2] : void 0;
var constant = (x) => () => x;
function percentile(reduce) {
  const p = +`${reduce}`.slice(1) / 100;
  return (I, f) => quantile(I, p, f);
}
function coerceNumbers(values2) {
  return isNumberArray(values2) ? values2 : map(values2, coerceNumber, Float64Array);
}
function coerceNumber(x) {
  return x == null ? NaN : Number(x);
}
function coerceDates(values2) {
  return map(values2, coerceDate);
}
function coerceDate(x) {
  return x instanceof Date && !isNaN(x) ? x : typeof x === "string" ? parse(x) : x == null || isNaN(x = Number(x)) ? void 0 : new Date(x);
}
function maybeColorChannel(value, defaultValue) {
  if (value === void 0) value = defaultValue;
  return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
}
function maybeNumberChannel(value, defaultValue) {
  if (value === void 0) value = defaultValue;
  return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
}
function maybeKeyword(input, name, allowed) {
  if (input != null) return keyword(input, name, allowed);
}
function keyword(input, name, allowed) {
  const i = `${input}`.toLowerCase();
  if (!allowed.includes(i)) throw new Error(`invalid ${name}: ${input}`);
  return i;
}
function dataify(data) {
  return isArrowTable(data) ? data : arrayify(data);
}
function arrayify(values2) {
  if (values2 == null || isArray(values2)) return values2;
  if (isArrowVector(values2)) return maybeTypedArrowify(values2);
  if (isGeoJSON(values2)) {
    switch (values2.type) {
      case "FeatureCollection":
        return values2.features;
      case "GeometryCollection":
        return values2.geometries;
      default:
        return [values2];
    }
  }
  return Array.from(values2);
}
function isGeoJSON(x) {
  switch (x == null ? void 0 : x.type) {
    case "FeatureCollection":
    case "GeometryCollection":
    case "Feature":
    case "LineString":
    case "MultiLineString":
    case "MultiPoint":
    case "MultiPolygon":
    case "Point":
    case "Polygon":
    case "Sphere":
      return true;
    default:
      return false;
  }
}
function map(values2, f, type = Array) {
  return values2 == null ? values2 : values2 instanceof type ? values2.map(f) : type.from(values2, f);
}
function slice(values2, type = Array) {
  return values2 instanceof type ? values2.slice() : type.from(values2);
}
function hasX({ x, x1, x2 }) {
  return x !== void 0 || x1 !== void 0 || x2 !== void 0;
}
function hasY({ y, y1, y2 }) {
  return y !== void 0 || y1 !== void 0 || y2 !== void 0;
}
function hasXY(options) {
  return hasX(options) || hasY(options) || options.interval !== void 0;
}
function isObject(option) {
  return (option == null ? void 0 : option.toString) === objectToString;
}
function isScaleOptions(option) {
  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
}
function isOptions(option) {
  return isObject(option) && typeof option.transform !== "function";
}
function isDomainSort(sort3) {
  return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;
}
function maybeZero(x, x1, x2, x3 = identity2) {
  if (x1 === void 0 && x2 === void 0) {
    x1 = 0, x2 = x === void 0 ? x3 : x;
  } else if (x1 === void 0) {
    x1 = x === void 0 ? 0 : x;
  } else if (x2 === void 0) {
    x2 = x === void 0 ? 0 : x;
  }
  return [x1, x2];
}
function maybeTuple(x, y) {
  return x === void 0 && y === void 0 ? [first, second2] : [x, y];
}
function maybeZ({ z, fill, stroke } = {}) {
  if (z === void 0) [z] = maybeColorChannel(fill);
  if (z === void 0) [z] = maybeColorChannel(stroke);
  return z;
}
function lengthof(data) {
  return isArray(data) ? data.length : data == null ? void 0 : data.numRows;
}
function range2(data) {
  const n = lengthof(data);
  const r = new Uint32Array(n);
  for (let i = 0; i < n; ++i) r[i] = i;
  return r;
}
function take(values2, index) {
  return isArray(values2) ? map(index, (i) => values2[i], values2.constructor) : map(index, (i) => values2.at(i));
}
function taker(f) {
  return f.length === 1 ? (index, values2) => f(take(values2, index)) : f;
}
function subarray(I, i, j) {
  return I.subarray ? I.subarray(i, j) : I.slice(i, j);
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function maybeInput(key, options) {
  if (options[key] !== void 0) return options[key];
  switch (key) {
    case "x1":
    case "x2":
      key = "x";
      break;
    case "y1":
    case "y2":
      key = "y";
      break;
  }
  return options[key];
}
function column(source) {
  let value;
  return [
    {
      transform: () => value,
      label: labelof(source)
    },
    (v) => value = v
  ];
}
function maybeColumn(source) {
  return source == null ? [source] : column(source);
}
function labelof(value, defaultValue) {
  return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
}
function mid(x1, x2) {
  return {
    transform(data) {
      const X1 = x1.transform(data);
      const X2 = x2.transform(data);
      return isTemporal(X1) || isTemporal(X2) ? map(X1, (_, i) => new Date((+X1[i] + +X2[i]) / 2)) : map(X1, (_, i) => (+X1[i] + +X2[i]) / 2, Float64Array);
    },
    label: x1.label
  };
}
function maybeApplyInterval(V, scale2) {
  const t = maybeIntervalTransform(scale2 == null ? void 0 : scale2.interval, scale2 == null ? void 0 : scale2.type);
  return t ? map(V, t) : V;
}
function maybeIntervalTransform(interval, type) {
  const i = maybeInterval(interval, type);
  return i && ((v) => defined(v) ? i.floor(v) : v);
}
function maybeInterval(interval, type) {
  if (interval == null) return;
  if (typeof interval === "number") return numberInterval(interval);
  if (typeof interval === "string") return (type === "time" ? timeInterval : utcInterval)(interval);
  if (typeof interval.floor !== "function") throw new Error("invalid interval; missing floor method");
  if (typeof interval.offset !== "function") throw new Error("invalid interval; missing offset method");
  return interval;
}
function numberInterval(interval) {
  interval = +interval;
  if (0 < interval && interval < 1 && Number.isInteger(1 / interval)) interval = -1 / interval;
  const n = Math.abs(interval);
  return interval < 0 ? {
    floor: (d) => Math.floor(d * n) / n,
    offset: (d, s = 1) => (d * n + Math.floor(s)) / n,
    range: (lo, hi) => range(Math.ceil(lo * n), hi * n).map((x) => x / n)
  } : {
    floor: (d) => Math.floor(d / n) * n,
    offset: (d, s = 1) => d + n * Math.floor(s),
    range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x) => x * n)
  };
}
function maybeRangeInterval(interval, type) {
  interval = maybeInterval(interval, type);
  if (interval && typeof interval.range !== "function") throw new Error("invalid interval: missing range method");
  return interval;
}
function maybeNiceInterval(interval, type) {
  interval = maybeRangeInterval(interval, type);
  if (interval && typeof interval.ceil !== "function") throw new Error("invalid interval: missing ceil method");
  return interval;
}
function isTimeInterval(t) {
  return isInterval(t) && typeof (t == null ? void 0 : t.floor) === "function" && t.floor() instanceof Date;
}
function isInterval(t) {
  return typeof (t == null ? void 0 : t.range) === "function";
}
function maybeValue(value) {
  return value === void 0 || isOptions(value) ? value : { value };
}
function numberChannel(source) {
  return source == null ? null : {
    transform: (data) => valueof(data, source, Float64Array),
    label: labelof(source)
  };
}
function isTuples(data) {
  if (!isIterable(data)) return false;
  for (const d of data) {
    if (d == null) continue;
    return typeof d === "object" && "0" in d && "1" in d;
  }
}
function isIterable(value) {
  return value && typeof value[Symbol.iterator] === "function";
}
function isTextual(values2) {
  for (const value of values2) {
    if (value == null) continue;
    return typeof value !== "object" || value instanceof Date;
  }
}
function isOrdinal(values2) {
  for (const value of values2) {
    if (value == null) continue;
    const type = typeof value;
    return type === "string" || type === "boolean";
  }
}
function isTemporal(values2) {
  for (const value of values2) {
    if (value == null) continue;
    return value instanceof Date;
  }
}
function isTemporalString(values2) {
  for (const value of values2) {
    if (value == null) continue;
    return typeof value === "string" && isNaN(value) && parse(value);
  }
}
function isNumericString(values2) {
  for (const value of values2) {
    if (value == null) continue;
    if (typeof value !== "string") return false;
    if (!value.trim()) continue;
    return !isNaN(value);
  }
}
function isNumeric(values2) {
  for (const value of values2) {
    if (value == null) continue;
    return typeof value === "number";
  }
}
function isEvery(values2, is) {
  let every;
  for (const value of values2) {
    if (value == null) continue;
    if (!is(value)) return false;
    every = true;
  }
  return every;
}
var namedColors = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
function isColor(value) {
  if (typeof value !== "string") return false;
  value = value.toLowerCase().trim();
  return /^#[0-9a-f]{3,8}$/.test(value) || // hex rgb, rgba, rrggbb, rrggbbaa
  /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\(.*\)$/.test(value) || // <funciri>, CSS variable, color, etc.
  namedColors.has(value);
}
function isOpacity(value) {
  return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
}
function isNoneish(value) {
  return value == null || isNone(value);
}
function isNone(value) {
  return /^\s*none\s*$/i.test(value);
}
function isRound(value) {
  return /^\s*round\s*$/i.test(value);
}
function maybeAnchor(value, name) {
  return maybeKeyword(value, name, [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function maybeFrameAnchor(value = "middle") {
  return maybeAnchor(value, "frameAnchor");
}
function inherit(options = {}, ...rest) {
  let o = options;
  for (const defaults22 of rest) {
    for (const key in defaults22) {
      if (o[key] === void 0) {
        const value = defaults22[key];
        if (o === options) o = { ...o, [key]: value };
        else o[key] = value;
      }
    }
  }
  return o;
}
function named(things) {
  console.warn("named iterables are deprecated; please use an object instead");
  const names = /* @__PURE__ */ new Set();
  return Object.fromEntries(
    Array.from(things, (thing) => {
      const { name } = thing;
      if (name == null) throw new Error("missing name");
      const key = `${name}`;
      if (key === "__proto__") throw new Error(`illegal name: ${key}`);
      if (names.has(key)) throw new Error(`duplicate name: ${key}`);
      names.add(key);
      return [name, thing];
    })
  );
}
function maybeNamed(things) {
  return isIterable(things) ? named(things) : things;
}
function maybeClip(clip) {
  if (clip === true) clip = "frame";
  else if (clip === false) clip = null;
  else if (!isGeoJSON(clip) && clip != null) {
    clip = keyword(clip, "clip", ["frame", "sphere"]);
    if (clip === "sphere") clip = { type: "Sphere" };
  }
  return clip;
}
function isArrowTable(value) {
  return value && typeof value.getChild === "function" && typeof value.toArray === "function" && value.schema && Array.isArray(value.schema.fields);
}
function isArrowVector(value) {
  return value && typeof value.toArray === "function" && value.type;
}
function isArrowDateType(type) {
  return type && (type.typeId === 8 || // date
  type.typeId === 10) && // timestamp
  type.unit === 1;
}

// node_modules/@observablehq/plot/src/scales/index.js
var position = Symbol("position");
var color = Symbol("color");
var radius = Symbol("radius");
var length = Symbol("length");
var opacity = Symbol("opacity");
var symbol = Symbol("symbol");
var projection = Symbol("projection");
var registry = /* @__PURE__ */ new Map([
  ["x", position],
  ["y", position],
  ["fx", position],
  ["fy", position],
  ["r", radius],
  ["color", color],
  ["opacity", opacity],
  ["symbol", symbol],
  ["length", length],
  ["projection", projection]
]);
function isPosition(kind) {
  return kind === position || kind === projection;
}
function hasNumericRange(kind) {
  return kind === position || kind === radius || kind === length || kind === opacity;
}

// node_modules/@observablehq/plot/src/symbol.js
var sqrt3 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt3;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", times_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  return value && typeof value.draw === "function";
}
function isSymbol(value) {
  if (isSymbolObject(value)) return true;
  if (typeof value !== "string") return false;
  return symbols.has(value.toLowerCase());
}
function maybeSymbol(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2)) return symbol2;
  const value = symbols.get(`${symbol2}`.toLowerCase());
  if (value) return value;
  throw new Error(`invalid symbol: ${symbol2}`);
}
function maybeSymbolChannel(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2)) return [void 0, symbol2];
  if (typeof symbol2 === "string") {
    const value = symbols.get(`${symbol2}`.toLowerCase());
    if (value) return [void 0, value];
  }
  return [symbol2, void 0];
}

// node_modules/@observablehq/plot/src/transforms/basic.js
function basic({ filter: f1, sort: s1, reverse: r1, transform: t1, initializer: i1, ...options } = {}, transform) {
  if (t1 === void 0) {
    if (f1 != null) t1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1)) t1 = composeTransform(t1, sortTransform(s1));
    if (r1) t1 = composeTransform(t1, reverseTransform);
  }
  if (transform != null && i1 != null) throw new Error("transforms cannot be applied after initializers");
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    transform: composeTransform(t1, transform)
  };
}
function initializer({ filter: f1, sort: s1, reverse: r1, initializer: i1, ...options } = {}, initializer2) {
  if (i1 === void 0) {
    if (f1 != null) i1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1)) i1 = composeInitializer(i1, sortTransform(s1));
    if (r1) i1 = composeInitializer(i1, reverseTransform);
  }
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    initializer: composeInitializer(i1, initializer2)
  };
}
function composeTransform(t1, t2) {
  if (t1 == null) return t2 === null ? void 0 : t2;
  if (t2 == null) return t1 === null ? void 0 : t1;
  return function(data, facets, plotOptions) {
    ({ data, facets } = t1.call(this, data, facets, plotOptions));
    return t2.call(this, dataify(data), facets, plotOptions);
  };
}
function composeInitializer(i1, i2) {
  if (i1 == null) return i2 === null ? void 0 : i2;
  if (i2 == null) return i1 === null ? void 0 : i1;
  return function(data, facets, channels, ...args) {
    let c1, d1, f1, c2, d2, f2;
    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, ...args));
    ({ data: d2 = d1, facets: f2 = f1, channels: c2 } = i2.call(this, d1, f1, { ...channels, ...c1 }, ...args));
    return { data: d2, facets: f2, channels: { ...c1, ...c2 } };
  };
}
function apply(options, t) {
  return (options.initializer != null ? initializer : basic)(options, t);
}
function filter(test, options) {
  return apply(options, filterTransform(test));
}
function filterTransform(value) {
  return (data, facets) => {
    const V = valueof(data, value);
    return { data, facets: facets.map((I) => I.filter((i) => V[i])) };
  };
}
function reverse2({ sort: sort3, ...options } = {}) {
  return {
    ...apply(options, reverseTransform),
    sort: isDomainSort(sort3) ? sort3 : null
  };
}
function reverseTransform(data, facets) {
  return { data, facets: facets.map((I) => I.slice().reverse()) };
}
function shuffle({ seed, sort: sort3, ...options } = {}) {
  return {
    ...apply(options, sortValue(seed == null ? Math.random : lcg(seed))),
    sort: isDomainSort(sort3) ? sort3 : null
  };
}
function sort2(order, { sort: sort3, ...options } = {}) {
  return {
    ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),
    sort: isDomainSort(sort3) ? sort3 : null
  };
}
function sortTransform(value) {
  return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
}
function sortData(compare) {
  return (data, facets) => {
    const compareData = isArray(data) ? (i, j) => compare(data[i], data[j]) : (i, j) => compare(data.get(i), data.get(j));
    return { data, facets: facets.map((I) => I.slice().sort(compareData)) };
  };
}
function sortValue(value) {
  let channel, order;
  ({ channel, value, order } = { ...maybeValue(value) });
  const negate = channel == null ? void 0 : channel.startsWith("-");
  if (negate) channel = channel.slice(1);
  if (order === void 0) order = negate ? descendingDefined : ascendingDefined;
  if (typeof order !== "function") {
    switch (`${order}`.toLowerCase()) {
      case "ascending":
        order = ascendingDefined;
        break;
      case "descending":
        order = descendingDefined;
        break;
      default:
        throw new Error(`invalid order: ${order}`);
    }
  }
  return (data, facets, channels) => {
    let V;
    if (channel === void 0) {
      V = valueof(data, value);
    } else {
      if (channels === void 0) throw new Error("channel sort requires an initializer");
      V = channels[channel];
      if (!V) return {};
      V = V.value;
    }
    const compareValue = (i, j) => order(V[i], V[j]);
    return { data, facets: facets.map((I) => I.slice().sort(compareValue)) };
  };
}

// node_modules/@observablehq/plot/src/transforms/group.js
function groupZ(outputs, options) {
  return groupn(null, null, outputs, options);
}
function groupX(outputs = { y: "count" }, options = {}) {
  const { x = identity2 } = options;
  if (x == null) throw new Error("missing channel: x");
  return groupn(x, null, outputs, options);
}
function groupY(outputs = { x: "count" }, options = {}) {
  const { y = identity2 } = options;
  if (y == null) throw new Error("missing channel: y");
  return groupn(null, y, outputs, options);
}
function group2(outputs = { fill: "count" }, options = {}) {
  let { x, y } = options;
  [x, y] = maybeTuple(x, y);
  if (x == null) throw new Error("missing channel: x");
  if (y == null) throw new Error("missing channel: y");
  return groupn(x, y, outputs, options);
}
function groupn(x, y, {
  data: reduceData = reduceIdentity,
  filter: filter2,
  sort: sort3,
  reverse: reverse3,
  ...outputs
  // output channel definitions
} = {}, inputs = {}) {
  outputs = maybeGroupOutputs(outputs, inputs);
  reduceData = maybeGroupReduce(reduceData, identity2);
  sort3 = sort3 == null ? void 0 : maybeGroupOutput("sort", sort3, inputs);
  filter2 = filter2 == null ? void 0 : maybeGroupEvaluator("filter", filter2, inputs);
  const [GX, setGX] = maybeColumn(x);
  const [GY, setGY] = maybeColumn(y);
  const {
    z,
    fill,
    stroke,
    x1,
    x2,
    // consumed if x is an output
    y1,
    y2,
    // consumed if y is an output
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets, plotOptions) => {
      const X = maybeApplyInterval(valueof(data, x), plotOptions == null ? void 0 : plotOptions.x);
      const Y = maybeApplyInterval(valueof(data, y), plotOptions == null ? void 0 : plotOptions.y);
      const Z = valueof(data, z);
      const F = valueof(data, vfill);
      const S = valueof(data, vstroke);
      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });
      const groupFacets = [];
      const groupData = [];
      const GX2 = X && setGX([]);
      const GY2 = Y && setGY([]);
      const GZ2 = Z && setGZ([]);
      const GF2 = F && setGF([]);
      const GS2 = S && setGS([]);
      let i = 0;
      for (const o of outputs) o.initialize(data);
      if (sort3) sort3.initialize(data);
      if (filter2) filter2.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o of outputs) o.scope("facet", facet);
        if (sort3) sort3.scope("facet", facet);
        if (filter2) filter2.scope("facet", facet);
        for (const [f, I] of maybeGroup(facet, G)) {
          for (const [y3, gg] of maybeGroup(I, Y)) {
            for (const [x3, g] of maybeGroup(gg, X)) {
              const extent3 = { data };
              if (X) extent3.x = x3;
              if (Y) extent3.y = y3;
              if (G) extent3.z = f;
              if (filter2 && !filter2.reduce(g, extent3)) continue;
              groupFacet.push(i++);
              groupData.push(reduceData.reduceIndex(g, data, extent3));
              if (X) GX2.push(x3);
              if (Y) GY2.push(y3);
              if (Z) GZ2.push(G === Z ? f : Z[g[0]]);
              if (F) GF2.push(G === F ? f : F[g[0]]);
              if (S) GS2.push(G === S ? f : S[g[0]]);
              for (const o of outputs) o.reduce(g, extent3);
              if (sort3) sort3.reduce(g, extent3);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort3, reverse3);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (GX ? { x: GX } : { x1, x2 }),
    ...!hasOutput(outputs, "y") && (GY ? { y: GY } : { y1, y2 }),
    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
  };
}
function hasOutput(outputs, ...names) {
  for (const { name } of outputs) {
    if (names.includes(name)) {
      return true;
    }
  }
  return false;
}
function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
  const entries = Object.entries(outputs);
  if (inputs.title != null && outputs.title === void 0) entries.push(["title", reduceTitle]);
  if (inputs.href != null && outputs.href === void 0) entries.push(["href", reduceFirst]);
  return entries.filter(([, reduce]) => reduce !== void 0).map(([name, reduce]) => reduce === null ? nullOutput(name) : asOutput(name, reduce, inputs));
}
function maybeOutput(name, reduce, inputs, asEvaluator = maybeEvaluator) {
  let scale2;
  if (isObject(reduce) && "reduce" in reduce) scale2 = reduce.scale, reduce = reduce.reduce;
  const evaluator = asEvaluator(name, reduce, inputs);
  const [output, setOutput] = column(evaluator.label);
  let O;
  return {
    name,
    output: scale2 === void 0 ? output : { value: output, scale: scale2 },
    initialize(data) {
      evaluator.initialize(data);
      O = setOutput([]);
    },
    scope(scope, I) {
      evaluator.scope(scope, I);
    },
    reduce(I, extent3) {
      O.push(evaluator.reduce(I, extent3));
    }
  };
}
function nullOutput(name) {
  return { name, initialize() {
  }, scope() {
  }, reduce() {
  } };
}
function maybeEvaluator(name, reduce, inputs, asReduce = maybeReduce) {
  const input = maybeInput(name, inputs);
  const reducer = asReduce(reduce, input);
  let V, context;
  return {
    label: labelof(reducer === reduceCount ? null : input, reducer.label),
    initialize(data) {
      V = input === void 0 ? data : valueof(data, input);
      if (reducer.scope === "data") {
        context = reducer.reduceIndex(range2(data), V);
      }
    },
    scope(scope, I) {
      if (reducer.scope === scope) {
        context = reducer.reduceIndex(I, V);
      }
    },
    reduce(I, extent3) {
      return reducer.scope == null ? reducer.reduceIndex(I, V, extent3) : reducer.reduceIndex(I, V, context, extent3);
    }
  };
}
function maybeGroup(I, X) {
  return X ? group(I, (i) => X[i]) : [[, I]];
}
function maybeReduce(reduce, value, fallback = invalidReduce) {
  if (reduce == null) return fallback(reduce);
  if (typeof reduce.reduceIndex === "function") return reduce;
  if (typeof reduce.reduce === "function" && isObject(reduce)) return reduceReduce(reduce);
  if (typeof reduce === "function") return reduceFunction(reduce);
  if (/^p\d{2}$/i.test(reduce)) return reduceAccessor(percentile(reduce));
  switch (`${reduce}`.toLowerCase()) {
    case "first":
      return reduceFirst;
    case "last":
      return reduceLast;
    case "identity":
      return reduceIdentity;
    case "count":
      return reduceCount;
    case "distinct":
      return reduceDistinct;
    case "sum":
      return value == null ? reduceCount : reduceSum;
    case "proportion":
      return reduceProportion(value, "data");
    case "proportion-facet":
      return reduceProportion(value, "facet");
    case "deviation":
      return reduceAccessor(deviation);
    case "min":
      return reduceAccessor(min);
    case "min-index":
      return reduceAccessor(minIndex);
    case "max":
      return reduceAccessor(max);
    case "max-index":
      return reduceAccessor(maxIndex);
    case "mean":
      return reduceMaybeTemporalAccessor(mean);
    case "median":
      return reduceMaybeTemporalAccessor(median);
    case "variance":
      return reduceAccessor(variance);
    case "mode":
      return reduceAccessor(mode);
  }
  return fallback(reduce);
}
function invalidReduce(reduce) {
  throw new Error(`invalid reduce: ${reduce}`);
}
function maybeGroupOutputs(outputs, inputs) {
  return maybeOutputs(outputs, inputs, maybeGroupOutput);
}
function maybeGroupOutput(name, reduce, inputs) {
  return maybeOutput(name, reduce, inputs, maybeGroupEvaluator);
}
function maybeGroupEvaluator(name, reduce, inputs) {
  return maybeEvaluator(name, reduce, inputs, maybeGroupReduce);
}
function maybeGroupReduce(reduce, value) {
  return maybeReduce(reduce, value, maybeGroupReduceFallback);
}
function maybeGroupReduceFallback(reduce) {
  switch (`${reduce}`.toLowerCase()) {
    case "x":
      return reduceX;
    case "y":
      return reduceY;
    case "z":
      return reduceZ;
  }
  throw new Error(`invalid group reduce: ${reduce}`);
}
function maybeSubgroup(outputs, inputs) {
  for (const name in inputs) {
    const value = inputs[name];
    if (value !== void 0 && !outputs.some((o) => o.name === name)) {
      return value;
    }
  }
}
function maybeSort(facets, sort3, reverse3) {
  if (sort3) {
    const S = sort3.output.transform();
    const compare = (i, j) => ascendingDefined(S[i], S[j]);
    facets.forEach((f) => f.sort(compare));
  }
  if (reverse3) {
    facets.forEach((f) => f.reverse());
  }
}
function reduceReduce(reduce) {
  console.warn("deprecated reduce interface; implement reduceIndex instead.");
  return { ...reduce, reduceIndex: reduce.reduce.bind(reduce) };
}
function reduceFunction(f) {
  return {
    reduceIndex(I, X, extent3) {
      return f(take(X, I), extent3);
    }
  };
}
function reduceAccessor(f) {
  return {
    reduceIndex(I, X) {
      return f(I, (i) => X[i]);
    }
  };
}
function reduceMaybeTemporalAccessor(f) {
  return {
    reduceIndex(I, X) {
      const x = f(I, (i) => X[i]);
      return isTemporal(X) ? new Date(x) : x;
    }
  };
}
var reduceIdentity = {
  reduceIndex(I, X) {
    return take(X, I);
  }
};
var reduceFirst = {
  reduceIndex(I, X) {
    return X[I[0]];
  }
};
var reduceTitle = {
  reduceIndex(I, X) {
    const n = 5;
    const groups = sort(
      rollup(
        I,
        (V) => V.length,
        (i) => X[i]
      ),
      second2
    );
    const top = groups.slice(-n).reverse();
    if (top.length < groups.length) {
      const bottom = groups.slice(0, 1 - n);
      top[n - 1] = [`… ${bottom.length.toLocaleString("en-US")} more`, sum(bottom, second2)];
    }
    return top.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
  }
};
var reduceLast = {
  reduceIndex(I, X) {
    return X[I[I.length - 1]];
  }
};
var reduceCount = {
  label: "Frequency",
  reduceIndex(I) {
    return I.length;
  }
};
var reduceDistinct = {
  label: "Distinct",
  reduceIndex(I, X) {
    const s = new InternSet();
    for (const i of I) s.add(X[i]);
    return s.size;
  }
};
var reduceSum = reduceAccessor(sum);
function reduceProportion(value, scope) {
  return value == null ? { scope, label: "Frequency", reduceIndex: (I, V, basis = 1) => I.length / basis } : { scope, reduceIndex: (I, V, basis = 1) => sum(I, (i) => V[i]) / basis };
}
var reduceX = {
  reduceIndex(I, X, { x }) {
    return x;
  }
};
var reduceY = {
  reduceIndex(I, X, { y }) {
    return y;
  }
};
var reduceZ = {
  reduceIndex(I, X, { z }) {
    return z;
  }
};
function find(test) {
  if (typeof test !== "function") throw new Error(`invalid test function: ${test}`);
  return {
    reduceIndex(I, V, { data }) {
      return V[I.find(isArray(data) ? (i) => test(data[i], i, data) : (i) => test(data.get(i), i, data))];
    }
  };
}

// node_modules/@observablehq/plot/src/channel.js
function createChannel(data, { scale: scale2, type, value, filter: filter2, hint, label = labelof(value) }, name) {
  if (hint === void 0 && typeof (value == null ? void 0 : value.transform) === "function") hint = value.hint;
  return inferChannelScale(name, {
    scale: scale2,
    type,
    value: valueof(data, value),
    label,
    filter: filter2,
    hint
  });
}
function createChannels(channels, data) {
  return Object.fromEntries(
    Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])
  );
}
function valueObject(channels, scales) {
  const values2 = Object.fromEntries(
    Object.entries(channels).map(([name, { scale: scaleName, value }]) => {
      const scale2 = scaleName == null ? null : scales[scaleName];
      return [name, scale2 == null ? value : map(value, scale2)];
    })
  );
  values2.channels = channels;
  return values2;
}
function inferChannelScale(name, channel) {
  const { scale: scale2, value } = channel;
  if (scale2 === true || scale2 === "auto") {
    switch (name) {
      case "fill":
      case "stroke":
      case "color":
        channel.scale = scale2 !== true && isEvery(value, isColor) ? null : "color";
        channel.defaultScale = "color";
        break;
      case "fillOpacity":
      case "strokeOpacity":
      case "opacity":
        channel.scale = scale2 !== true && isEvery(value, isOpacity) ? null : "opacity";
        channel.defaultScale = "opacity";
        break;
      case "symbol":
        if (scale2 !== true && isEvery(value, isSymbol)) {
          channel.scale = null;
          channel.value = map(value, maybeSymbol);
        } else {
          channel.scale = "symbol";
        }
        channel.defaultScale = "symbol";
        break;
      default:
        channel.scale = registry.has(name) ? name : null;
        break;
    }
  } else if (scale2 === false) {
    channel.scale = null;
  } else if (scale2 != null && !registry.has(scale2)) {
    throw new Error(`unknown scale: ${scale2}`);
  }
  return channel;
}
function channelDomain(data, facets, channels, facetChannels, options) {
  const { order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;
  for (const x in options) {
    if (!registry.has(x)) continue;
    let { value: y, order = defaultOrder, reverse: reverse3 = defaultReverse, reduce = defaultReduce, limit = defaultLimit } = maybeValue(options[x]);
    const negate = y == null ? void 0 : y.startsWith("-");
    if (negate) y = y.slice(1);
    order = order === void 0 ? negate !== (y === "width" || y === "height") ? descendingGroup : ascendingGroup : maybeOrder(order);
    if (reduce == null || reduce === false) continue;
    const X = x === "fx" || x === "fy" ? reindexFacetChannel(facets, facetChannels[x]) : findScaleChannel(channels, x);
    if (!X) throw new Error(`missing channel for scale: ${x}`);
    const XV = X.value;
    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
    if (y == null) {
      X.domain = () => {
        let domain = Array.from(new InternSet(XV));
        if (reverse3) domain = domain.reverse();
        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);
        return domain;
      };
    } else {
      const YV = y === "data" ? data : y === "height" ? difference(channels, "y1", "y2") : y === "width" ? difference(channels, "x1", "x2") : values(channels, y, y === "y" ? "y2" : y === "x" ? "x2" : void 0);
      const reducer = maybeReduce(reduce === true ? "max" : reduce, YV);
      X.domain = () => {
        let domain = rollups(
          range2(XV),
          (I) => reducer.reduceIndex(I, YV),
          (i) => XV[i]
        );
        if (order) domain.sort(order);
        if (reverse3) domain.reverse();
        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);
        return domain.map(first);
      };
    }
  }
}
function findScaleChannel(channels, scale2) {
  for (const name in channels) {
    const channel = channels[name];
    if (channel.scale === scale2) return channel;
  }
}
function reindexFacetChannel(facets, channel) {
  const originalFacets = facets.original;
  if (originalFacets === facets) return channel;
  const V1 = channel.value;
  const V2 = channel.value = [];
  for (let i = 0; i < originalFacets.length; ++i) {
    const vi = V1[originalFacets[i][0]];
    for (const j of facets[i]) V2[j] = vi;
  }
  return channel;
}
function difference(channels, k1, k2) {
  const X1 = values(channels, k1);
  const X2 = values(channels, k2);
  return map(X2, (x2, i) => Math.abs(x2 - X1[i]), Float64Array);
}
function values(channels, name, alias) {
  let channel = channels[name];
  if (!channel && alias !== void 0) channel = channels[alias];
  if (channel) return channel.value;
  throw new Error(`missing channel: ${name}`);
}
function maybeOrder(order) {
  if (order == null || typeof order === "function") return order;
  switch (`${order}`.toLowerCase()) {
    case "ascending":
      return ascendingGroup;
    case "descending":
      return descendingGroup;
  }
  throw new Error(`invalid order: ${order}`);
}
function ascendingGroup([ak, av], [bk, bv]) {
  return ascendingDefined(av, bv) || ascendingDefined(ak, bk);
}
function descendingGroup([ak, av], [bk, bv]) {
  return descendingDefined(av, bv) || ascendingDefined(ak, bk);
}
function getSource(channels, key) {
  let channel = channels[key];
  if (!channel) return;
  while (channel.source) channel = channel.source;
  return channel.source === null ? null : channel;
}

// node_modules/@observablehq/plot/src/scales/schemes.js
var categoricalSchemes = /* @__PURE__ */ new Map([
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["observable10", observable10_default],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default]
]);
function isCategoricalScheme(scheme28) {
  return scheme28 != null && categoricalSchemes.has(`${scheme28}`.toLowerCase());
}
var ordinalSchemes = new Map([
  ...categoricalSchemes,
  // diverging
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  // reversed diverging (for temperature data)
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  // sequential (single-hue)
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  // sequential (multi-hue)
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  // cyclical
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function scheme92(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 1) return [scheme28[3][1]];
    if (n === 2) return [scheme28[3][1], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme112(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2) return [scheme28[3][0], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme11r(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2) return [scheme28[3][2], scheme28[3][0]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();
  };
}
function schemei(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));
}
function schemeicyclical(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s = `${scheme28}`.toLowerCase();
  if (!ordinalSchemes.has(s)) throw new Error(`unknown ordinal scheme: ${s}`);
  return ordinalSchemes.get(s);
}
function ordinalRange(scheme28, length2) {
  const s = ordinalScheme(scheme28);
  const r = typeof s === "function" ? s({ length: length2 }) : s;
  return r.length !== length2 ? r.slice(0, length2) : r;
}
function maybeBooleanRange(domain, scheme28 = "greys") {
  const range3 = /* @__PURE__ */ new Set();
  const [f, t] = ordinalRange(scheme28, 2);
  for (const value of domain) {
    if (value == null) continue;
    if (value === true) range3.add(t);
    else if (value === false) range3.add(f);
    else return;
  }
  return [...range3];
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  // reversed diverging (for temperature data)
  ["burd", (t) => RdBu_default(1 - t)],
  ["buylrd", (t) => RdYlBu_default(1 - t)],
  // sequential (single-hue)
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  // sequential (multi-hue)
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  // cyclical
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function quantitativeScheme(scheme28) {
  const s = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s)) throw new Error(`unknown quantitative scheme: ${s}`);
  return quantitativeSchemes.get(s);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}

// node_modules/@observablehq/plot/src/scales/quantitative.js
var flip = (i) => (t) => i(1 - t);
var unit = [0, 1];
var interpolators = /* @__PURE__ */ new Map([
  // numbers
  ["number", number_default],
  // color spaces
  ["rgb", rgb_default],
  ["hsl", hsl_default],
  ["hcl", hcl_default],
  ["lab", lab]
]);
function maybeInterpolator(interpolate) {
  const i = `${interpolate}`.toLowerCase();
  if (!interpolators.has(i)) throw new Error(`unknown interpolator: ${i}`);
  return interpolators.get(i);
}
function createScaleQ(key, scale2, channels, {
  type,
  nice: nice2,
  clamp,
  zero,
  domain = inferAutoDomain(key, channels),
  unknown,
  round: round2,
  scheme: scheme28,
  interval,
  range: range3 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit : void 0,
  interpolate = registry.get(key) === color ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type === "cyclical" ? "rainbow" : "turbo") : round2 ? round_default : number_default,
  reverse: reverse3
}) {
  domain = maybeRepeat(domain);
  interval = maybeRangeInterval(interval, type);
  if (type === "cyclical" || type === "sequential") type = "linear";
  if (typeof interpolate !== "function") interpolate = maybeInterpolator(interpolate);
  reverse3 = !!reverse3;
  if (range3 !== void 0) {
    const n = domain.length;
    const m = (range3 = maybeRepeat(range3)).length;
    if (n !== m) {
      if (interpolate.length === 1) throw new Error("invalid piecewise interpolator");
      interpolate = piecewise(interpolate, range3);
      range3 = void 0;
    }
  }
  if (interpolate.length === 1) {
    if (reverse3) {
      interpolate = flip(interpolate);
      reverse3 = false;
    }
    if (range3 === void 0) {
      range3 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
      if (range3.length === 2) range3 = unit;
    }
    scale2.interpolate((range3 === unit ? constant : interpolatePiecewise)(interpolate));
  } else {
    scale2.interpolate(interpolate);
  }
  if (zero) {
    const [min2, max2] = extent(domain);
    if (min2 > 0 || max2 < 0) {
      domain = slice(domain);
      const o = orderof(domain) || 1;
      if (o === Math.sign(min2)) domain[0] = 0;
      else domain[domain.length - 1] = 0;
    }
  }
  if (reverse3) domain = reverse(domain);
  scale2.domain(domain).unknown(unknown);
  if (nice2) scale2.nice(maybeNice(nice2, type)), domain = scale2.domain();
  if (range3 !== void 0) scale2.range(range3);
  if (clamp) scale2.clamp(clamp);
  return { type, domain, range: range3, scale: scale2, interpolate, interval };
}
function maybeRepeat(values2) {
  values2 = arrayify(values2);
  return values2.length >= 2 ? values2 : [values2[0], values2[0]];
}
function maybeNice(nice2, type) {
  return nice2 === true ? void 0 : typeof nice2 === "number" ? nice2 : maybeNiceInterval(nice2, type);
}
function createScaleLinear(key, channels, options) {
  return createScaleQ(key, linear(), channels, options);
}
function createScaleSqrt(key, channels, options) {
  return createScalePow(key, channels, { ...options, exponent: 0.5 });
}
function createScalePow(key, channels, { exponent = 1, ...options }) {
  return createScaleQ(key, pow().exponent(exponent), channels, { ...options, type: "pow" });
}
function createScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
  return createScaleQ(key, log().base(base), channels, { ...options, domain });
}
function createScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleQ(key, symlog().constant(constant2), channels, options);
}
function createScaleQuantile(key, channels, {
  range: range3,
  quantiles = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  // deprecated; use n instead
  n = quantiles,
  scheme: scheme28 = "rdylbu",
  domain = inferQuantileDomain(channels),
  unknown,
  interpolate,
  reverse: reverse3
}) {
  if (range3 === void 0) {
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color ? ordinalRange(scheme28, n) : void 0;
  }
  if (domain.length > 0) {
    domain = quantile2(domain, range3 === void 0 ? { length: n } : range3).quantiles();
  }
  return createScaleThreshold(key, channels, { domain, range: range3, reverse: reverse3, unknown });
}
function createScaleQuantize(key, channels, {
  range: range3,
  n = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  scheme: scheme28 = "rdylbu",
  domain = inferAutoDomain(key, channels),
  unknown,
  interpolate,
  reverse: reverse3
}) {
  const [min2, max2] = extent(domain);
  let thresholds;
  if (range3 === void 0) {
    thresholds = ticks(min2, max2, n);
    if (thresholds[0] <= min2) thresholds.splice(0, 1);
    if (thresholds[thresholds.length - 1] >= max2) thresholds.pop();
    n = thresholds.length + 1;
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color ? ordinalRange(scheme28, n) : void 0;
  } else {
    thresholds = quantize_default(number_default(min2, max2), n + 1).slice(1, -1);
    if (min2 instanceof Date) thresholds = thresholds.map((x) => new Date(x));
  }
  if (orderof(arrayify(domain)) < 0) thresholds.reverse();
  return createScaleThreshold(key, channels, { domain: thresholds, range: range3, reverse: reverse3, unknown });
}
function createScaleThreshold(key, channels, {
  domain = [0],
  // explicit thresholds in ascending order
  unknown,
  scheme: scheme28 = "rdylbu",
  interpolate,
  range: range3 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color ? ordinalRange(scheme28, domain.length + 1) : void 0,
  reverse: reverse3
}) {
  domain = arrayify(domain);
  const sign = orderof(domain);
  if (!isNaN(sign) && !isOrdered(domain, sign)) throw new Error(`the ${key} scale has a non-monotonic domain`);
  if (reverse3) range3 = reverse(range3);
  return {
    type: "threshold",
    scale: threshold(sign < 0 ? reverse(domain) : domain, range3 === void 0 ? [] : range3).unknown(unknown),
    domain,
    range: range3
  };
}
function isOrdered(domain, sign) {
  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {
    const s = descending(d, d = domain[i]);
    if (s !== 0 && s !== sign) return false;
  }
  return true;
}
function createScaleIdentity(key) {
  return { type: "identity", scale: hasNumericRange(registry.get(key)) ? identity() : (d) => d };
}
function inferDomain(channels, f = finite) {
  return channels.length ? [
    min(channels, ({ value }) => value === void 0 ? value : min(value, f)),
    max(channels, ({ value }) => value === void 0 ? value : max(value, f))
  ] : [0, 1];
}
function inferAutoDomain(key, channels) {
  const type = registry.get(key);
  return (type === radius || type === opacity || type === length ? inferZeroDomain : inferDomain)(channels);
}
function inferZeroDomain(channels) {
  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite)) : 1];
}
function inferRadialRange(channels, domain) {
  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
  if (hint !== void 0) return [0, hint.radius];
  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
  const range3 = domain.map((d) => 3 * Math.sqrt(d / h25));
  const k = 30 / max(range3);
  return k < 1 ? range3.map((r) => r * k) : range3;
}
function inferLengthRange(channels, domain) {
  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
  const range3 = domain.map((d) => 12 * d / h50);
  const k = 60 / max(range3);
  return k < 1 ? range3.map((r) => r * k) : range3;
}
function inferLogDomain(channels) {
  for (const { value } of channels) {
    if (value !== void 0) {
      for (let v of value) {
        if (v > 0) return inferDomain(channels, positive);
        if (v < 0) return inferDomain(channels, negative);
      }
    }
  }
  return [1, 10];
}
function inferQuantileDomain(channels) {
  const domain = [];
  for (const { value } of channels) {
    if (value === void 0) continue;
    for (const v of value) domain.push(v);
  }
  return domain;
}
function interpolatePiecewise(interpolate) {
  return (i, j) => (t) => interpolate(i + t * (j - i));
}

// node_modules/@observablehq/plot/src/warnings.js
var warnings = 0;
var lastMessage;
function consumeWarnings() {
  const w = warnings;
  warnings = 0;
  lastMessage = void 0;
  return w;
}
function warn(message) {
  if (message === lastMessage) return;
  lastMessage = message;
  console.warn(message);
  ++warnings;
}

// node_modules/@observablehq/plot/src/scales/diverging.js
function createScaleD(key, scale2, transform, channels, {
  type,
  nice: nice2,
  clamp,
  domain = inferDomain(channels),
  unknown,
  pivot = 0,
  scheme: scheme28,
  range: range3,
  symmetric = true,
  interpolate = registry.get(key) === color ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
  reverse: reverse3
}) {
  pivot = +pivot;
  domain = arrayify(domain);
  let [min2, max2] = domain;
  if (domain.length > 2) warn(`Warning: the diverging ${key} scale domain contains extra elements.`);
  if (descending(min2, max2) < 0) [min2, max2] = [max2, min2], reverse3 = !reverse3;
  min2 = Math.min(min2, pivot);
  max2 = Math.max(max2, pivot);
  if (typeof interpolate !== "function") {
    interpolate = maybeInterpolator(interpolate);
  }
  if (range3 !== void 0) {
    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range3) : piecewise(interpolate, range3);
  }
  if (reverse3) interpolate = flip(interpolate);
  if (symmetric) {
    const mid2 = transform.apply(pivot);
    const mindelta = mid2 - transform.apply(min2);
    const maxdelta = transform.apply(max2) - mid2;
    if (mindelta < maxdelta) min2 = transform.invert(mid2 - maxdelta);
    else if (mindelta > maxdelta) max2 = transform.invert(mid2 + mindelta);
  }
  scale2.domain([min2, pivot, max2]).unknown(unknown).interpolator(interpolate);
  if (clamp) scale2.clamp(clamp);
  if (nice2) scale2.nice(nice2);
  return { type, domain: [min2, max2], pivot, interpolate, scale: scale2 };
}
function createScaleDiverging(key, channels, options) {
  return createScaleD(key, diverging(), transformIdentity, channels, options);
}
function createScaleDivergingSqrt(key, channels, options) {
  return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
}
function createScaleDivergingPow(key, channels, { exponent = 1, ...options }) {
  return createScaleD(key, divergingPow().exponent(exponent = +exponent), transformPow(exponent), channels, {
    ...options,
    type: "diverging-pow"
  });
}
function createScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {
  return createScaleD(key, divergingLog().base(base = +base), transformLog, channels, {
    domain,
    pivot,
    ...options
  });
}
function createScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleD(
    key,
    divergingSymlog().constant(constant2 = +constant2),
    transformSymlog(constant2),
    channels,
    options
  );
}
var transformIdentity = {
  apply(x) {
    return x;
  },
  invert(x) {
    return x;
  }
};
var transformLog = {
  apply: Math.log,
  invert: Math.exp
};
var transformSqrt = {
  apply(x) {
    return Math.sign(x) * Math.sqrt(Math.abs(x));
  },
  invert(x) {
    return Math.sign(x) * (x * x);
  }
};
function transformPow(exponent) {
  return exponent === 0.5 ? transformSqrt : {
    apply(x) {
      return Math.sign(x) * Math.pow(Math.abs(x), exponent);
    },
    invert(x) {
      return Math.sign(x) * Math.pow(Math.abs(x), 1 / exponent);
    }
  };
}
function transformSymlog(constant2) {
  return {
    apply(x) {
      return Math.sign(x) * Math.log1p(Math.abs(x / constant2));
    },
    invert(x) {
      return Math.sign(x) * Math.expm1(Math.abs(x)) * constant2;
    }
  };
}

// node_modules/@observablehq/plot/src/scales/temporal.js
function createScaleT(key, scale2, channels, options) {
  return createScaleQ(key, scale2, channels, options);
}
function createScaleTime(key, channels, options) {
  return createScaleT(key, time(), channels, options);
}
function createScaleUtc(key, channels, options) {
  return createScaleT(key, utcTime(), channels, options);
}

// node_modules/@observablehq/plot/src/scales/ordinal.js
var ordinalImplicit = Symbol("ordinal");
function createScaleO(key, scale2, channels, { type, interval, domain, range: range3, reverse: reverse3, hint }) {
  interval = maybeRangeInterval(interval, type);
  if (domain === void 0) domain = inferDomain2(channels, interval, key);
  if (type === "categorical" || type === ordinalImplicit) type = "ordinal";
  if (reverse3) domain = reverse(domain);
  domain = scale2.domain(domain).domain();
  if (range3 !== void 0) {
    if (typeof range3 === "function") range3 = range3(domain);
    scale2.range(range3);
  }
  return { type, domain, range: range3, scale: scale2, hint, interval };
}
function createScaleOrdinal(key, channels, { type, interval, domain, range: range3, scheme: scheme28, unknown, ...options }) {
  interval = maybeRangeInterval(interval, type);
  if (domain === void 0) domain = inferDomain2(channels, interval, key);
  let hint;
  if (registry.get(key) === symbol) {
    hint = inferSymbolHint(channels);
    range3 = range3 === void 0 ? inferSymbolRange(hint) : map(range3, maybeSymbol);
  } else if (registry.get(key) === color) {
    if (range3 === void 0 && (type === "ordinal" || type === ordinalImplicit)) {
      range3 = maybeBooleanRange(domain, scheme28);
      if (range3 !== void 0) scheme28 = void 0;
    }
    if (scheme28 === void 0 && range3 === void 0) {
      scheme28 = type === "ordinal" ? "turbo" : "observable10";
    }
    if (scheme28 !== void 0) {
      if (range3 !== void 0) {
        const interpolate = quantitativeScheme(scheme28);
        const t0 = range3[0], d = range3[1] - range3[0];
        range3 = ({ length: n }) => quantize_default((t) => interpolate(t0 + d * t), n);
      } else {
        range3 = ordinalScheme(scheme28);
      }
    }
  }
  if (unknown === implicit) {
    throw new Error(`implicit unknown on ${key} scale is not supported`);
  }
  return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type, domain, range: range3, hint });
}
function createScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
  return maybeRound(point().align(align).padding(padding), channels, options, key);
}
function createScaleBand(key, channels, {
  align = 0.5,
  padding = 0.1,
  paddingInner = padding,
  paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
  ...options
}) {
  return maybeRound(
    band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
    channels,
    options,
    key
  );
}
function maybeRound(scale2, channels, options, key) {
  let { round: round2 } = options;
  if (round2 !== void 0) scale2.round(round2 = !!round2);
  scale2 = createScaleO(key, scale2, channels, options);
  scale2.round = round2;
  return scale2;
}
function inferDomain2(channels, interval, key) {
  const values2 = new InternSet();
  for (const { value, domain } of channels) {
    if (domain !== void 0) return domain();
    if (value === void 0) continue;
    for (const v of value) values2.add(v);
  }
  if (interval !== void 0) {
    const [min2, max2] = extent(values2).map(interval.floor, interval);
    return interval.range(min2, interval.offset(max2));
  }
  if (values2.size > 1e4 && registry.get(key) === position) {
    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
  }
  return sort(values2, ascendingDefined);
}
function inferHint(channels, key) {
  let value;
  for (const { hint } of channels) {
    const candidate = hint == null ? void 0 : hint[key];
    if (candidate === void 0) continue;
    if (value === void 0) value = candidate;
    else if (value !== candidate) return;
  }
  return value;
}
function inferSymbolHint(channels) {
  return {
    fill: inferHint(channels, "fill"),
    stroke: inferHint(channels, "stroke")
  };
}
function inferSymbolRange(hint) {
  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
}

// node_modules/@observablehq/plot/src/scales.js
function createScales(channelsByScale, {
  label: globalLabel,
  inset: globalInset = 0,
  insetTop: globalInsetTop = globalInset,
  insetRight: globalInsetRight = globalInset,
  insetBottom: globalInsetBottom = globalInset,
  insetLeft: globalInsetLeft = globalInset,
  round: round2,
  nice: nice2,
  clamp,
  zero,
  align,
  padding,
  projection: projection2,
  facet: { label: facetLabel = globalLabel } = {},
  ...options
} = {}) {
  const scales = {};
  for (const [key, channels] of channelsByScale) {
    const scaleOptions = options[key];
    const scale2 = createScale(key, channels, {
      round: registry.get(key) === position ? round2 : void 0,
      // only for position
      nice: nice2,
      clamp,
      zero,
      align,
      padding,
      projection: projection2,
      ...scaleOptions
    });
    if (scale2) {
      let {
        label = key === "fx" || key === "fy" ? facetLabel : globalLabel,
        percent,
        transform,
        inset,
        insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
        // not fy
        insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
        // not fx
        insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
        // not fy
        insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
        // not fx
      } = scaleOptions || {};
      if (transform == null) transform = void 0;
      else if (typeof transform !== "function") throw new Error("invalid scale transform; not a function");
      scale2.percent = !!percent;
      scale2.label = label === void 0 ? inferScaleLabel(channels, scale2) : label;
      scale2.transform = transform;
      if (key === "x" || key === "fx") {
        scale2.insetLeft = +insetLeft;
        scale2.insetRight = +insetRight;
      } else if (key === "y" || key === "fy") {
        scale2.insetTop = +insetTop;
        scale2.insetBottom = +insetBottom;
      }
      scales[key] = scale2;
    }
  }
  return scales;
}
function createScaleFunctions(descriptors) {
  const scales = {};
  const scaleFunctions = { scales };
  for (const [key, descriptor] of Object.entries(descriptors)) {
    const { scale: scale2, type, interval, label } = descriptor;
    scales[key] = exposeScale(descriptor);
    scaleFunctions[key] = scale2;
    scale2.type = type;
    if (interval != null) scale2.interval = interval;
    if (label != null) scale2.label = label;
  }
  return scaleFunctions;
}
function autoScaleRange(scales, dimensions) {
  const { x, y, fx, fy } = scales;
  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
  if (fx) autoScaleRangeX(fx, superdimensions);
  if (fy) autoScaleRangeY(fy, superdimensions);
  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;
  if (x) autoScaleRangeX(x, subdimensions);
  if (y) autoScaleRangeY(y, subdimensions);
}
function inferScaleLabel(channels = [], scale2) {
  let label;
  for (const { label: l } of channels) {
    if (l === void 0) continue;
    if (label === void 0) label = l;
    else if (label !== l) return;
  }
  if (label === void 0) return;
  if (!isOrdinalScale(scale2) && scale2.percent) label = `${label} (%)`;
  return { inferred: true, toString: () => label };
}
function inferScaleOrder(scale2) {
  return Math.sign(orderof(scale2.domain())) * Math.sign(orderof(scale2.range()));
}
function outerDimensions(dimensions) {
  const {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width,
    height,
    facet: {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    }
  } = dimensions;
  return {
    marginTop: Math.max(marginTop, facetMarginTop),
    marginRight: Math.max(marginRight, facetMarginRight),
    marginBottom: Math.max(marginBottom, facetMarginBottom),
    marginLeft: Math.max(marginLeft, facetMarginLeft),
    width,
    height
  };
}
function innerDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  return {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,
    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,
    facet: { width, height }
  };
}
function autoScaleRangeX(scale2, dimensions) {
  if (scale2.range === void 0) {
    const { insetLeft, insetRight } = scale2;
    const { width, marginLeft = 0, marginRight = 0 } = dimensions;
    const left = marginLeft + insetLeft;
    const right = width - marginRight - insetRight;
    scale2.range = [left, Math.max(left, right)];
    if (!isOrdinalScale(scale2)) scale2.range = piecewiseRange(scale2);
    scale2.scale.range(scale2.range);
  }
  autoScaleRound(scale2);
}
function autoScaleRangeY(scale2, dimensions) {
  if (scale2.range === void 0) {
    const { insetTop, insetBottom } = scale2;
    const { height, marginTop = 0, marginBottom = 0 } = dimensions;
    const top = marginTop + insetTop;
    const bottom = height - marginBottom - insetBottom;
    scale2.range = [Math.max(top, bottom), top];
    if (!isOrdinalScale(scale2)) scale2.range = piecewiseRange(scale2);
    else scale2.range.reverse();
    scale2.scale.range(scale2.range);
  }
  autoScaleRound(scale2);
}
function autoScaleRound(scale2) {
  if (scale2.round === void 0 && isBandScale(scale2) && roundError(scale2) <= 30) {
    scale2.scale.round(true);
  }
}
function roundError({ scale: scale2 }) {
  const n = scale2.domain().length;
  const [start, stop] = scale2.range();
  const paddingInner = scale2.paddingInner ? scale2.paddingInner() : 1;
  const paddingOuter = scale2.paddingOuter ? scale2.paddingOuter() : scale2.padding();
  const m = n - paddingInner;
  const step = Math.abs(stop - start) / Math.max(1, m + paddingOuter * 2);
  return (step - Math.floor(step)) * m;
}
function piecewiseRange(scale2) {
  const length2 = scale2.scale.domain().length + isThresholdScale(scale2);
  if (!(length2 > 2)) return scale2.range;
  const [start, end] = scale2.range;
  return Array.from({ length: length2 }, (_, i) => start + i / (length2 - 1) * (end - start));
}
function normalizeScale(key, scale2, hint) {
  return createScale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale2 });
}
function createScale(key, channels = [], options = {}) {
  const type = inferScaleType(key, channels, options);
  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type })) {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isTemporal))
      warn(
        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type
        )}".`
      );
    else if (values2.some(isTemporalString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type
        )}".`
      );
    else if (values2.some(isNumericString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
          type
        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type
        )}".`
      );
  }
  options.type = type;
  switch (type) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      options = coerceType(channels, options, coerceNumbers);
      break;
    case "identity":
      switch (registry.get(key)) {
        case position:
          options = coerceType(channels, options, coerceNumbers);
          break;
        case symbol:
          options = coerceType(channels, options, coerceSymbols);
          break;
      }
      break;
    case "utc":
    case "time":
      options = coerceType(channels, options, coerceDates);
      break;
  }
  switch (type) {
    case "diverging":
      return createScaleDiverging(key, channels, options);
    case "diverging-sqrt":
      return createScaleDivergingSqrt(key, channels, options);
    case "diverging-pow":
      return createScaleDivergingPow(key, channels, options);
    case "diverging-log":
      return createScaleDivergingLog(key, channels, options);
    case "diverging-symlog":
      return createScaleDivergingSymlog(key, channels, options);
    case "categorical":
    case "ordinal":
    case ordinalImplicit:
      return createScaleOrdinal(key, channels, options);
    case "cyclical":
    case "sequential":
    case "linear":
      return createScaleLinear(key, channels, options);
    case "sqrt":
      return createScaleSqrt(key, channels, options);
    case "threshold":
      return createScaleThreshold(key, channels, options);
    case "quantile":
      return createScaleQuantile(key, channels, options);
    case "quantize":
      return createScaleQuantize(key, channels, options);
    case "pow":
      return createScalePow(key, channels, options);
    case "log":
      return createScaleLog(key, channels, options);
    case "symlog":
      return createScaleSymlog(key, channels, options);
    case "utc":
      return createScaleUtc(key, channels, options);
    case "time":
      return createScaleTime(key, channels, options);
    case "point":
      return createScalePoint(key, channels, options);
    case "band":
      return createScaleBand(key, channels, options);
    case "identity":
      return createScaleIdentity(key);
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${type}`);
  }
}
function formatScaleType(type) {
  return typeof type === "symbol" ? type.description : type;
}
function maybeScaleType(type) {
  return typeof type === "string" ? `${type}`.toLowerCase() : type;
}
var typeProjection = { toString: () => "projection" };
function inferScaleType(key, channels, { type, domain, range: range3, scheme: scheme28, pivot, projection: projection2 }) {
  var _a;
  type = maybeScaleType(type);
  if (key === "fx" || key === "fy") return "band";
  if ((key === "x" || key === "y") && projection2 != null) type = typeProjection;
  for (const channel of channels) {
    const t = maybeScaleType(channel.type);
    if (t === void 0) continue;
    else if (type === void 0) type = t;
    else if (type !== t) throw new Error(`scale incompatible with channel: ${type} !== ${t}`);
  }
  if (type === typeProjection) return;
  if (type !== void 0) return type;
  if (domain === void 0 && !channels.some(({ value }) => value !== void 0)) return;
  const kind = registry.get(key);
  if (kind === radius) return "sqrt";
  if (kind === opacity || kind === length) return "linear";
  if (kind === symbol) return "ordinal";
  const n = (_a = domain ?? range3) == null ? void 0 : _a.length;
  if (n < 2 || n > 2) return asOrdinalType(kind);
  if (domain !== void 0) {
    if (isOrdinal(domain)) return asOrdinalType(kind);
    if (isTemporal(domain)) return "utc";
  } else {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isOrdinal)) return asOrdinalType(kind);
    if (values2.some(isTemporal)) return "utc";
  }
  if (kind === color) {
    if (pivot != null || isDivergingScheme(scheme28)) return "diverging";
    if (isCategoricalScheme(scheme28)) return "categorical";
  }
  return "linear";
}
function asOrdinalType(kind) {
  switch (kind) {
    case position:
      return "point";
    case color:
      return ordinalImplicit;
    default:
      return "ordinal";
  }
}
function isOrdinalScale({ type }) {
  return type === "ordinal" || type === "point" || type === "band" || type === ordinalImplicit;
}
function isThresholdScale({ type }) {
  return type === "threshold";
}
function isBandScale({ type }) {
  return type === "point" || type === "band";
}
function isCollapsed(scale2) {
  if (scale2 === void 0) return true;
  const domain = scale2.domain();
  const value = scale2(domain[0]);
  for (let i = 1, n = domain.length; i < n; ++i) {
    if (scale2(domain[i]) - value) {
      return false;
    }
  }
  return true;
}
function coerceType(channels, { domain, ...options }, coerceValues) {
  var _a;
  for (const c of channels) {
    if (c.value !== void 0) {
      if (domain === void 0) domain = (_a = c.value) == null ? void 0 : _a.domain;
      c.value = coerceValues(c.value);
    }
  }
  return {
    domain: domain === void 0 ? domain : coerceValues(domain),
    ...options
  };
}
function coerceSymbols(values2) {
  return map(values2, maybeSymbol);
}
function scale(options = {}) {
  let scale2;
  for (const key in options) {
    if (!registry.has(key)) continue;
    if (!isScaleOptions(options[key])) continue;
    if (scale2 !== void 0) throw new Error("ambiguous scale definition; multiple scales found");
    scale2 = exposeScale(normalizeScale(key, options[key]));
  }
  if (scale2 === void 0) throw new Error("invalid scale definition; no scale found");
  return scale2;
}
function exposeScales(scales) {
  return (key) => {
    if (!registry.has(key = `${key}`)) throw new Error(`unknown scale: ${key}`);
    return scales[key];
  };
}
function exposeScale({ scale: scale2, type, domain, range: range3, interpolate, interval, transform, percent, pivot }) {
  if (type === "identity") return { type: "identity", apply: (d) => d, invert: (d) => d };
  const unknown = scale2.unknown ? scale2.unknown() : void 0;
  return {
    type,
    domain: slice(domain),
    // defensive copy
    ...range3 !== void 0 && { range: slice(range3) },
    // defensive copy
    ...transform !== void 0 && { transform },
    ...percent && { percent },
    // only exposed if truthy
    ...unknown !== void 0 && { unknown },
    ...interval !== void 0 && { interval },
    // quantitative
    ...interpolate !== void 0 && { interpolate },
    ...scale2.clamp && { clamp: scale2.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...pivot !== void 0 && { pivot, symmetric: false },
    // log, diverging-log
    ...scale2.base && { base: scale2.base() },
    // pow, diverging-pow
    ...scale2.exponent && { exponent: scale2.exponent() },
    // symlog, diverging-symlog
    ...scale2.constant && { constant: scale2.constant() },
    // band, point
    ...scale2.align && { align: scale2.align(), round: scale2.round() },
    ...scale2.padding && (scale2.paddingInner ? { paddingInner: scale2.paddingInner(), paddingOuter: scale2.paddingOuter() } : { padding: scale2.padding() }),
    ...scale2.bandwidth && { bandwidth: scale2.bandwidth(), step: scale2.step() },
    // utilities
    apply: (t) => scale2(t),
    ...scale2.invert && { invert: (t) => scale2.invert(t) }
  };
}

// node_modules/@observablehq/plot/src/facet.js
function createFacets(channelsByScale, options) {
  const { fx, fy } = createScales(channelsByScale, options);
  const fxDomain = fx == null ? void 0 : fx.scale.domain();
  const fyDomain = fy == null ? void 0 : fy.scale.domain();
  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x, y], i) => ({ x, y, i })) : fxDomain ? fxDomain.map((x, i) => ({ x, i })) : fyDomain ? fyDomain.map((y, i) => ({ y, i })) : void 0;
}
function recreateFacets(facets, { x: X, y: Y }) {
  X && (X = facetIndex(X));
  Y && (Y = facetIndex(Y));
  return facets.filter(
    X && Y ? (f) => X.has(f.x) && Y.has(f.y) : X ? (f) => X.has(f.x) : (f) => Y.has(f.y)
  ).sort(
    X && Y ? (a, b) => X.get(a.x) - X.get(b.x) || Y.get(a.y) - Y.get(b.y) : X ? (a, b) => X.get(a.x) - X.get(b.x) : (a, b) => Y.get(a.y) - Y.get(b.y)
  );
}
function facetGroups(data, { fx, fy }) {
  const I = range2(data);
  const FX = fx == null ? void 0 : fx.value;
  const FY = fy == null ? void 0 : fy.value;
  return fx && fy ? rollup(
    I,
    (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G),
    (i) => FX[i],
    (i) => FY[i]
  ) : fx ? rollup(
    I,
    (G) => (G.fx = FX[G[0]], G),
    (i) => FX[i]
  ) : rollup(
    I,
    (G) => (G.fy = FY[G[0]], G),
    (i) => FY[i]
  );
}
function facetTranslator(fx, fy, { marginTop, marginLeft }) {
  const x = fx ? ({ x: x2 }) => fx(x2) - marginLeft : () => 0;
  const y = fy ? ({ y: y2 }) => fy(y2) - marginTop : () => 0;
  return function(d) {
    if (this.tagName === "svg") {
      this.setAttribute("x", x(d));
      this.setAttribute("y", y(d));
    } else {
      this.setAttribute("transform", `translate(${x(d)},${y(d)})`);
    }
  };
}
function facetExclude(index) {
  const ex = [];
  const e = new Uint32Array(sum(index, (d) => d.length));
  for (const i of index) {
    let n = 0;
    for (const j of index) {
      if (i === j) continue;
      e.set(j, n);
      n += j.length;
    }
    ex.push(e.slice(0, n));
  }
  return ex;
}
var facetAnchors = /* @__PURE__ */ new Map([
  ["top", facetAnchorTop],
  ["right", facetAnchorRight],
  ["bottom", facetAnchorBottom],
  ["left", facetAnchorLeft],
  ["top-left", and(facetAnchorTop, facetAnchorLeft)],
  ["top-right", and(facetAnchorTop, facetAnchorRight)],
  ["bottom-left", and(facetAnchorBottom, facetAnchorLeft)],
  ["bottom-right", and(facetAnchorBottom, facetAnchorRight)],
  ["top-empty", facetAnchorTopEmpty],
  ["right-empty", facetAnchorRightEmpty],
  ["bottom-empty", facetAnchorBottomEmpty],
  ["left-empty", facetAnchorLeftEmpty],
  ["empty", facetAnchorEmpty]
]);
function maybeFacetAnchor(facetAnchor) {
  if (facetAnchor == null) return null;
  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
  if (anchor) return anchor;
  throw new Error(`invalid facet anchor: ${facetAnchor}`);
}
var indexCache = /* @__PURE__ */ new WeakMap();
function facetIndex(V) {
  let I = indexCache.get(V);
  if (!I) indexCache.set(V, I = new InternMap(map(V, (v, i) => [v, i])));
  return I;
}
function facetIndexOf(V, v) {
  return facetIndex(V).get(v);
}
function facetFind(facets, x, y) {
  x = keyof(x);
  y = keyof(y);
  return facets.find((f) => Object.is(keyof(f.x), x) && Object.is(keyof(f.y), y));
}
function facetEmpty(facets, x, y) {
  var _a;
  return (_a = facetFind(facets, x, y)) == null ? void 0 : _a.empty;
}
function facetAnchorTop(facets, { y: Y }, { y }) {
  return Y ? facetIndexOf(Y, y) === 0 : true;
}
function facetAnchorBottom(facets, { y: Y }, { y }) {
  return Y ? facetIndexOf(Y, y) === Y.length - 1 : true;
}
function facetAnchorLeft(facets, { x: X }, { x }) {
  return X ? facetIndexOf(X, x) === 0 : true;
}
function facetAnchorRight(facets, { x: X }, { x }) {
  return X ? facetIndexOf(X, x) === X.length - 1 : true;
}
function facetAnchorTopEmpty(facets, { y: Y }, { x, y, empty }) {
  if (empty) return false;
  if (!Y) return;
  const i = facetIndexOf(Y, y);
  if (i > 0) return facetEmpty(facets, x, Y[i - 1]);
}
function facetAnchorBottomEmpty(facets, { y: Y }, { x, y, empty }) {
  if (empty) return false;
  if (!Y) return;
  const i = facetIndexOf(Y, y);
  if (i < Y.length - 1) return facetEmpty(facets, x, Y[i + 1]);
}
function facetAnchorLeftEmpty(facets, { x: X }, { x, y, empty }) {
  if (empty) return false;
  if (!X) return;
  const i = facetIndexOf(X, x);
  if (i > 0) return facetEmpty(facets, X[i - 1], y);
}
function facetAnchorRightEmpty(facets, { x: X }, { x, y, empty }) {
  if (empty) return false;
  if (!X) return;
  const i = facetIndexOf(X, x);
  if (i < X.length - 1) return facetEmpty(facets, X[i + 1], y);
}
function facetAnchorEmpty(facets, channels, { empty }) {
  return empty;
}
function and(a, b) {
  return function() {
    return a.apply(null, arguments) && b.apply(null, arguments);
  };
}
function facetFilter(facets, { channels: { fx, fy }, groups }) {
  return fx && fy ? facets.map(({ x, y }) => {
    var _a;
    return ((_a = groups.get(x)) == null ? void 0 : _a.get(y)) ?? [];
  }) : fx ? facets.map(({ x }) => groups.get(x) ?? []) : facets.map(({ y }) => groups.get(y) ?? []);
}

// node_modules/@observablehq/plot/src/projection.js
var pi = Math.PI;
var tau = 2 * pi;
var defaultAspectRatio = 0.618;
function createProjection({
  projection: projection2,
  inset: globalInset = 0,
  insetTop = globalInset,
  insetRight = globalInset,
  insetBottom = globalInset,
  insetLeft = globalInset
} = {}, dimensions) {
  if (projection2 == null) return;
  if (typeof projection2.stream === "function") return projection2;
  let options;
  let domain;
  let clip = "frame";
  if (isObject(projection2)) {
    let inset;
    ({
      type: projection2,
      domain,
      inset,
      insetTop = inset !== void 0 ? inset : insetTop,
      insetRight = inset !== void 0 ? inset : insetRight,
      insetBottom = inset !== void 0 ? inset : insetBottom,
      insetLeft = inset !== void 0 ? inset : insetLeft,
      clip = clip,
      ...options
    } = projection2);
    if (projection2 == null) return;
  }
  if (typeof projection2 !== "function") ({ type: projection2 } = namedProjection(projection2));
  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
  const dx = width - marginLeft - marginRight - insetLeft - insetRight;
  const dy = height - marginTop - marginBottom - insetTop - insetBottom;
  projection2 = projection2 == null ? void 0 : projection2({ width: dx, height: dy, clip, ...options });
  if (projection2 == null) return;
  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
  let tx = marginLeft + insetLeft;
  let ty = marginTop + insetTop;
  let transform;
  if (domain != null) {
    const [[x0, y0], [x1, y1]] = path_default(projection2).bounds(domain);
    const k = Math.min(dx / (x1 - x0), dy / (y1 - y0));
    if (k > 0) {
      tx -= (k * (x0 + x1) - dx) / 2;
      ty -= (k * (y0 + y1) - dy) / 2;
      transform = transform_default({
        point(x, y) {
          this.stream.point(x * k + tx, y * k + ty);
        }
      });
    } else {
      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
    }
  }
  transform ?? (transform = tx === 0 && ty === 0 ? identity3() : transform_default({
    point(x, y) {
      this.stream.point(x + tx, y + ty);
    }
  }));
  return { stream: (s) => projection2.stream(transform.stream(clip(s))) };
}
function namedProjection(projection2) {
  switch (`${projection2}`.toLowerCase()) {
    case "albers-usa":
      return scaleProjection(albersUsa_default, 0.7463, 0.4673);
    case "albers":
      return conicProjection(albers_default, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return scaleProjection(azimuthalEqualArea_default, 4, 4);
    case "azimuthal-equidistant":
      return scaleProjection(azimuthalEquidistant_default, tau, tau);
    case "conic-conformal":
      return conicProjection(conicConformal_default, tau, tau);
    case "conic-equal-area":
      return conicProjection(conicEqualArea_default, 6.1702, 2.9781);
    case "conic-equidistant":
      return conicProjection(conicEquidistant_default, 7.312, 3.6282);
    case "equal-earth":
      return scaleProjection(equalEarth_default, 5.4133, 2.6347);
    case "equirectangular":
      return scaleProjection(equirectangular_default, tau, pi);
    case "gnomonic":
      return scaleProjection(gnomonic_default, 3.4641, 3.4641);
    case "identity":
      return { type: identity3 };
    case "reflect-y":
      return { type: reflectY };
    case "mercator":
      return scaleProjection(mercator_default, tau, tau);
    case "orthographic":
      return scaleProjection(orthographic_default, 2, 2);
    case "stereographic":
      return scaleProjection(stereographic_default, 2, 2);
    case "transverse-mercator":
      return scaleProjection(transverseMercator_default, tau, tau);
    default:
      throw new Error(`unknown projection type: ${projection2}`);
  }
}
function maybePostClip(clip, x1, y1, x2, y2) {
  if (clip === false || clip == null || typeof clip === "number") return (s) => s;
  if (clip === true) clip = "frame";
  switch (`${clip}`.toLowerCase()) {
    case "frame":
      return clipRectangle(x1, y1, x2, y2);
    default:
      throw new Error(`unknown projection clip type: ${clip}`);
  }
}
function scaleProjection(createProjection2, kx, ky) {
  return {
    type: ({ width, height, rotate, precision = 0.15, clip }) => {
      var _a, _b, _c;
      const projection2 = createProjection2();
      if (precision != null) (_a = projection2.precision) == null ? void 0 : _a.call(projection2, precision);
      if (rotate != null) (_b = projection2.rotate) == null ? void 0 : _b.call(projection2, rotate);
      if (typeof clip === "number") (_c = projection2.clipAngle) == null ? void 0 : _c.call(projection2, clip);
      if (width != null) {
        projection2.scale(Math.min(width / kx, height / ky));
        projection2.translate([width / 2, height / 2]);
      }
      return projection2;
    },
    aspectRatio: ky / kx
  };
}
function conicProjection(createProjection2, kx, ky) {
  const { type, aspectRatio } = scaleProjection(createProjection2, kx, ky);
  return {
    type: (options) => {
      const { parallels, domain, width, height } = options;
      const projection2 = type(options);
      if (parallels != null) {
        projection2.parallels(parallels);
        if (domain === void 0 && width != null) {
          projection2.fitSize([width, height], { type: "Sphere" });
        }
      }
      return projection2;
    },
    aspectRatio
  };
}
var identity3 = constant({ stream: (stream) => stream });
var reflectY = constant(
  transform_default({
    point(x, y) {
      this.stream.point(x, -y);
    }
  })
);
function project(cx, cy, values2, projection2) {
  const x = values2[cx];
  const y = values2[cy];
  const n = x.length;
  const X = values2[cx] = new Float64Array(n).fill(NaN);
  const Y = values2[cy] = new Float64Array(n).fill(NaN);
  let i;
  const stream = projection2.stream({
    point(x2, y2) {
      X[i] = x2;
      Y[i] = y2;
    }
  });
  for (i = 0; i < n; ++i) {
    stream.point(x[i], y[i]);
  }
}
function hasProjection({ projection: projection2 } = {}) {
  if (projection2 == null) return false;
  if (typeof projection2.stream === "function") return true;
  if (isObject(projection2)) projection2 = projection2.type;
  return projection2 != null;
}
function projectionAspectRatio(projection2) {
  if (typeof (projection2 == null ? void 0 : projection2.stream) === "function") return defaultAspectRatio;
  if (isObject(projection2)) {
    let domain, options;
    ({ domain, type: projection2, ...options } = projection2);
    if (domain != null && projection2 != null) {
      const type = typeof projection2 === "string" ? namedProjection(projection2).type : projection2;
      const [[x0, y0], [x1, y1]] = path_default(type({ ...options, width: 100, height: 100 })).bounds(domain);
      const r = (y1 - y0) / (x1 - x0);
      return r && isFinite(r) ? r < 0.2 ? 0.2 : r > 5 ? 5 : r : defaultAspectRatio;
    }
  }
  if (projection2 == null) return;
  if (typeof projection2 !== "function") {
    const { aspectRatio } = namedProjection(projection2);
    if (aspectRatio) return aspectRatio;
  }
  return defaultAspectRatio;
}
function applyPosition(channels, scales, { projection: projection2 }) {
  const { x, y } = channels;
  let position3 = {};
  if (x) position3.x = x;
  if (y) position3.y = y;
  position3 = valueObject(position3, scales);
  if (projection2 && (x == null ? void 0 : x.scale) === "x" && (y == null ? void 0 : y.scale) === "y") project("x", "y", position3, projection2);
  if (x) position3.x = coerceNumbers(position3.x);
  if (y) position3.y = coerceNumbers(position3.y);
  return position3;
}
function getGeometryChannels(channel) {
  const X = [];
  const Y = [];
  const x = { scale: "x", value: X };
  const y = { scale: "y", value: Y };
  const sink = {
    point(x2, y2) {
      X.push(x2);
      Y.push(y2);
    },
    lineStart() {
    },
    lineEnd() {
    },
    polygonStart() {
    },
    polygonEnd() {
    },
    sphere() {
    }
  };
  for (const object of channel.value) stream_default(object, sink);
  return [x, y];
}
function xyProjection({ x: X, y: Y }) {
  if (X || Y) {
    X ?? (X = (x) => x);
    Y ?? (Y = (y) => y);
    return transform_default({
      point(x, y) {
        this.stream.point(X(x), Y(y));
      }
    });
  }
}

// node_modules/@observablehq/plot/src/context.js
function createContext(options = {}) {
  const { document = typeof window !== "undefined" ? window.document : void 0, clip } = options;
  return { document, clip: maybeClip(clip) };
}
function create(name, { document }) {
  return select_default(creator_default(name).call(document.documentElement));
}

// node_modules/@observablehq/plot/src/memoize.js
var unset = Symbol("unset");
function memoize1(compute) {
  return (compute.length === 1 ? memoize1Arg : memoize1Args)(compute);
}
function memoize1Arg(compute) {
  let cacheValue;
  let cacheKey = unset;
  return (key) => {
    if (!Object.is(cacheKey, key)) {
      cacheKey = key;
      cacheValue = compute(key);
    }
    return cacheValue;
  };
}
function memoize1Args(compute) {
  let cacheValue, cacheKeys;
  return (...keys) => {
    if ((cacheKeys == null ? void 0 : cacheKeys.length) !== keys.length || cacheKeys.some((k, i) => !Object.is(k, keys[i]))) {
      cacheKeys = keys;
      cacheValue = compute(...keys);
    }
    return cacheValue;
  };
}

// node_modules/@observablehq/plot/src/format.js
var numberFormat = memoize1((locale) => {
  return new Intl.NumberFormat(locale);
});
var monthFormat = memoize1((locale, month) => {
  return new Intl.DateTimeFormat(locale, { timeZone: "UTC", ...month && { month } });
});
var weekdayFormat = memoize1((locale, weekday) => {
  return new Intl.DateTimeFormat(locale, { timeZone: "UTC", ...weekday && { weekday } });
});
function formatNumber(locale = "en-US") {
  const format3 = numberFormat(locale);
  return (i) => i != null && !isNaN(i) ? format3.format(i) : void 0;
}
function formatMonth(locale = "en-US", format3 = "short") {
  const fmt = monthFormat(locale, format3);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;
}
function formatWeekday(locale = "en-US", format3 = "short") {
  const fmt = weekdayFormat(locale, format3);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;
}
function formatIsoDate(date) {
  return format2(date, "Invalid Date");
}
function formatAuto(locale = "en-US") {
  const number3 = formatNumber(locale);
  return (v) => (v instanceof Date ? formatIsoDate : typeof v === "number" ? number3 : string)(v);
}
var formatDefault = formatAuto();

// node_modules/@observablehq/plot/src/style.js
var offset = (typeof window !== "undefined" ? window.devicePixelRatio > 1 : typeof it === "undefined") ? 0 : 0.5;
var nextClipId = 0;
var nextPatternId = 0;
function getClipId() {
  return `plot-clip-${++nextClipId}`;
}
function getPatternId() {
  return `plot-pattern-${++nextPatternId}`;
}
function styles(mark, {
  title,
  href,
  ariaLabel: variaLabel,
  ariaDescription,
  ariaHidden,
  target,
  fill,
  fillOpacity,
  stroke,
  strokeWidth,
  strokeOpacity,
  strokeLinejoin,
  strokeLinecap,
  strokeMiterlimit,
  strokeDasharray,
  strokeDashoffset,
  opacity: opacity2,
  mixBlendMode,
  imageFilter,
  paintOrder,
  pointerEvents,
  shapeRendering,
  channels
}, {
  ariaLabel: cariaLabel,
  fill: defaultFill = "currentColor",
  fillOpacity: defaultFillOpacity,
  stroke: defaultStroke = "none",
  strokeOpacity: defaultStrokeOpacity,
  strokeWidth: defaultStrokeWidth,
  strokeLinecap: defaultStrokeLinecap,
  strokeLinejoin: defaultStrokeLinejoin,
  strokeMiterlimit: defaultStrokeMiterlimit,
  paintOrder: defaultPaintOrder
}) {
  if (defaultFill === null) {
    fill = null;
    fillOpacity = null;
  }
  if (defaultStroke === null) {
    stroke = null;
    strokeOpacity = null;
  }
  if (isNoneish(defaultFill)) {
    if (!isNoneish(defaultStroke) && (!isNoneish(fill) || (channels == null ? void 0 : channels.fill))) defaultStroke = "none";
  } else {
    if (isNoneish(defaultStroke) && (!isNoneish(stroke) || (channels == null ? void 0 : channels.stroke))) defaultFill = "none";
  }
  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
  const [vopacity, copacity] = maybeNumberChannel(opacity2);
  if (!isNone(cstroke)) {
    if (strokeWidth === void 0) strokeWidth = defaultStrokeWidth;
    if (strokeLinecap === void 0) strokeLinecap = defaultStrokeLinecap;
    if (strokeLinejoin === void 0) strokeLinejoin = defaultStrokeLinejoin;
    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin)) strokeMiterlimit = defaultStrokeMiterlimit;
    if (!isNone(cfill) && paintOrder === void 0) paintOrder = defaultPaintOrder;
  }
  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
  if (defaultFill !== null) {
    mark.fill = impliedString(cfill, "currentColor");
    mark.fillOpacity = impliedNumber(cfillOpacity, 1);
  }
  if (defaultStroke !== null) {
    mark.stroke = impliedString(cstroke, "none");
    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
    mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
    mark.strokeLinecap = impliedString(strokeLinecap, "butt");
    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
    mark.strokeDasharray = impliedString(strokeDasharray, "none");
    mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
  }
  mark.target = string(target);
  mark.ariaLabel = string(cariaLabel);
  mark.ariaDescription = string(ariaDescription);
  mark.ariaHidden = string(ariaHidden);
  mark.opacity = impliedNumber(copacity, 1);
  mark.mixBlendMode = impliedString(mixBlendMode, "normal");
  mark.imageFilter = impliedString(imageFilter, "none");
  mark.paintOrder = impliedString(paintOrder, "normal");
  mark.pointerEvents = impliedString(pointerEvents, "auto");
  mark.shapeRendering = impliedString(shapeRendering, "auto");
  return {
    title: { value: title, optional: true, filter: null },
    href: { value: href, optional: true, filter: null },
    ariaLabel: { value: variaLabel, optional: true, filter: null },
    fill: { value: vfill, scale: "auto", optional: true },
    fillOpacity: { value: vfillOpacity, scale: "auto", optional: true },
    stroke: { value: vstroke, scale: "auto", optional: true },
    strokeOpacity: { value: vstrokeOpacity, scale: "auto", optional: true },
    strokeWidth: { value: vstrokeWidth, optional: true },
    opacity: { value: vopacity, scale: "auto", optional: true }
  };
}
function applyTitle(selection, L) {
  if (L)
    selection.filter((i) => nonempty(L[i])).append("title").call(applyText, L);
}
function applyTitleGroup(selection, L) {
  if (L)
    selection.filter(([i]) => nonempty(L[i])).append("title").call(applyTextGroup, L);
}
function applyText(selection, T) {
  if (T) selection.text((i) => formatDefault(T[i]));
}
function applyTextGroup(selection, T) {
  if (T) selection.text(([i]) => formatDefault(T[i]));
}
function applyChannelStyles(selection, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T,
  fill: F,
  fillOpacity: FO,
  stroke: S,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O,
  href: H
}) {
  if (AL) applyAttr(selection, "aria-label", (i) => AL[i]);
  if (F) applyAttr(selection, "fill", (i) => F[i]);
  if (FO) applyAttr(selection, "fill-opacity", (i) => FO[i]);
  if (S) applyAttr(selection, "stroke", (i) => S[i]);
  if (SO) applyAttr(selection, "stroke-opacity", (i) => SO[i]);
  if (SW) applyAttr(selection, "stroke-width", (i) => SW[i]);
  if (O) applyAttr(selection, "opacity", (i) => O[i]);
  if (H) applyHref(selection, (i) => H[i], target);
  if (!tip2) applyTitle(selection, T);
}
function applyGroupedChannelStyles(selection, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T,
  fill: F,
  fillOpacity: FO,
  stroke: S,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O,
  href: H
}) {
  if (AL) applyAttr(selection, "aria-label", ([i]) => AL[i]);
  if (F) applyAttr(selection, "fill", ([i]) => F[i]);
  if (FO) applyAttr(selection, "fill-opacity", ([i]) => FO[i]);
  if (S) applyAttr(selection, "stroke", ([i]) => S[i]);
  if (SO) applyAttr(selection, "stroke-opacity", ([i]) => SO[i]);
  if (SW) applyAttr(selection, "stroke-width", ([i]) => SW[i]);
  if (O) applyAttr(selection, "opacity", ([i]) => O[i]);
  if (H) applyHref(selection, ([i]) => H[i], target);
  if (!tip2) applyTitleGroup(selection, T);
}
function groupAesthetics({
  ariaLabel: AL,
  title: T,
  fill: F,
  fillOpacity: FO,
  stroke: S,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O,
  href: H
}, { tip: tip2 }) {
  return [AL, tip2 ? void 0 : T, F, FO, S, SO, SW, O, H].filter((c) => c !== void 0);
}
function groupZ2(I, Z, z) {
  const G = group(I, (i) => Z[i]);
  if (z === void 0 && G.size > 1 + I.length >> 1) {
    warn(
      `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
    );
  }
  return G.values();
}
function* groupIndex(I, position3, mark, channels) {
  const { z } = mark;
  const { z: Z } = channels;
  const A = groupAesthetics(channels, mark);
  const C = [...position3, ...A];
  for (const G of Z ? groupZ2(I, Z, z) : [I]) {
    let Ag;
    let Gg;
    out: for (const i of G) {
      for (const c of C) {
        if (!defined(c[i])) {
          if (Gg) Gg.push(-1);
          continue out;
        }
      }
      if (Ag === void 0) {
        if (Gg) yield Gg;
        Ag = A.map((c) => keyof(c[i])), Gg = [i];
        continue;
      }
      Gg.push(i);
      for (let j = 0; j < A.length; ++j) {
        const k = keyof(A[j][i]);
        if (k !== Ag[j]) {
          yield Gg;
          Ag = A.map((c) => keyof(c[i])), Gg = [i];
          continue out;
        }
      }
    }
    if (Gg) yield Gg;
  }
}
function applyClip(selection, mark, dimensions, context) {
  let clipUrl;
  const { clip = context.clip } = mark;
  if (clip === "frame") {
    selection = create("svg:g", context).each(function() {
      this.appendChild(selection.node());
      selection.node = () => this;
    });
    clipUrl = getFrameClip(context, dimensions);
  } else if (clip) {
    clipUrl = getGeoClip(clip, context);
  }
  applyAttr(selection, "aria-label", mark.ariaLabel);
  applyAttr(selection, "aria-description", mark.ariaDescription);
  applyAttr(selection, "aria-hidden", mark.ariaHidden);
  applyAttr(selection, "clip-path", clipUrl);
}
function memoizeClip(clip) {
  const cache = /* @__PURE__ */ new WeakMap();
  return (context, dimensions) => {
    let url = cache.get(context);
    if (!url) {
      const id = getClipId();
      select_default(context.ownerSVGElement).append("clipPath").attr("id", id).call(clip, context, dimensions);
      cache.set(context, url = `url(#${id})`);
    }
    return url;
  };
}
var getFrameClip = memoizeClip((clipPath, context, dimensions) => {
  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
  clipPath.append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom);
});
var geoClipCache = /* @__PURE__ */ new WeakMap();
var sphere = { type: "Sphere" };
function getGeoClip(geo2, context) {
  let cache, url;
  if (!(cache = geoClipCache.get(context))) geoClipCache.set(context, cache = /* @__PURE__ */ new WeakMap());
  if (geo2.type === "Sphere") geo2 = sphere;
  if (!(url = cache.get(geo2))) {
    const id = getClipId();
    select_default(context.ownerSVGElement).append("clipPath").attr("id", id).append("path").attr("d", context.path()(geo2));
    cache.set(geo2, url = `url(#${id})`);
  }
  return url;
}
function applyIndirectStyles(selection, mark, dimensions, context) {
  applyClip(selection, mark, dimensions, context);
  applyAttr(selection, "class", mark.className);
  applyAttr(selection, "fill", mark.fill);
  applyAttr(selection, "fill-opacity", mark.fillOpacity);
  applyAttr(selection, "stroke", mark.stroke);
  applyAttr(selection, "stroke-width", mark.strokeWidth);
  applyAttr(selection, "stroke-opacity", mark.strokeOpacity);
  applyAttr(selection, "stroke-linejoin", mark.strokeLinejoin);
  applyAttr(selection, "stroke-linecap", mark.strokeLinecap);
  applyAttr(selection, "stroke-miterlimit", mark.strokeMiterlimit);
  applyAttr(selection, "stroke-dasharray", mark.strokeDasharray);
  applyAttr(selection, "stroke-dashoffset", mark.strokeDashoffset);
  applyAttr(selection, "shape-rendering", mark.shapeRendering);
  applyAttr(selection, "filter", mark.imageFilter);
  applyAttr(selection, "paint-order", mark.paintOrder);
  const { pointerEvents = context.pointerSticky === false ? "none" : void 0 } = mark;
  applyAttr(selection, "pointer-events", pointerEvents);
}
function applyDirectStyles(selection, mark) {
  applyStyle(selection, "mix-blend-mode", mark.mixBlendMode);
  applyAttr(selection, "opacity", mark.opacity);
}
function applyHref(selection, href, target) {
  selection.each(function(i) {
    const h = href(i);
    if (h != null) {
      const a = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
      a.setAttribute("fill", "inherit");
      a.setAttributeNS(namespaces_default.xlink, "href", h);
      if (target != null) a.setAttribute("target", target);
      this.parentNode.insertBefore(a, this).appendChild(this);
    }
  });
}
function applyAttr(selection, name, value) {
  if (value != null) selection.attr(name, value);
}
function applyStyle(selection, name, value) {
  if (value != null) selection.style(name, value);
}
function applyTransform(selection, mark, { x, y }, tx = offset, ty = offset) {
  tx += mark.dx;
  ty += mark.dy;
  if (x == null ? void 0 : x.bandwidth) tx += x.bandwidth() / 2;
  if (y == null ? void 0 : y.bandwidth) ty += y.bandwidth() / 2;
  if (tx || ty) selection.attr("transform", `translate(${tx},${ty})`);
}
function impliedString(value, impliedValue) {
  if ((value = string(value)) !== impliedValue) return value;
}
function impliedNumber(value, impliedValue) {
  if ((value = number(value)) !== impliedValue) return value;
}
var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
function maybeClassName(name) {
  if (name === void 0) return "plot-d6a7b5";
  name = `${name}`;
  if (!validClassName.test(name)) throw new Error(`invalid class name: ${name}`);
  return name;
}
function applyInlineStyles(selection, style) {
  if (typeof style === "string") {
    selection.property("style", style);
  } else if (style != null) {
    for (const element of selection) {
      Object.assign(element.style, style);
    }
  }
}
function applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {
  return [
    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
  ];
}

// node_modules/@observablehq/plot/src/mark.js
var Mark = class {
  constructor(data, channels = {}, options = {}, defaults22) {
    const {
      facet = "auto",
      facetAnchor,
      fx,
      fy,
      sort: sort3,
      dx = 0,
      dy = 0,
      margin = 0,
      marginTop = margin,
      marginRight = margin,
      marginBottom = margin,
      marginLeft = margin,
      className,
      clip = defaults22 == null ? void 0 : defaults22.clip,
      channels: extraChannels,
      tip: tip2,
      render
    } = options;
    this.data = data;
    this.sort = isDomainSort(sort3) ? sort3 : null;
    this.initializer = initializer(options).initializer;
    this.transform = this.initializer ? options.transform : basic(options).transform;
    if (facet === null || facet === false) {
      this.facet = null;
    } else {
      this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
      this.fx = data === singleton && typeof fx === "string" ? [fx] : fx;
      this.fy = data === singleton && typeof fy === "string" ? [fy] : fy;
    }
    this.facetAnchor = maybeFacetAnchor(facetAnchor);
    channels = maybeNamed(channels);
    if (extraChannels !== void 0) channels = { ...maybeChannels(extraChannels), ...channels };
    if (defaults22 !== void 0) channels = { ...styles(this, options, defaults22), ...channels };
    this.channels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        if (isOptions(channel.value)) {
          const { value, label = channel.label, scale: scale2 = channel.scale } = channel.value;
          channel = { ...channel, label, scale: scale2, value };
        }
        if (data === singleton && typeof channel.value === "string") {
          const { value } = channel;
          channel = { ...channel, value: [value] };
        }
        return [name, channel];
      }).filter(([name, { value, optional }]) => {
        if (value != null) return true;
        if (optional) return false;
        throw new Error(`missing channel value: ${name}`);
      })
    );
    this.dx = +dx;
    this.dy = +dy;
    this.marginTop = +marginTop;
    this.marginRight = +marginRight;
    this.marginBottom = +marginBottom;
    this.marginLeft = +marginLeft;
    this.clip = maybeClip(clip);
    this.tip = maybeTip(tip2);
    this.className = string(className);
    if (this.facet === "super") {
      if (fx || fy) throw new Error(`super-faceting cannot use fx or fy`);
      for (const name in this.channels) {
        const { scale: scale2 } = channels[name];
        if (scale2 !== "x" && scale2 !== "y") continue;
        throw new Error(`super-faceting cannot use x or y`);
      }
    }
    if (render != null) {
      this.render = composeRender(render, this.render);
    }
  }
  initialize(facets, facetChannels, plotOptions) {
    let data = dataify(this.data);
    if (facets === void 0 && data != null) facets = [range2(data)];
    const originalFacets = facets;
    if (this.transform != null) ({ facets, data } = this.transform(data, facets, plotOptions)), data = dataify(data);
    if (facets !== void 0) facets.original = originalFacets;
    const channels = createChannels(this.channels, data);
    if (this.sort != null) channelDomain(data, facets, channels, facetChannels, this.sort);
    return { data, facets, channels };
  }
  filter(index, channels, values2) {
    for (const name in channels) {
      const { filter: filter2 = defined } = channels[name];
      if (filter2 !== null) {
        const value = values2[name];
        index = index.filter((i) => filter2(value[i]));
      }
    }
    return index;
  }
  // If there is a projection, and there are paired x and y channels associated
  // with the x and y scale respectively (and not already in screen coordinates
  // as with an initializer), then apply the projection, replacing the x and y
  // values. Note that the x and y scales themselves don’t exist if there is a
  // projection, but whether the channels are associated with scales still
  // determines whether the projection should apply; think of the projection as
  // a combination xy-scale.
  project(channels, values2, context) {
    for (const cx in channels) {
      if (channels[cx].scale === "x" && /^x|x$/.test(cx)) {
        const cy = cx.replace(/^x|x$/, "y");
        if (cy in channels && channels[cy].scale === "y") {
          project(cx, cy, values2, context.projection);
        }
      }
    }
  }
  scale(channels, scales, context) {
    const values2 = valueObject(channels, scales);
    if (context.projection) this.project(channels, values2, context);
    return values2;
  }
};
function marks(...marks2) {
  marks2.plot = Mark.prototype.plot;
  return marks2;
}
function composeRender(r1, r2) {
  if (r1 == null) return r2 === null ? void 0 : r2;
  if (r2 == null) return r1 === null ? void 0 : r1;
  if (typeof r1 !== "function") throw new TypeError(`invalid render transform: ${r1}`);
  if (typeof r2 !== "function") throw new TypeError(`invalid render transform: ${r2}`);
  return function(i, s, v, d, c, next) {
    return r1.call(this, i, s, v, d, c, (i2, s2, v2, d2, c2) => {
      return r2.call(this, i2, s2, v2, d2, c2, next);
    });
  };
}
function maybeChannels(channels) {
  return Object.fromEntries(
    Object.entries(maybeNamed(channels)).map(([name, channel]) => {
      channel = typeof channel === "string" ? { value: channel, label: name } : maybeValue(channel);
      if (channel.filter === void 0 && channel.scale == null) channel = { ...channel, filter: null };
      return [name, channel];
    })
  );
}
function maybeTip(tip2) {
  return tip2 === true ? "xy" : tip2 === false || tip2 == null ? null : typeof tip2 === "string" ? keyword(tip2, "tip", ["x", "y", "xy"]) : tip2;
}
function withTip(options, pointer2) {
  return (options == null ? void 0 : options.tip) === true ? { ...options, tip: pointer2 } : isObject(options == null ? void 0 : options.tip) && options.tip.pointer === void 0 ? { ...options, tip: { ...options.tip, pointer: pointer2 } } : options;
}

// node_modules/@observablehq/plot/src/dimensions.js
function createDimensions(scales, marks2, options = {}) {
  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;
  for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {
    if (marginTop2 > marginTopDefault) marginTopDefault = marginTop2;
    if (marginRight2 > marginRightDefault) marginRightDefault = marginRight2;
    if (marginBottom2 > marginBottomDefault) marginBottomDefault = marginBottom2;
    if (marginLeft2 > marginLeftDefault) marginLeftDefault = marginLeft2;
  }
  let {
    margin,
    marginTop = margin !== void 0 ? margin : marginTopDefault,
    marginRight = margin !== void 0 ? margin : marginRightDefault,
    marginBottom = margin !== void 0 ? margin : marginBottomDefault,
    marginLeft = margin !== void 0 ? margin : marginLeftDefault
  } = options;
  marginTop = +marginTop;
  marginRight = +marginRight;
  marginBottom = +marginBottom;
  marginLeft = +marginLeft;
  let {
    width = 640,
    height = autoHeight(scales, options, {
      width,
      marginTopDefault,
      marginRightDefault,
      marginBottomDefault,
      marginLeftDefault
    }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)
  } = options;
  width = +width;
  height = +height;
  const dimensions = {
    width,
    height,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft
  };
  if (scales.fx || scales.fy) {
    let {
      margin: facetMargin,
      marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop,
      marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight,
      marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom,
      marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft
    } = options.facet ?? {};
    facetMarginTop = +facetMarginTop;
    facetMarginRight = +facetMarginRight;
    facetMarginBottom = +facetMarginBottom;
    facetMarginLeft = +facetMarginLeft;
    dimensions.facet = {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    };
  }
  return dimensions;
}
function autoHeight({ x, y, fy, fx }, { projection: projection2, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {
  const nfy = fy ? fy.scale.domain().length || 1 : 1;
  const ar = projectionAspectRatio(projection2);
  if (ar) {
    const nfx = fx ? fx.scale.domain().length : 1;
    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
    const lar = Math.max(0.1, Math.min(10, far));
    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
  }
  const ny = y ? isOrdinalScale(y) ? y.scale.domain().length || 1 : Math.max(7, 17 / nfy) : 1;
  if (aspectRatio != null) {
    aspectRatio = +aspectRatio;
    if (!(isFinite(aspectRatio) && aspectRatio > 0)) throw new Error(`invalid aspectRatio: ${aspectRatio}`);
    const ratio = aspectRatioLength("y", y) / (aspectRatioLength("x", x) * aspectRatio);
    const fxb = fx ? fx.scale.bandwidth() : 1;
    const fyb = fy ? fy.scale.bandwidth() : 1;
    const w = fxb * (width - marginLeftDefault - marginRightDefault) - x.insetLeft - x.insetRight;
    return (ratio * w + y.insetTop + y.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
  }
  return !!(y || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
}
function aspectRatioLength(k, scale2) {
  if (!scale2) throw new Error(`aspectRatio requires ${k} scale`);
  const { type, domain } = scale2;
  let transform;
  switch (type) {
    case "linear":
    case "utc":
    case "time":
      transform = Number;
      break;
    case "pow": {
      const exponent = scale2.scale.exponent();
      transform = (x) => Math.pow(x, exponent);
      break;
    }
    case "log":
      transform = Math.log;
      break;
    case "point":
    case "band":
      return domain.length;
    default:
      throw new Error(`unsupported ${k} scale for aspectRatio: ${type}`);
  }
  const [min2, max2] = extent(domain);
  return Math.abs(transform(max2) - transform(min2));
}

// node_modules/@observablehq/plot/src/interactions/pointer.js
var states = /* @__PURE__ */ new WeakMap();
function pointerK(kx, ky, { x, y, px, py, maxRadius = 40, channels, render, ...options } = {}) {
  maxRadius = +maxRadius;
  if (px != null) x ?? (x = null), channels = { ...channels, px: { value: px, scale: "x" } };
  if (py != null) y ?? (y = null), channels = { ...channels, py: { value: py, scale: "y" } };
  return {
    x,
    y,
    channels,
    ...options,
    // Unlike other composed transforms, the render transform must be the
    // outermost render function because it will re-render dynamically in
    // response to pointer events.
    render: composeRender(function(index, scales, values2, dimensions, context, next) {
      context = { ...context, pointerSticky: false };
      const svg = context.ownerSVGElement;
      const { data } = context.getMarkState(this);
      let state = states.get(svg);
      if (!state) states.set(svg, state = { sticky: false, roots: [], renders: [] });
      let renderIndex = state.renders.push(render2) - 1;
      const { x: x2, y: y2, fx, fy } = scales;
      let tx = fx ? fx(index.fx) - dimensions.marginLeft : 0;
      let ty = fy ? fy(index.fy) - dimensions.marginTop : 0;
      if (x2 == null ? void 0 : x2.bandwidth) tx += x2.bandwidth() / 2;
      if (y2 == null ? void 0 : y2.bandwidth) ty += y2.bandwidth() / 2;
      const faceted = index.fi != null;
      let facetState;
      if (faceted) {
        let facetStates = state.facetStates;
        if (!facetStates) state.facetStates = facetStates = /* @__PURE__ */ new Map();
        facetState = facetStates.get(this);
        if (!facetState) facetStates.set(this, facetState = /* @__PURE__ */ new Map());
      }
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const { px: PX, py: PY } = values2;
      const px2 = PX ? (i2) => PX[i2] : anchorX(values2, cx);
      const py2 = PY ? (i2) => PY[i2] : anchorY(values2, cy);
      let i;
      let g;
      let s;
      let f;
      function update(ii, ri) {
        if (faceted) {
          if (f) f = cancelAnimationFrame(f);
          if (ii == null) facetState.delete(index.fi);
          else {
            facetState.set(index.fi, ri);
            f = requestAnimationFrame(() => {
              f = null;
              for (const [fi, r] of facetState) {
                if (r < ri || r === ri && fi < index.fi) {
                  ii = null;
                  break;
                }
              }
              render2(ii);
            });
            return;
          }
        }
        render2(ii);
      }
      function render2(ii) {
        if (i === ii && s === state.sticky) return;
        i = ii;
        s = context.pointerSticky = state.sticky;
        const I = i == null ? [] : [i];
        if (faceted) I.fx = index.fx, I.fy = index.fy, I.fi = index.fi;
        const r = next(I, scales, values2, dimensions, context);
        if (g) {
          if (faceted) {
            const p = g.parentNode;
            const ft = g.getAttribute("transform");
            const mt = r.getAttribute("transform");
            ft ? r.setAttribute("transform", ft) : r.removeAttribute("transform");
            mt ? p.setAttribute("transform", mt) : p.removeAttribute("transform");
            r.removeAttribute("aria-label");
            r.removeAttribute("aria-description");
            r.removeAttribute("aria-hidden");
          }
          g.replaceWith(r);
        }
        state.roots[renderIndex] = g = r;
        if (!(i == null && (facetState == null ? void 0 : facetState.size) > 1)) {
          const value = i == null ? null : isArray(data) ? data[i] : data.get(i);
          context.dispatchValue(value);
        }
        return r;
      }
      function pointermove(event) {
        if (state.sticky || event.pointerType === "mouse" && event.buttons === 1) return;
        let [xp, yp] = pointer_default(event);
        xp -= tx, yp -= ty;
        const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx;
        const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky;
        let ii = null;
        let ri = maxRadius * maxRadius;
        for (const j of index) {
          const dx = kpx * (px2(j) - xp);
          const dy = kpy * (py2(j) - yp);
          const rj = dx * dx + dy * dy;
          if (rj <= ri) ii = j, ri = rj;
        }
        if (ii != null && (kx !== 1 || ky !== 1)) {
          const dx = px2(ii) - xp;
          const dy = py2(ii) - yp;
          ri = dx * dx + dy * dy;
        }
        update(ii, ri);
      }
      function pointerdown(event) {
        if (event.pointerType !== "mouse") return;
        if (i == null) return;
        if (state.sticky && state.roots.some((r) => r == null ? void 0 : r.contains(event.target))) return;
        if (state.sticky) state.sticky = false, state.renders.forEach((r) => r(null));
        else state.sticky = true, render2(i);
        event.stopImmediatePropagation();
      }
      function pointerleave(event) {
        if (event.pointerType !== "mouse") return;
        if (!state.sticky) update(null);
      }
      svg.addEventListener("pointerenter", pointermove);
      svg.addEventListener("pointermove", pointermove);
      svg.addEventListener("pointerdown", pointerdown);
      svg.addEventListener("pointerleave", pointerleave);
      return render2(null);
    }, render)
  };
}
function pointer(options) {
  return pointerK(1, 1, options);
}
function pointerX(options) {
  return pointerK(1, 0.01, options);
}
function pointerY(options) {
  return pointerK(0.01, 1, options);
}
function anchorX({ x1: X1, x2: X2, x: X = X1 }, cx) {
  return X1 && X2 ? (i) => (X1[i] + X2[i]) / 2 : X ? (i) => X[i] : () => cx;
}
function anchorY({ y1: Y1, y2: Y2, y: Y = Y1 }, cy) {
  return Y1 && Y2 ? (i) => (Y1[i] + Y2[i]) / 2 : Y ? (i) => Y[i] : () => cy;
}

// node_modules/@observablehq/plot/src/axes.js
function inferFontVariant(scale2) {
  return isOrdinalScale(scale2) && scale2.interval === void 0 ? void 0 : "tabular-nums";
}

// node_modules/@observablehq/plot/src/legends/ramp.js
function legendRamp(color2, options) {
  let {
    label = color2.label,
    tickSize = 6,
    width = 240,
    height = 44 + tickSize,
    marginTop = 18,
    marginRight = 0,
    marginBottom = 16 + tickSize,
    marginLeft = 0,
    style,
    ticks: ticks2 = (width - marginLeft - marginRight) / 64,
    tickFormat,
    fontVariant = inferFontVariant(color2),
    round: round2 = true,
    opacity: opacity2,
    className
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  opacity2 = maybeNumberChannel(opacity2)[1];
  if (tickFormat === null) tickFormat = () => null;
  const svg = create("svg", context).attr("class", `${className}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `:where(.${className}-ramp) {
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
:where(.${className}-ramp text) {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  let tickAdjust = (g) => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
  let x;
  const applyRange = round2 ? (x2, range4) => x2.rangeRound(range4) : (x2, range4) => x2.range(range4);
  const { type, domain, range: range3, interpolate, scale: scale2, pivot } = color2;
  if (interpolate) {
    const interpolator = range3 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range3);
    x = applyRange(
      scale2.copy(),
      quantize_default(
        number_default(marginLeft, width - marginRight),
        Math.min(domain.length + (pivot !== void 0), range3 === void 0 ? Infinity : range3.length)
      )
    );
    const n = 256;
    const canvas = context.document.createElement("canvas");
    canvas.width = n;
    canvas.height = 1;
    const context2 = canvas.getContext("2d");
    for (let i = 0, j = n - 1; i < n; ++i) {
      context2.fillStyle = interpolator(i / j);
      context2.fillRect(i, 0, 1, 1);
    }
    svg.append("image").attr("opacity", opacity2).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
  } else if (type === "threshold") {
    const thresholds = domain;
    const thresholdFormat = tickFormat === void 0 ? (d) => d : typeof tickFormat === "string" ? format(tickFormat) : tickFormat;
    x = applyRange(linear().domain([-1, range3.length - 1]), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(range3).enter().append("rect").attr("x", (d, i) => x(i - 1)).attr("y", marginTop).attr("width", (d, i) => x(i) - x(i - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d) => d);
    ticks2 = map(thresholds, (_, i) => i);
    tickFormat = (i) => thresholdFormat(thresholds[i], i);
  } else {
    x = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x).attr("y", marginTop).attr("width", Math.max(0, x.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale2);
    tickAdjust = () => {
    };
  }
  svg.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
    axisBottom(x).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat === "string" ? tickFormat : void 0).tickFormat(typeof tickFormat === "function" ? tickFormat : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
  ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g) => g.select(".domain").remove());
  if (label !== void 0) {
    svg.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
  }
  return svg.node();
}

// node_modules/@observablehq/plot/src/math.js
var radians = Math.PI / 180;

// node_modules/@observablehq/plot/src/marker.js
function markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {
  mark.markerStart = maybeMarker(markerStart);
  mark.markerMid = maybeMarker(markerMid);
  mark.markerEnd = maybeMarker(markerEnd);
}
function maybeMarker(marker) {
  if (marker == null || marker === false) return null;
  if (marker === true) return markerCircleFill;
  if (typeof marker === "function") return marker;
  switch (`${marker}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return markerArrow("auto");
    case "arrow-reverse":
      return markerArrow("auto-start-reverse");
    case "dot":
      return markerDot;
    case "circle":
    case "circle-fill":
      return markerCircleFill;
    case "circle-stroke":
      return markerCircleStroke;
    case "tick":
      return markerTick("auto");
    case "tick-x":
      return markerTick(90);
    case "tick-y":
      return markerTick(0);
  }
  throw new Error(`invalid marker: ${marker}`);
}
function markerArrow(orient) {
  return (color2, context) => create("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", orient).attr("fill", "none").attr("stroke", color2).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function markerDot(color2, context) {
  return create("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color2).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
}
function markerCircleFill(color2, context) {
  return create("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color2).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerCircleStroke(color2, context) {
  return create("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", color2).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerTick(orient) {
  return (color2, context) => create("svg:marker", context).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", orient).attr("stroke", color2).call((marker) => marker.append("path").attr("d", "M0,-3v6")).node();
}
var nextMarkerId = 0;
function applyMarkers(path, mark, { stroke: S }, context) {
  return applyMarkersColor(path, mark, S && ((i) => S[i]), null, context);
}
function applyGroupedMarkers(path, mark, { stroke: S, z: Z }, context) {
  return applyMarkersColor(path, mark, S && (([i]) => S[i]), Z, context);
}
var START = 1;
var END = 2;
function getGroupedOrientation(path, Z) {
  const O = new Uint8Array(Z.length);
  const D = path.data().filter((I) => I.length > 1);
  const n = D.length;
  for (let i = 0, z = unset; i < n; ++i) {
    const I = D[i];
    if (I.length > 1) {
      const i2 = I[0];
      if (z !== (z = keyof(Z[i2]))) O[i2] |= START;
    }
  }
  for (let i = n - 1, z = unset; i >= 0; --i) {
    const I = D[i];
    if (I.length > 1) {
      const i2 = I[0];
      if (z !== (z = keyof(Z[i2]))) O[i2] |= END;
    }
  }
  return ([i]) => O[i];
}
function applyMarkersColor(path, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke, Z, context) {
  if (!markerStart && !markerMid && !markerEnd) return;
  const iriByMarkerColor = /* @__PURE__ */ new Map();
  const orient = Z && getGroupedOrientation(path, Z);
  function applyMarker(name, marker, filter2) {
    return function(i) {
      if (filter2 && !filter2(i)) return;
      const color2 = strokeof(i);
      let iriByColor = iriByMarkerColor.get(marker);
      if (!iriByColor) iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
      let iri = iriByColor.get(color2);
      if (!iri) {
        const node = this.parentNode.insertBefore(marker(color2, context), this);
        const id = `plot-marker-${++nextMarkerId}`;
        node.setAttribute("id", id);
        iriByColor.set(color2, iri = `url(#${id})`);
      }
      this.setAttribute(name, iri);
    };
  }
  if (markerStart) path.each(applyMarker("marker-start", markerStart, orient && ((i) => orient(i) & START)));
  if (markerMid && orient) path.each(applyMarker("marker-start", markerMid, (i) => !(orient(i) & START)));
  if (markerMid) path.each(applyMarker("marker-mid", markerMid));
  if (markerEnd) path.each(applyMarker("marker-end", markerEnd, orient && ((i) => orient(i) & END)));
}

// node_modules/@observablehq/plot/src/transforms/inset.js
function maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {
  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
  return { inset, insetLeft, insetRight, ...options };
}
function maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {
  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
  return { inset, insetTop, insetBottom, ...options };
}
function maybeInset(inset, inset1, inset2) {
  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
}

// node_modules/@observablehq/plot/src/transforms/interval.js
function maybeIntervalValue(value, { interval }) {
  value = { ...maybeValue(value) };
  value.interval = maybeInterval(value.interval === void 0 ? interval : value.interval);
  return value;
}
function maybeIntervalK(k, maybeInsetK, options, trivial) {
  const { [k]: v, [`${k}1`]: v1, [`${k}2`]: v2 } = options;
  const { value, interval } = maybeIntervalValue(v, options);
  if (value == null || interval == null && !trivial) return options;
  const label = labelof(v);
  if (interval == null) {
    let V;
    const kv = { transform: (data) => V || (V = valueof(data, value)), label };
    return {
      ...options,
      [k]: void 0,
      [`${k}1`]: v1 === void 0 ? kv : v1,
      [`${k}2`]: v2 === void 0 && !(v1 === v2 && trivial) ? kv : v2
    };
  }
  let D1, V1;
  function transform(data) {
    if (V1 !== void 0 && data === D1) return V1;
    return V1 = map(valueof(D1 = data, value), (v3) => interval.floor(v3));
  }
  return maybeInsetK({
    ...options,
    [k]: void 0,
    [`${k}1`]: v1 === void 0 ? { transform, label } : v1,
    [`${k}2`]: v2 === void 0 ? { transform: (data) => transform(data).map((v3) => interval.offset(v3)), label } : v2
  });
}
function maybeIntervalMidK(k, maybeInsetK, options) {
  const { [k]: v } = options;
  const { value, interval } = maybeIntervalValue(v, options);
  if (value == null || interval == null) return options;
  return maybeInsetK({
    ...options,
    [k]: {
      label: labelof(v),
      transform: (data) => {
        const V1 = map(valueof(data, value), (v2) => interval.floor(v2));
        const V2 = V1.map((v2) => interval.offset(v2));
        return V1.map(
          isTemporal(V1) ? (v1, v2) => v1 == null || isNaN(v1 = +v1) || (v2 = V2[v2], v2 == null) || isNaN(v2 = +v2) ? void 0 : new Date((v1 + v2) / 2) : (v1, v2) => v1 == null || (v2 = V2[v2], v2 == null) ? NaN : (+v1 + +v2) / 2
        );
      }
    }
  });
}
function maybeTrivialIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options, true);
}
function maybeTrivialIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options, true);
}
function maybeIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options);
}
function maybeIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options);
}
function maybeIntervalMidX(options = {}) {
  return maybeIntervalMidK("x", maybeInsetX, options);
}
function maybeIntervalMidY(options = {}) {
  return maybeIntervalMidK("y", maybeInsetY, options);
}

// node_modules/@observablehq/plot/src/marks/rule.js
var defaults = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
var RuleX = class extends Mark {
  constructor(data, options = {}) {
    const { x, y1, y2, inset = 0, insetTop = inset, insetBottom = inset } = options;
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y1: { value: y1, scale: "y", optional: true },
        y2: { value: y2, scale: "y", optional: true }
      },
      withTip(options, "x"),
      defaults
    );
    this.insetTop = number(insetTop);
    this.insetBottom = number(insetBottom);
    markers(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y1: Y1, y2: Y2 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetTop, insetBottom } = this;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X && x }, offset, 0).call(
      (g) => g.selectAll().data(index).enter().append("line").call(applyDirectStyles, this).attr("x1", X ? (i) => X[i] : (marginLeft + width - marginRight) / 2).attr("x2", X ? (i) => X[i] : (marginLeft + width - marginRight) / 2).attr("y1", Y1 && !isCollapsed(y) ? (i) => Y1[i] + insetTop : marginTop + insetTop).attr(
        "y2",
        Y2 && !isCollapsed(y) ? y.bandwidth ? (i) => Y2[i] + y.bandwidth() - insetBottom : (i) => Y2[i] - insetBottom : height - marginBottom - insetBottom
      ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
var RuleY = class extends Mark {
  constructor(data, options = {}) {
    const { x1, x2, y, inset = 0, insetRight = inset, insetLeft = inset } = options;
    super(
      data,
      {
        y: { value: y, scale: "y", optional: true },
        x1: { value: x1, scale: "x", optional: true },
        x2: { value: x2, scale: "x", optional: true }
      },
      withTip(options, "y"),
      defaults
    );
    this.insetRight = number(insetRight);
    this.insetLeft = number(insetLeft);
    markers(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { y: Y, x1: X1, x2: X2 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetLeft, insetRight } = this;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y && y }, 0, offset).call(
      (g) => g.selectAll().data(index).enter().append("line").call(applyDirectStyles, this).attr("x1", X1 && !isCollapsed(x) ? (i) => X1[i] + insetLeft : marginLeft + insetLeft).attr(
        "x2",
        X2 && !isCollapsed(x) ? x.bandwidth ? (i) => X2[i] + x.bandwidth() - insetRight : (i) => X2[i] - insetRight : width - marginRight - insetRight
      ).attr("y1", Y ? (i) => Y[i] : (marginTop + height - marginBottom) / 2).attr("y2", Y ? (i) => Y[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
function ruleX(data, options) {
  let { x = identity2, y, y1, y2, ...rest } = maybeIntervalY(options);
  [y1, y2] = maybeOptionalZero(y, y1, y2);
  return new RuleX(data, { ...rest, x, y1, y2 });
}
function ruleY(data, options) {
  let { y = identity2, x, x1, x2, ...rest } = maybeIntervalX(options);
  [x1, x2] = maybeOptionalZero(x, x1, x2);
  return new RuleY(data, { ...rest, y, x1, x2 });
}
function maybeOptionalZero(x, x1, x2) {
  if (x == null) {
    if (x1 === void 0) {
      if (x2 !== void 0) return [0, x2];
    } else {
      if (x2 === void 0) return [0, x1];
    }
  } else if (x1 === void 0) {
    return x2 === void 0 ? [0, x] : [x, x2];
  } else if (x2 === void 0) {
    return [x, x1];
  }
  return [x1, x2];
}

// node_modules/@observablehq/plot/src/template.js
function template(strings, ...parts) {
  let n = parts.length;
  for (let j = 0, copy = true; j < n; ++j) {
    if (typeof parts[j] !== "function") {
      if (copy) {
        strings = strings.slice();
        copy = false;
      }
      strings.splice(j, 2, strings[j] + parts[j] + strings[j + 1]);
      parts.splice(j, 1);
      --j, --n;
    }
  }
  return (i) => {
    let s = strings[0];
    for (let j = 0; j < n; ++j) {
      s += parts[j](i) + strings[j + 1];
    }
    return s;
  };
}

// node_modules/@observablehq/plot/src/marks/text.js
var defaults2 = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
};
var softHyphen = "­";
var Text = class extends Mark {
  constructor(data, options = {}) {
    const {
      x,
      y,
      text: text2 = isIterable(data) && isTextual(data) ? identity2 : indexOf,
      frameAnchor,
      textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
      lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
      lineHeight = 1,
      lineWidth = Infinity,
      textOverflow,
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      rotate
    } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        fontSize: { value: vfontSize, optional: true },
        rotate: { value: numberChannel(vrotate), optional: true },
        text: { value: text2, filter: nonempty, optional: true }
      },
      options,
      defaults2
    );
    this.rotate = crotate;
    this.textAnchor = impliedString(textAnchor, "middle");
    this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = cfontSize;
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    if (!(this.lineWidth >= 0)) throw new Error(`invalid lineWidth: ${lineWidth}`);
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y: Y, rotate: R, text: T, title: TL, fontSize: FS } = channels;
    const { rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, { x: X && x, y: Y && y }).call(
      (g) => g.selectAll().data(index).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(
        "transform",
        template`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`
      ).call(applyAttr, "font-size", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function maybeTextOverflow(textOverflow) {
  return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
    "clip",
    // shorthand for clip-end
    "ellipsis",
    // … ellipsis-end
    "clip-start",
    "clip-end",
    "ellipsis-start",
    "ellipsis-middle",
    "ellipsis-end"
  ]).replace(/^(clip|ellipsis)$/, "$1-end");
}
function applyMultilineText(selection, mark, T, TL) {
  if (!T) return;
  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;
  selection.each(function(i) {
    const lines = splitLines(formatDefault(T[i]) ?? "").map(clipLine);
    const n = lines.length;
    const y = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n : (164 - n * 100) / 200;
    if (n > 1) {
      let m = 0;
      for (let i2 = 0; i2 < n; ++i2) {
        ++m;
        if (!lines[i2]) continue;
        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
        tspan.setAttribute("x", 0);
        if (i2 === m - 1) tspan.setAttribute("y", `${(y + i2) * lineHeight}em`);
        else tspan.setAttribute("dy", `${m * lineHeight}em`);
        tspan.textContent = lines[i2];
        this.appendChild(tspan);
        m = 0;
      }
    } else {
      if (y) this.setAttribute("y", `${y * lineHeight}em`);
      this.textContent = lines[0];
    }
    if (textOverflow && !TL && lines[0] !== T[i]) {
      const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
      title.textContent = T[i];
      this.appendChild(title);
    }
  });
}
function text(data, { x, y, ...options } = {}) {
  if (options.frameAnchor === void 0) [x, y] = maybeTuple(x, y);
  return new Text(data, { ...options, x, y });
}
function textX(data, { x = identity2, ...options } = {}) {
  return new Text(data, maybeIntervalMidY({ ...options, x }));
}
function textY(data, { y = identity2, ...options } = {}) {
  return new Text(data, maybeIntervalMidX({ ...options, y }));
}
function applyIndirectTextStyles(selection, mark, T) {
  applyAttr(selection, "text-anchor", mark.textAnchor);
  applyAttr(selection, "font-family", mark.fontFamily);
  applyAttr(selection, "font-size", mark.fontSize);
  applyAttr(selection, "font-style", mark.fontStyle);
  applyAttr(selection, "font-variant", mark.fontVariant === void 0 ? inferFontVariant2(T) : mark.fontVariant);
  applyAttr(selection, "font-weight", mark.fontWeight);
}
function inferFontVariant2(T) {
  return T && (isNumeric(T) || isTemporal(T)) ? "tabular-nums" : void 0;
}
var fontSizes = /* @__PURE__ */ new Set([
  // global keywords
  "inherit",
  "initial",
  "revert",
  "unset",
  // absolute keywords
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  // relative keywords
  "larger",
  "smaller"
]);
function maybeFontSizeChannel(fontSize) {
  if (fontSize == null || typeof fontSize === "number") return [void 0, fontSize];
  if (typeof fontSize !== "string") return [fontSize, void 0];
  fontSize = fontSize.trim().toLowerCase();
  return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
}
function lineWrap(input, maxWidth, widthof) {
  const lines = [];
  let lineStart, lineEnd = 0;
  for (const [wordStart, wordEnd, required] of lineBreaks(input)) {
    if (lineStart === void 0) lineStart = wordStart;
    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? "-" : ""));
      lineStart = wordStart;
    }
    if (required) {
      lines.push(input.slice(lineStart, wordEnd));
      lineStart = void 0;
      continue;
    }
    lineEnd = wordEnd;
  }
  return lines;
}
function* lineBreaks(input) {
  let i = 0, j = 0;
  const n = input.length;
  while (j < n) {
    let k = 1;
    switch (input[j]) {
      case softHyphen:
      case "-":
        ++j;
        yield [i, j, false];
        i = j;
        break;
      case " ":
        yield [i, j, false];
        while (input[++j] === " ") ;
        i = j;
        break;
      case "\r":
        if (input[j + 1] === "\n") ++k;
      case "\n":
        yield [i, j, true];
        j += k;
        i = j;
        break;
      default:
        ++j;
        break;
    }
  }
  yield [i, j, true];
}
var defaultWidthMap = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "‘": 31,
  "’": 31,
  "“": 47,
  "”": 47,
  "…": 82
};
function defaultWidth(text2, start = 0, end = text2.length) {
  let sum2 = 0;
  for (let i = start; i < end; i = readCharacter(text2, i)) {
    sum2 += defaultWidthMap[text2[i]] ?? (isPictographic(text2, i) ? 120 : defaultWidthMap.e);
  }
  return sum2;
}
function monospaceWidth(text2, start = 0, end = text2.length) {
  let sum2 = 0;
  for (let i = start; i < end; i = readCharacter(text2, i)) {
    sum2 += isPictographic(text2, i) ? 126 : 63;
  }
  return sum2;
}
function splitter({ monospace, lineWidth, textOverflow }) {
  if (textOverflow != null || lineWidth == Infinity) return (text2) => text2.split(/\r\n?|\n/g);
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  return (text2) => lineWrap(text2, maxWidth, widthof);
}
function clipper({ monospace, lineWidth, textOverflow }) {
  if (textOverflow == null || lineWidth == Infinity) return (text2) => text2;
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  switch (textOverflow) {
    case "clip-start":
      return (text2) => clipStart(text2, maxWidth, widthof, "");
    case "clip-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, "");
    case "ellipsis-start":
      return (text2) => clipStart(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-middle":
      return (text2) => clipMiddle(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, ellipsis);
  }
}
var ellipsis = "…";
function cut(text2, width, widthof, inset) {
  const I = [];
  let w = 0;
  for (let i = 0, j = 0, n = text2.length; i < n; i = j) {
    j = readCharacter(text2, i);
    const l = widthof(text2, i, j);
    if (w + l > width) {
      w += inset;
      while (w > width && i > 0) j = i, i = I.pop(), w -= widthof(text2, i, j);
      return [i, width - w];
    }
    w += l;
    I.push(i);
  }
  return [-1, 0];
}
function clipEnd(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const e = widthof(ellipsis2);
  const [i] = cut(text2, width, widthof, e);
  return i < 0 ? text2 : text2.slice(0, i).trimEnd() + ellipsis2;
}
function clipMiddle(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w = widthof(text2);
  if (w <= width) return text2;
  const e = widthof(ellipsis2) / 2;
  const [i, ei] = cut(text2, width / 2, widthof, e);
  const [j] = cut(text2, w - width / 2 - ei + e, widthof, -e);
  return j < 0 ? ellipsis2 : text2.slice(0, i).trimEnd() + ellipsis2 + text2.slice(readCharacter(text2, j)).trimStart();
}
function clipStart(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w = widthof(text2);
  if (w <= width) return text2;
  const e = widthof(ellipsis2);
  const [j] = cut(text2, w - width + e, widthof, -e);
  return j < 0 ? ellipsis2 : ellipsis2 + text2.slice(readCharacter(text2, j)).trimStart();
}
var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
var rePictographic = new RegExp("\\p{Extended_Pictographic}", "uy");
function readCharacter(text2, i) {
  i += isSurrogatePair(text2, i) ? 2 : 1;
  if (isCombiner(text2, i)) i = reCombiner.lastIndex;
  if (isZeroWidthJoiner(text2, i)) return readCharacter(text2, i + 1);
  return i;
}
function isAscii(text2, i) {
  return text2.charCodeAt(i) < 128;
}
function isSurrogatePair(text2, i) {
  const hi = text2.charCodeAt(i);
  if (hi >= 55296 && hi < 56320) {
    const lo = text2.charCodeAt(i + 1);
    return lo >= 56320 && lo < 57344;
  }
  return false;
}
function isZeroWidthJoiner(text2, i) {
  return text2.charCodeAt(i) === 8205;
}
function isCombiner(text2, i) {
  return isAscii(text2, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text2));
}
function isPictographic(text2, i) {
  return isAscii(text2, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text2));
}

// node_modules/@observablehq/plot/src/marks/vector.js
var defaults3 = {
  ariaLabel: "vector",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinejoin: "round",
  strokeLinecap: "round"
};
var defaultRadius = 3.5;
var wingRatio = defaultRadius * 5;
var shapeArrow = {
  draw(context, l, r) {
    const wing = l * r / wingRatio;
    context.moveTo(0, 0);
    context.lineTo(0, -l);
    context.moveTo(-wing, wing - l);
    context.lineTo(0, -l);
    context.lineTo(wing, wing - l);
  }
};
var shapeSpike = {
  draw(context, l, r) {
    context.moveTo(-r, 0);
    context.lineTo(0, -l);
    context.lineTo(r, 0);
  }
};
var shapes = /* @__PURE__ */ new Map([
  ["arrow", shapeArrow],
  ["spike", shapeSpike]
]);
function isShapeObject(value) {
  return value && typeof value.draw === "function";
}
function maybeShape(shape) {
  if (isShapeObject(shape)) return shape;
  const value = shapes.get(`${shape}`.toLowerCase());
  if (value) return value;
  throw new Error(`invalid shape: ${shape}`);
}
var Vector = class extends Mark {
  constructor(data, options = {}) {
    const { x, y, r = defaultRadius, length: length2, rotate, shape = shapeArrow, anchor = "middle", frameAnchor } = options;
    const [vl, cl] = maybeNumberChannel(length2, 12);
    const [vr, cr] = maybeNumberChannel(rotate, 0);
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        length: { value: vl, scale: "length", optional: true },
        rotate: { value: vr, optional: true }
      },
      options,
      defaults3
    );
    this.r = +r;
    this.length = cl;
    this.rotate = cr;
    this.shape = maybeShape(shape);
    this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y: Y, length: L, rotate: A } = channels;
    const { length: length2, rotate, anchor, shape, r } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X && x, y: Y && y }).call(
      (g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr(
        "transform",
        template`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${A ? (i) => ` rotate(${A[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L ? (i) => ` translate(0,${L[i]})` : ` translate(0,${length2})` : L ? (i) => ` translate(0,${L[i] / 2})` : ` translate(0,${length2 / 2})`}`
      ).attr(
        "d",
        L ? (i) => {
          const p = pathRound();
          shape.draw(p, L[i], r);
          return p;
        } : (() => {
          const p = pathRound();
          shape.draw(p, length2, r);
          return p;
        })()
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function vector(data, options = {}) {
  let { x, y, ...rest } = options;
  if (options.frameAnchor === void 0) [x, y] = maybeTuple(x, y);
  return new Vector(data, { ...rest, x, y });
}
function vectorX(data, options = {}) {
  const { x = identity2, ...rest } = options;
  return new Vector(data, { ...rest, x });
}
function vectorY(data, options = {}) {
  const { y = identity2, ...rest } = options;
  return new Vector(data, { ...rest, y });
}
function spike(data, options = {}) {
  const {
    shape = shapeSpike,
    stroke = defaults3.stroke,
    strokeWidth = 1,
    fill = stroke,
    fillOpacity = 0.3,
    anchor = "start",
    ...rest
  } = options;
  return vector(data, { ...rest, shape, stroke, strokeWidth, fill, fillOpacity, anchor });
}

// node_modules/@observablehq/plot/src/marks/axis.js
function maybeData(data, options) {
  if (arguments.length < 2 && !isIterable(data)) options = data, data = null;
  if (options === void 0) options = {};
  return [data, options];
}
function maybeAnchor2({ anchor } = {}, anchors) {
  return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
}
function anchorY2(options) {
  return maybeAnchor2(options, ["left", "right"]);
}
function anchorFy(options) {
  return maybeAnchor2(options, ["right", "left"]);
}
function anchorX2(options) {
  return maybeAnchor2(options, ["bottom", "top"]);
}
function anchorFx(options) {
  return maybeAnchor2(options, ["top", "bottom"]);
}
function axisY() {
  const [data, options] = maybeData(...arguments);
  return axisKy("y", anchorY2(options), data, options);
}
function axisFy() {
  const [data, options] = maybeData(...arguments);
  return axisKy("fy", anchorFy(options), data, options);
}
function axisX() {
  const [data, options] = maybeData(...arguments);
  return axisKx("x", anchorX2(options), data, options);
}
function axisFx() {
  const [data, options] = maybeData(...arguments);
  return axisKx("fx", anchorFx(options), data, options);
}
function axisKy(k, anchor, data, {
  color: color2 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color2,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color2,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k === "y" ? 6 : 0,
  tickPadding,
  tickRotate,
  x,
  margin,
  marginTop = margin === void 0 ? 20 : margin,
  marginRight = margin === void 0 ? anchor === "right" ? 40 : 0 : margin,
  marginBottom = margin === void 0 ? 20 : margin,
  marginLeft = margin === void 0 ? anchor === "left" ? 40 : 0 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ariaLabel = `${k}-axis`,
  ...options
}) {
  tickSize = number(tickSize);
  tickPadding = number(tickPadding);
  tickRotate = number(tickRotate);
  if (labelAnchor !== void 0) labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKy(k, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      x,
      ariaLabel,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKy(k, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      x,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ariaLabel,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale2 = scales[k];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k === "y" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale2.bandwidth ? "center" : "top");
        const clo = labelOffset ?? (anchor === "right" ? marginRight2 : marginLeft2) - 3;
        if (cla === "center") {
          this.textAnchor = void 0;
          this.lineAnchor = anchor === "right" ? "bottom" : "top";
          this.frameAnchor = anchor;
          this.rotate = -90;
        } else {
          this.textAnchor = anchor === "right" ? "end" : "start";
          this.lineAnchor = cla;
          this.frameAnchor = `${cla}-${anchor}`;
          this.rotate = 0;
        }
        this.dy = cla === "top" ? 3 - marginTop2 : cla === "bottom" ? marginBottom2 - 3 : 0;
        this.dx = anchor === "right" ? clo : -clo;
        this.ariaLabel = `${ariaLabel} label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k, scale2, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisKx(k, anchor, data, {
  color: color2 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color2,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color2,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k === "x" ? 6 : 0,
  tickPadding,
  tickRotate,
  y,
  margin,
  marginTop = margin === void 0 ? anchor === "top" ? 30 : 0 : margin,
  marginRight = margin === void 0 ? 20 : margin,
  marginBottom = margin === void 0 ? anchor === "bottom" ? 30 : 0 : margin,
  marginLeft = margin === void 0 ? 20 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ariaLabel = `${k}-axis`,
  ...options
}) {
  tickSize = number(tickSize);
  tickPadding = number(tickPadding);
  tickRotate = number(tickRotate);
  if (labelAnchor !== void 0) labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKx(k, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      y,
      ariaLabel,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKx(k, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      y,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ariaLabel,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale2 = scales[k];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k === "x" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale2.bandwidth ? "center" : "right");
        const clo = labelOffset ?? (anchor === "top" ? marginTop2 : marginBottom2) - 3;
        if (cla === "center") {
          this.frameAnchor = anchor;
          this.textAnchor = void 0;
        } else {
          this.frameAnchor = `${anchor}-${cla}`;
          this.textAnchor = cla === "right" ? "end" : "start";
        }
        this.lineAnchor = anchor;
        this.dy = anchor === "top" ? -clo : clo;
        this.dx = cla === "right" ? marginRight2 - 3 : cla === "left" ? 3 - marginLeft2 : 0;
        this.ariaLabel = `${ariaLabel} label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k, scale2, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisTickKy(k, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  y = k === "y" ? void 0 : null,
  ariaLabel,
  ...options
}) {
  return axisMark(
    vectorY,
    k,
    data,
    {
      ariaLabel: `${ariaLabel} tick`,
      ariaHidden: true
    },
    {
      strokeWidth,
      strokeLinecap,
      strokeLinejoin,
      facetAnchor,
      frameAnchor,
      y,
      ...options,
      dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
      anchor: "start",
      length: tickSize,
      shape: anchor === "left" ? shapeTickLeft : shapeTickRight
    }
  );
}
function axisTickKx(k, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x = k === "x" ? void 0 : null,
  ariaLabel,
  ...options
}) {
  return axisMark(
    vectorX,
    k,
    data,
    {
      ariaLabel: `${ariaLabel} tick`,
      ariaHidden: true
    },
    {
      strokeWidth,
      strokeLinejoin,
      strokeLinecap,
      facetAnchor,
      frameAnchor,
      x,
      ...options,
      dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
      anchor: "start",
      length: tickSize,
      shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
    }
  );
}
function axisTextKy(k, anchor, data, {
  facetAnchor = anchor + (k === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians) : 0),
  text: text2,
  textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
  lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
  fontVariant,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  ariaLabel,
  y = k === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textY,
    k,
    data,
    { ariaLabel: `${ariaLabel} tick label` },
    {
      facetAnchor,
      frameAnchor,
      text: text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      y,
      ...options,
      dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
    },
    function(scale2, data2, ticks2, tickFormat, channels) {
      if (fontVariant === void 0) this.fontVariant = inferFontVariant3(scale2);
      if (text2 === void 0) channels.text = inferTextChannel(scale2, data2, ticks2, tickFormat, anchor);
    }
  );
}
function axisTextKx(k, anchor, data, {
  facetAnchor = anchor + (k === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians) : 0),
  text: text2,
  textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
  lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
  fontVariant,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x = k === "x" ? void 0 : null,
  ariaLabel,
  ...options
}) {
  return axisMark(
    textX,
    k,
    data,
    { ariaLabel: `${ariaLabel} tick label` },
    {
      facetAnchor,
      frameAnchor,
      text: text2 === void 0 ? null : text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      x,
      ...options,
      dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
    },
    function(scale2, data2, ticks2, tickFormat, channels) {
      if (fontVariant === void 0) this.fontVariant = inferFontVariant3(scale2);
      if (text2 === void 0) channels.text = inferTextChannel(scale2, data2, ticks2, tickFormat, anchor);
    }
  );
}
function gridY() {
  const [data, options] = maybeData(...arguments);
  return gridKy("y", anchorY2(options), data, options);
}
function gridFy() {
  const [data, options] = maybeData(...arguments);
  return gridKy("fy", anchorFy(options), data, options);
}
function gridX() {
  const [data, options] = maybeData(...arguments);
  return gridKx("x", anchorX2(options), data, options);
}
function gridFx() {
  const [data, options] = maybeData(...arguments);
  return gridKx("fx", anchorFx(options), data, options);
}
function gridKy(k, anchor, data, {
  y = k === "y" ? void 0 : null,
  x = null,
  x1 = anchor === "left" ? x : null,
  x2 = anchor === "right" ? x : null,
  ariaLabel = `${k}-grid`,
  ariaHidden = true,
  ...options
}) {
  return axisMark(ruleY, k, data, { ariaLabel, ariaHidden }, { y, x1, x2, ...gridDefaults(options) });
}
function gridKx(k, anchor, data, {
  x = k === "x" ? void 0 : null,
  y = null,
  y1 = anchor === "top" ? y : null,
  y2 = anchor === "bottom" ? y : null,
  ariaLabel = `${k}-grid`,
  ariaHidden = true,
  ...options
}) {
  return axisMark(ruleX, k, data, { ariaLabel, ariaHidden }, { x, y1, y2, ...gridDefaults(options) });
}
function gridDefaults({
  color: color2 = "currentColor",
  opacity: opacity2 = 0.1,
  stroke = color2,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  ...options
}) {
  return { stroke, strokeOpacity, strokeWidth, ...options };
}
function labelOptions({
  fill,
  fillOpacity,
  fontFamily,
  fontSize,
  fontStyle,
  fontVariant,
  fontWeight,
  monospace,
  pointerEvents,
  shapeRendering,
  clip = false
}, initializer2) {
  [, fill] = maybeColorChannel(fill);
  [, fillOpacity] = maybeNumberChannel(fillOpacity);
  return {
    facet: "super",
    x: null,
    y: null,
    fill,
    fillOpacity,
    fontFamily,
    fontSize,
    fontStyle,
    fontVariant,
    fontWeight,
    monospace,
    pointerEvents,
    shapeRendering,
    clip,
    initializer: initializer2
  };
}
function axisMark(mark, k, data, properties, options, initialize) {
  let channels;
  function axisInitializer(data2, facets, _channels, scales, dimensions, context) {
    const initializeFacets = data2 == null && (k === "fx" || k === "fy");
    const { [k]: scale2 } = scales;
    if (!scale2) throw new Error(`missing scale: ${k}`);
    const domain = scale2.domain();
    let { interval, ticks: ticks2, tickFormat, tickSpacing = k === "x" ? 80 : 35 } = options;
    if (typeof ticks2 === "string" && hasTemporalDomain(scale2)) interval = ticks2, ticks2 = void 0;
    if (ticks2 === void 0) ticks2 = maybeRangeInterval(interval, scale2.type) ?? inferTickCount(scale2, tickSpacing);
    if (data2 == null) {
      if (isIterable(ticks2)) {
        data2 = arrayify(ticks2);
      } else if (isInterval(ticks2)) {
        data2 = inclusiveRange(ticks2, ...extent(domain));
      } else if (scale2.interval) {
        let interval2 = scale2.interval;
        if (scale2.ticks) {
          const [min2, max2] = extent(domain);
          const n = (max2 - min2) / interval2[intervalDuration];
          interval2 = generalizeTimeInterval(interval2, n / ticks2) ?? interval2;
          data2 = inclusiveRange(interval2, min2, max2);
        } else {
          data2 = domain;
          const n = data2.length;
          interval2 = generalizeTimeInterval(interval2, n / ticks2) ?? interval2;
          if (interval2 !== scale2.interval) data2 = inclusiveRange(interval2, ...extent(data2));
        }
        if (interval2 === scale2.interval) {
          const n = Math.round(data2.length / ticks2);
          if (n > 1) data2 = data2.filter((d, i) => i % n === 0);
        }
      } else if (scale2.ticks) {
        data2 = scale2.ticks(ticks2);
      } else {
        data2 = domain;
      }
      if (!scale2.ticks && data2.length && data2 !== domain) {
        const domainSet = new InternSet(domain);
        data2 = data2.filter((d) => domainSet.has(d));
        if (!data2.length) warn(`Warning: the ${k}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
      }
      if (k === "y" || k === "x") {
        facets = [range2(data2)];
      } else {
        channels[k] = { scale: k, value: identity2 };
      }
    }
    initialize == null ? void 0 : initialize.call(this, scale2, data2, ticks2, tickFormat, channels);
    const initializedChannels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        return [name, { ...channel, value: valueof(data2, channel.value) }];
      })
    );
    if (initializeFacets) facets = context.filterFacets(data2, initializedChannels);
    return { data: data2, facets, channels: initializedChannels };
  }
  const basicInitializer = initializer(options).initializer;
  const m = mark(data, initializer({ ...options, initializer: axisInitializer }, basicInitializer));
  if (data == null) {
    channels = m.channels;
    m.channels = {};
  } else {
    channels = {};
  }
  if (properties !== void 0) Object.assign(m, properties);
  if (m.clip === void 0) m.clip = false;
  return m;
}
function inferTickCount(scale2, tickSpacing) {
  const [min2, max2] = extent(scale2.range());
  return (max2 - min2) / tickSpacing;
}
function inferTextChannel(scale2, data, ticks2, tickFormat, anchor) {
  return { value: inferTickFormat(scale2, data, ticks2, tickFormat, anchor) };
}
function inferTickFormat(scale2, data, ticks2, tickFormat, anchor) {
  return typeof tickFormat === "function" && !(scale2.type === "log" && scale2.tickFormat) ? tickFormat : tickFormat === void 0 && data && isTemporal(data) ? inferTimeFormat(scale2.type, data, anchor) ?? formatDefault : scale2.tickFormat ? scale2.tickFormat(typeof ticks2 === "number" ? ticks2 : null, tickFormat) : typeof tickFormat === "string" && scale2.domain().length > 0 ? (isTemporal(scale2.domain()) ? utcFormat : format)(tickFormat) : tickFormat === void 0 ? formatDefault : constant(tickFormat);
}
function inclusiveRange(interval, min2, max2) {
  return interval.range(min2, interval.offset(interval.floor(max2)));
}
var shapeTickBottom = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(0, l);
  }
};
var shapeTickTop = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(0, -l);
  }
};
var shapeTickLeft = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(-l, 0);
  }
};
var shapeTickRight = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(l, 0);
  }
};
function inferFontVariant3(scale2) {
  return scale2.bandwidth && !scale2.interval ? void 0 : "tabular-nums";
}
function formatAxisLabel(k, scale2, { anchor, label = scale2.label, labelAnchor, labelArrow } = {}) {
  if (label == null || label.inferred && hasTemporalDomain(scale2) && /^(date|time|year)$/i.test(label)) return;
  label = String(label);
  if (labelArrow === "auto") labelArrow = (!scale2.bandwidth || scale2.interval) && !/[↑↓→←]/.test(label);
  if (!labelArrow) return label;
  if (labelArrow === true) {
    const order = inferScaleOrder(scale2);
    if (order)
      labelArrow = /x$/.test(k) || labelAnchor === "center" ? /x$/.test(k) === order < 0 ? "left" : "right" : order < 0 ? "up" : "down";
  }
  switch (labelArrow) {
    case "left":
      return `← ${label}`;
    case "right":
      return `${label} →`;
    case "up":
      return anchor === "right" ? `${label} ↑` : `↑ ${label}`;
    case "down":
      return anchor === "right" ? `${label} ↓` : `↓ ${label}`;
  }
  return label;
}
function maybeLabelArrow(labelArrow = "auto") {
  return isNoneish(labelArrow) ? false : typeof labelArrow === "boolean" ? labelArrow : keyword(labelArrow, "labelArrow", ["auto", "up", "right", "down", "left"]);
}
function hasTemporalDomain(scale2) {
  return isTemporal(scale2.domain());
}

// node_modules/@observablehq/plot/src/legends/swatches.js
function maybeScale(scale2, key) {
  if (key == null) return key;
  const s = scale2(key);
  if (!s) throw new Error(`scale not found: ${key}`);
  return s;
}
function legendSwatches(color2, { opacity: opacity2, ...options } = {}) {
  if (!isOrdinalScale(color2) && !isThresholdScale(color2))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color2.type})`);
  return legendItems(
    color2,
    options,
    (selection, scale2, width, height) => selection.append("svg").attr("width", width).attr("height", height).attr("fill", scale2.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%")
  );
}
function legendSymbols(symbol2, {
  fill = ((_a) => (_a = symbol2.hint) == null ? void 0 : _a.fill)() !== void 0 ? symbol2.hint.fill : "none",
  fillOpacity = 1,
  stroke = ((_b) => (_b = symbol2.hint) == null ? void 0 : _b.stroke)() !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
  strokeOpacity = 1,
  strokeWidth = 1.5,
  r = 4.5,
  ...options
} = {}, scale2) {
  const [vf, cf] = maybeColorChannel(fill);
  const [vs, cs] = maybeColorChannel(stroke);
  const sf = maybeScale(scale2, vf);
  const ss = maybeScale(scale2, vs);
  const size = r * r * Math.PI;
  fillOpacity = maybeNumberChannel(fillOpacity)[1];
  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
  strokeWidth = maybeNumberChannel(strokeWidth)[1];
  return legendItems(
    symbol2,
    options,
    (selection, scale3, width, height) => selection.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", width).attr("height", height).attr("fill", vf === "color" ? (d) => sf.scale(d) : cf).attr("fill-opacity", fillOpacity).attr("stroke", vs === "color" ? (d) => ss.scale(d) : cs).attr("stroke-opacity", strokeOpacity).attr("stroke-width", strokeWidth).append("path").attr("d", (d) => {
      const p = pathRound();
      symbol2.scale(d).draw(p, size);
      return p;
    })
  );
}
function legendItems(scale2, options = {}, swatch) {
  let {
    columns,
    tickFormat,
    fontVariant = inferFontVariant(scale2),
    // TODO label,
    swatchSize = 15,
    swatchWidth = swatchSize,
    swatchHeight = swatchSize,
    marginLeft = 0,
    className,
    style,
    width
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  tickFormat = inferTickFormat(scale2.scale, scale2.domain, void 0, tickFormat);
  const swatches = create("div", context).attr(
    "class",
    `${className}-swatches ${className}-swatches-${columns != null ? "columns" : "wrap"}`
  );
  let extraStyle;
  if (columns != null) {
    extraStyle = `:where(.${className}-swatches-columns .${className}-swatch) {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
:where(.${className}-swatches-columns .${className}-swatch::before) {
  flex-shrink: 0;
}
:where(.${className}-swatches-columns .${className}-swatch-label) {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`;
    swatches.style("columns", columns).selectAll().data(scale2.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale2, swatchWidth, swatchHeight).call(
      (item) => item.append("div").attr("class", `${className}-swatch-label`).attr("title", tickFormat).text(tickFormat)
    );
  } else {
    extraStyle = `:where(.${className}-swatches-wrap) {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
:where(.${className}-swatches-wrap .${className}-swatch) {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`;
    swatches.selectAll().data(scale2.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale2, swatchWidth, swatchHeight).append(function() {
      return this.ownerDocument.createTextNode(tickFormat.apply(this, arguments));
    });
  }
  return swatches.call(
    (div) => div.insert("style", "*").text(
      `:where(.${className}-swatches) {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
:where(.${className}-swatch > svg) {
  margin-right: 0.5em;
  overflow: visible;
}
${extraStyle}`
    )
  ).style("margin-left", marginLeft ? `${+marginLeft}px` : null).style("width", width === void 0 ? null : `${+width}px`).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
}

// node_modules/@observablehq/plot/src/legends.js
var legendRegistry = /* @__PURE__ */ new Map([
  ["symbol", legendSymbols],
  ["color", legendColor],
  ["opacity", legendOpacity]
]);
function legend(options = {}) {
  for (const [key, value] of legendRegistry) {
    const scale2 = options[key];
    if (isScaleOptions(scale2)) {
      const context = createContext(options);
      let hint;
      if (key === "symbol") {
        const { fill, stroke = fill === void 0 && isScaleOptions(options.color) ? "color" : void 0 } = options;
        hint = { fill, stroke };
      }
      return value(
        normalizeScale(key, scale2, hint),
        legendOptions(context, scale2, options),
        (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null
      );
    }
  }
  throw new Error("unknown legend type; no scale found");
}
function exposeLegends(scales, context, defaults22 = {}) {
  return (key, options) => {
    if (!legendRegistry.has(key)) throw new Error(`unknown legend type: ${key}`);
    if (!(key in scales)) return;
    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults22[key], options), (key2) => scales[key2]);
  };
}
function legendOptions({ className, ...context }, { label, ticks: ticks2, tickFormat } = {}, options) {
  return inherit(options, { className, ...context }, { label, ticks: ticks2, tickFormat });
}
function legendColor(color2, { legend: legend2 = true, ...options }) {
  if (legend2 === true) legend2 = color2.type === "ordinal" ? "swatches" : "ramp";
  if (color2.domain === void 0) return;
  switch (`${legend2}`.toLowerCase()) {
    case "swatches":
      return legendSwatches(color2, options);
    case "ramp":
      return legendRamp(color2, options);
    default:
      throw new Error(`unknown legend type: ${legend2}`);
  }
}
function legendOpacity({ type, interpolate, ...scale2 }, { legend: legend2 = true, color: color2 = rgb(0, 0, 0), ...options }) {
  if (!interpolate) throw new Error(`${type} opacity scales are not supported`);
  if (legend2 === true) legend2 = "ramp";
  if (`${legend2}`.toLowerCase() !== "ramp") throw new Error(`${legend2} opacity legends are not supported`);
  return legendColor({ type, ...scale2, interpolate: interpolateOpacity(color2) }, { legend: legend2, ...options });
}
function interpolateOpacity(color2) {
  const { r, g, b } = rgb(color2) || rgb(0, 0, 0);
  return (t) => `rgba(${r},${g},${b},${t})`;
}
function createLegends(scales, context, options) {
  const legends = [];
  for (const [key, value] of legendRegistry) {
    const o = options[key];
    if ((o == null ? void 0 : o.legend) && key in scales) {
      const legend2 = value(scales[key], legendOptions(context, scales[key], o), (key2) => scales[key2]);
      if (legend2 != null) legends.push(legend2);
    }
  }
  return legends;
}

// node_modules/@observablehq/plot/src/transforms/identity.js
function maybeIdentityX(options = {}, k = "x") {
  return hasX(options) ? options : { ...options, [k]: identity2 };
}
function maybeIdentityY(options = {}, k = "y") {
  return hasY(options) ? options : { ...options, [k]: identity2 };
}

// node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js
function exclusiveFacets(data, facets) {
  if (facets.length === 1) return { data, facets };
  const n = lengthof(data);
  const O = new Uint8Array(n);
  let overlaps = 0;
  for (const facet of facets) {
    for (const i of facet) {
      if (O[i]) ++overlaps;
      O[i] = 1;
    }
  }
  if (overlaps === 0) return { data, facets };
  data = slice(data);
  const R = data[reindex] = new Uint32Array(n + overlaps);
  facets = facets.map((facet) => slice(facet, Uint32Array));
  let j = n;
  O.fill(0);
  for (const facet of facets) {
    for (let k = 0, m = facet.length; k < m; ++k) {
      const i = facet[k];
      if (O[i]) facet[k] = j, data[j] = data[i], R[j] = i, ++j;
      else R[i] = i;
      O[i] = 1;
    }
  }
  return { data, facets };
}

// node_modules/@observablehq/plot/src/transforms/stack.js
function stackX(stackOptions = {}, options = {}) {
  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
  const { y1, y = y1, x, ...rest } = options;
  const [transform, Y, x1, x2] = stack(y, x, "y", "x", stackOptions, rest);
  return { ...transform, y1, y: Y, x1, x2, x: mid(x1, x2) };
}
function stackX1(stackOptions = {}, options = {}) {
  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
  const { y1, y = y1, x } = options;
  const [transform, Y, X] = stack(y, x, "y", "x", stackOptions, options);
  return { ...transform, y1, y: Y, x: X };
}
function stackX2(stackOptions = {}, options = {}) {
  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
  const { y1, y = y1, x } = options;
  const [transform, Y, , X] = stack(y, x, "y", "x", stackOptions, options);
  return { ...transform, y1, y: Y, x: X };
}
function stackY(stackOptions = {}, options = {}) {
  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
  const { x1, x = x1, y, ...rest } = options;
  const [transform, X, y1, y2] = stack(x, y, "x", "y", stackOptions, rest);
  return { ...transform, x1, x: X, y1, y2, y: mid(y1, y2) };
}
function stackY1(stackOptions = {}, options = {}) {
  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
  const { x1, x = x1, y } = options;
  const [transform, X, Y] = stack(x, y, "x", "y", stackOptions, options);
  return { ...transform, x1, x: X, y: Y };
}
function stackY2(stackOptions = {}, options = {}) {
  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
  const { x1, x = x1, y } = options;
  const [transform, X, , Y] = stack(x, y, "x", "y", stackOptions, options);
  return { ...transform, x1, x: X, y: Y };
}
function maybeStackX({ x, x1, x2, ...options } = {}) {
  options = withTip(options, "y");
  if (x1 === void 0 && x2 === void 0) return stackX({ x, ...options });
  [x1, x2] = maybeZero(x, x1, x2);
  return { ...options, x1, x2 };
}
function maybeStackY({ y, y1, y2, ...options } = {}) {
  options = withTip(options, "x");
  if (y1 === void 0 && y2 === void 0) return stackY({ y, ...options });
  [y1, y2] = maybeZero(y, y1, y2);
  return { ...options, y1, y2 };
}
function mergeOptions(options) {
  const { offset: offset2, order, reverse: reverse3, ...rest } = options;
  return [{ offset: offset2, order, reverse: reverse3 }, rest];
}
var lengthy = { length: true };
function stack(x, y = one, kx, ky, { offset: offset2, order, reverse: reverse3 }, options) {
  if (y === null) throw new Error(`stack requires ${ky}`);
  const z = maybeZ(options);
  const [X, setX] = maybeColumn(x);
  const [Y1, setY1] = column(y);
  const [Y2, setY2] = column(y);
  Y1.hint = Y2.hint = lengthy;
  offset2 = maybeOffset(offset2);
  order = maybeOrder2(order, offset2, ky);
  return [
    basic(options, (data, facets, plotOptions) => {
      ({ data, facets } = exclusiveFacets(data, facets));
      const X2 = x == null ? void 0 : setX(maybeApplyInterval(valueof(data, x), plotOptions == null ? void 0 : plotOptions[kx]));
      const Y = valueof(data, y, Float64Array);
      const Z = valueof(data, z);
      const compare = order && order(data, X2, Y, Z);
      const n = lengthof(data);
      const Y12 = setY1(new Float64Array(n));
      const Y22 = setY2(new Float64Array(n));
      const facetstacks = [];
      for (const facet of facets) {
        const stacks = X2 ? Array.from(group(facet, (i) => X2[i]).values()) : [facet];
        if (compare) for (const stack2 of stacks) stack2.sort(compare);
        for (const stack2 of stacks) {
          let yn = 0;
          let yp = 0;
          if (reverse3) stack2.reverse();
          for (const i of stack2) {
            const y2 = Y[i];
            if (y2 < 0) yn = Y22[i] = (Y12[i] = yn) + y2;
            else if (y2 > 0) yp = Y22[i] = (Y12[i] = yp) + y2;
            else Y22[i] = Y12[i] = yp;
          }
        }
        facetstacks.push(stacks);
      }
      if (offset2) offset2(facetstacks, Y12, Y22, Z);
      return { data, facets };
    }),
    X,
    Y1,
    Y2
  ];
}
function maybeOffset(offset2) {
  if (offset2 == null) return;
  if (typeof offset2 === "function") return offset2;
  switch (`${offset2}`.toLowerCase()) {
    case "expand":
    case "normalize":
      return offsetExpand;
    case "center":
    case "silhouette":
      return offsetCenter;
    case "wiggle":
      return offsetWiggle;
  }
  throw new Error(`unknown offset: ${offset2}`);
}
function extent2(stack2, Y2) {
  let min2 = 0, max2 = 0;
  for (const i of stack2) {
    const y = Y2[i];
    if (y < min2) min2 = y;
    if (y > max2) max2 = y;
  }
  return [min2, max2];
}
function offsetExpand(facetstacks, Y1, Y2) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn, yp] = extent2(stack2, Y2);
      for (const i of stack2) {
        const m = 1 / (yp - yn || 1);
        Y1[i] = m * (Y1[i] - yn);
        Y2[i] = m * (Y2[i] - yn);
      }
    }
  }
}
function offsetCenter(facetstacks, Y1, Y2) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn, yp] = extent2(stack2, Y2);
      for (const i of stack2) {
        const m = (yp + yn) / 2;
        Y1[i] -= m;
        Y2[i] -= m;
      }
    }
    offsetZero(stacks, Y1, Y2);
  }
  offsetCenterFacets(facetstacks, Y1, Y2);
}
function offsetWiggle(facetstacks, Y1, Y2, Z) {
  for (const stacks of facetstacks) {
    const prev = new InternMap();
    let y = 0;
    for (const stack2 of stacks) {
      let j = -1;
      const Fi = stack2.map((i) => Math.abs(Y2[i] - Y1[i]));
      const Df = stack2.map((i) => {
        j = Z ? Z[i] : ++j;
        const value = Y2[i] - Y1[i];
        const diff = prev.has(j) ? value - prev.get(j) : 0;
        prev.set(j, value);
        return diff;
      });
      const Cf1 = [0, ...cumsum(Df)];
      for (const i of stack2) {
        Y1[i] += y;
        Y2[i] += y;
      }
      const s1 = sum(Fi);
      if (s1) y -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;
    }
    offsetZero(stacks, Y1, Y2);
  }
  offsetCenterFacets(facetstacks, Y1, Y2);
}
function offsetZero(stacks, Y1, Y2) {
  const m = min(stacks, (stack2) => min(stack2, (i) => Y1[i]));
  for (const stack2 of stacks) {
    for (const i of stack2) {
      Y1[i] -= m;
      Y2[i] -= m;
    }
  }
}
function offsetCenterFacets(facetstacks, Y1, Y2) {
  const n = facetstacks.length;
  if (n === 1) return;
  const facets = facetstacks.map((stacks) => stacks.flat());
  const m = facets.map((I) => (min(I, (i) => Y1[i]) + max(I, (i) => Y2[i])) / 2);
  const m0 = min(m);
  for (let j = 0; j < n; j++) {
    const p = m0 - m[j];
    for (const i of facets[j]) {
      Y1[i] += p;
      Y2[i] += p;
    }
  }
}
function maybeOrder2(order, offset2, ky) {
  if (order === void 0 && offset2 === offsetWiggle) return orderInsideOut(ascendingDefined);
  if (order == null) return;
  if (typeof order === "string") {
    const negate = order.startsWith("-");
    const compare = negate ? descendingDefined : ascendingDefined;
    switch ((negate ? order.slice(1) : order).toLowerCase()) {
      case "value":
      case ky:
        return orderY(compare);
      case "z":
        return orderZ(compare);
      case "sum":
        return orderSum(compare);
      case "appearance":
        return orderAppearance(compare);
      case "inside-out":
        return orderInsideOut(compare);
    }
    return orderAccessor(field(order));
  }
  if (typeof order === "function") return (order.length === 1 ? orderAccessor : orderComparator)(order);
  if (isArray(order)) return orderGiven(order);
  throw new Error(`invalid order: ${order}`);
}
function orderY(compare) {
  return (data, X, Y) => (i, j) => compare(Y[i], Y[j]);
}
function orderZ(compare) {
  return (data, X, Y, Z) => (i, j) => compare(Z[i], Z[j]);
}
function orderSum(compare) {
  return orderZDomain(
    compare,
    (data, X, Y, Z) => groupSort(
      range2(data),
      (I) => sum(I, (i) => Y[i]),
      (i) => Z[i]
    )
  );
}
function orderAppearance(compare) {
  return orderZDomain(
    compare,
    (data, X, Y, Z) => groupSort(
      range2(data),
      (I) => X[greatest(I, (i) => Y[i])],
      (i) => Z[i]
    )
  );
}
function orderInsideOut(compare) {
  return orderZDomain(compare, (data, X, Y, Z) => {
    const I = range2(data);
    const K = groupSort(
      I,
      (I2) => X[greatest(I2, (i) => Y[i])],
      (i) => Z[i]
    );
    const sums = rollup(
      I,
      (I2) => sum(I2, (i) => Y[i]),
      (i) => Z[i]
    );
    const Kp = [], Kn = [];
    let s = 0;
    for (const k of K) {
      if (s < 0) {
        s += sums.get(k);
        Kp.push(k);
      } else {
        s -= sums.get(k);
        Kn.push(k);
      }
    }
    return Kn.reverse().concat(Kp);
  });
}
function orderAccessor(f) {
  return (data) => {
    const O = valueof(data, f);
    return (i, j) => ascendingDefined(O[i], O[j]);
  };
}
function orderComparator(f) {
  return (data) => {
    return isArray(data) ? (i, j) => f(data[i], data[j]) : (i, j) => f(data.get(i), data.get(j));
  };
}
function orderGiven(domain) {
  return orderZDomain(ascendingDefined, () => domain);
}
function orderZDomain(compare, domain) {
  return (data, X, Y, Z) => {
    if (!Z) throw new Error("missing channel: z");
    const map3 = new InternMap(domain(data, X, Y, Z).map((d, i) => [d, i]));
    return (i, j) => compare(map3.get(Z[i]), map3.get(Z[j]));
  };
}

// node_modules/@observablehq/plot/src/marks/rect.js
var defaults4 = {
  ariaLabel: "rect"
};
var Rect = class extends Mark {
  constructor(data, options = {}) {
    const { x1, y1, x2, y2 } = options;
    super(
      data,
      {
        x1: { value: x1, scale: "x", type: x1 != null && x2 == null ? "band" : void 0, optional: true },
        y1: { value: y1, scale: "y", type: y1 != null && y2 == null ? "band" : void 0, optional: true },
        x2: { value: x2, scale: "x", optional: true },
        y2: { value: y2, scale: "y", optional: true }
      },
      options,
      defaults4
    );
    rectInsets(this, options);
    rectRadii(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    let { x1: X1, y1: Y1, x2: X2, y2: Y2 } = channels;
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const { projection: projection2 } = context;
    const { insetTop, insetRight, insetBottom, insetLeft } = this;
    const { rx, ry, rx1y1, rx1y2, rx2y1, rx2y2 } = this;
    if ((X1 || X2) && !projection2 && isCollapsed(x)) X1 = X2 = null;
    if ((Y1 || Y2) && !projection2 && isCollapsed(y)) Y1 = Y2 = null;
    const bx = (x == null ? void 0 : x.bandwidth) ? x.bandwidth() : 0;
    const by = (y == null ? void 0 : y.bandwidth) ? y.bandwidth() : 0;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, 0, 0).call(
      (g) => g.selectAll().data(index).enter().call(
        rx1y1 || rx1y2 || rx2y1 || rx2y2 ? (g2) => g2.append("path").call(applyDirectStyles, this).call(
          applyRoundedRect,
          X1 && X2 ? (i) => X1[i] + (X2[i] < X1[i] ? -insetRight : insetLeft) : X1 ? (i) => X1[i] + insetLeft : marginLeft + insetLeft,
          Y1 && Y2 ? (i) => Y1[i] + (Y2[i] < Y1[i] ? -insetBottom : insetTop) : Y1 ? (i) => Y1[i] + insetTop : marginTop + insetTop,
          X1 && X2 ? (i) => X2[i] - (X2[i] < X1[i] ? -insetLeft : insetRight) : X1 ? (i) => X1[i] + bx - insetRight : width - marginRight - insetRight,
          Y1 && Y2 ? (i) => Y2[i] - (Y2[i] < Y1[i] ? -insetTop : insetBottom) : Y1 ? (i) => Y1[i] + by - insetBottom : height - marginBottom - insetBottom,
          this
        ).call(applyChannelStyles, this, channels) : (g2) => g2.append("rect").call(applyDirectStyles, this).attr(
          "x",
          X1 ? X2 ? (i) => Math.min(X1[i], X2[i]) + insetLeft : (i) => X1[i] + insetLeft : marginLeft + insetLeft
        ).attr(
          "y",
          Y1 ? Y2 ? (i) => Math.min(Y1[i], Y2[i]) + insetTop : (i) => Y1[i] + insetTop : marginTop + insetTop
        ).attr(
          "width",
          X1 ? X2 ? (i) => Math.max(0, Math.abs(X2[i] - X1[i]) + bx - insetLeft - insetRight) : bx - insetLeft - insetRight : width - marginRight - marginLeft - insetRight - insetLeft
        ).attr(
          "height",
          Y1 ? Y2 ? (i) => Math.max(0, Math.abs(Y1[i] - Y2[i]) + by - insetTop - insetBottom) : by - insetTop - insetBottom : height - marginTop - marginBottom - insetTop - insetBottom
        ).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
      )
    ).node();
  }
};
function rectInsets(mark, { inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset } = {}) {
  mark.insetTop = number(insetTop);
  mark.insetRight = number(insetRight);
  mark.insetBottom = number(insetBottom);
  mark.insetLeft = number(insetLeft);
}
function rectRadii(mark, {
  r,
  rx,
  // for elliptic corners
  ry,
  // for elliptic corners
  rx1 = r,
  ry1 = r,
  rx2 = r,
  ry2 = r,
  rx1y1 = rx1 !== void 0 ? +rx1 : ry1 !== void 0 ? +ry1 : 0,
  rx1y2 = rx1 !== void 0 ? +rx1 : ry2 !== void 0 ? +ry2 : 0,
  rx2y1 = rx2 !== void 0 ? +rx2 : ry1 !== void 0 ? +ry1 : 0,
  rx2y2 = rx2 !== void 0 ? +rx2 : ry2 !== void 0 ? +ry2 : 0
} = {}) {
  if (rx1y1 || rx1y2 || rx2y1 || rx2y2) {
    mark.rx1y1 = rx1y1;
    mark.rx1y2 = rx1y2;
    mark.rx2y1 = rx2y1;
    mark.rx2y2 = rx2y2;
  } else {
    mark.rx = impliedString(rx, "auto");
    mark.ry = impliedString(ry, "auto");
  }
}
function applyRoundedRect(selection, X1, Y1, X2, Y2, mark) {
  const { rx1y1: r11, rx1y2: r12, rx2y1: r21, rx2y2: r22 } = mark;
  if (typeof X1 !== "function") X1 = constant(X1);
  if (typeof Y1 !== "function") Y1 = constant(Y1);
  if (typeof X2 !== "function") X2 = constant(X2);
  if (typeof Y2 !== "function") Y2 = constant(Y2);
  const rx = Math.max(Math.abs(r11 + r21), Math.abs(r12 + r22));
  const ry = Math.max(Math.abs(r11 + r12), Math.abs(r21 + r22));
  selection.attr("d", (i) => {
    const x1 = X1(i);
    const y1 = Y1(i);
    const x2 = X2(i);
    const y2 = Y2(i);
    const ix = x1 > x2;
    const iy = y1 > y2;
    const l = ix ? x2 : x1;
    const r = ix ? x1 : x2;
    const t = iy ? y2 : y1;
    const b = iy ? y1 : y2;
    const k = Math.min(1, (r - l) / rx, (b - t) / ry);
    const tl = k * (ix ? iy ? r22 : r21 : iy ? r12 : r11);
    const tr = k * (ix ? iy ? r12 : r11 : iy ? r22 : r21);
    const br = k * (ix ? iy ? r11 : r12 : iy ? r21 : r22);
    const bl = k * (ix ? iy ? r21 : r22 : iy ? r11 : r12);
    return `M${l},${t + biasY(tl, bl)}A${tl},${tl} 0 0 ${tl < 0 ? 0 : 1} ${l + biasX(tl, bl)},${t}H${r - biasX(tr, br)}A${tr},${tr} 0 0 ${tr < 0 ? 0 : 1} ${r},${t + biasY(tr, br)}V${b - biasY(br, tr)}A${br},${br} 0 0 ${br < 0 ? 0 : 1} ${r - biasX(br, tr)},${b}H${l + biasX(bl, tl)}A${bl},${bl} 0 0 ${bl < 0 ? 0 : 1} ${l},${b - biasY(bl, tl)}Z`;
  });
}
function biasX(r1, r2) {
  return r2 < 0 ? r1 : Math.abs(r1);
}
function biasY(r1, r2) {
  return r2 < 0 ? Math.abs(r1) : r1;
}
function rect(data, options) {
  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));
}
function rectX(data, options = {}) {
  if (!hasXY(options)) options = { ...options, y: indexOf, x2: identity2, interval: 1 };
  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));
}
function rectY(data, options = {}) {
  if (!hasXY(options)) options = { ...options, x: indexOf, y2: identity2, interval: 1 };
  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));
}

// node_modules/@observablehq/plot/src/marks/frame.js
var defaults5 = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor",
  clip: false
};
var lineDefaults = {
  ariaLabel: "frame",
  fill: null,
  stroke: "currentColor",
  strokeLinecap: "square",
  clip: false
};
var Frame = class extends Mark {
  constructor(options = {}) {
    const { anchor = null } = options;
    super(singleton, void 0, options, anchor == null ? defaults5 : lineDefaults);
    this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
    rectInsets(this, options);
    if (!anchor) rectRadii(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const { anchor, insetTop, insetRight, insetBottom, insetLeft } = this;
    const { rx, ry, rx1y1, rx1y2, rx2y1, rx2y2 } = this;
    const x1 = marginLeft + insetLeft;
    const x2 = width - marginRight - insetRight;
    const y1 = marginTop + insetTop;
    const y2 = height - marginBottom - insetBottom;
    return create(anchor ? "svg:line" : rx1y1 || rx1y2 || rx2y1 || rx2y2 ? "svg:path" : "svg:rect", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyChannelStyles, this, channels).call(applyTransform, this, {}).call(
      anchor === "left" ? (line2) => line2.attr("x1", x1).attr("x2", x1).attr("y1", y1).attr("y2", y2) : anchor === "right" ? (line2) => line2.attr("x1", x2).attr("x2", x2).attr("y1", y1).attr("y2", y2) : anchor === "top" ? (line2) => line2.attr("x1", x1).attr("x2", x2).attr("y1", y1).attr("y2", y1) : anchor === "bottom" ? (line2) => line2.attr("x1", x1).attr("x2", x2).attr("y1", y2).attr("y2", y2) : rx1y1 || rx1y2 || rx2y1 || rx2y2 ? (path) => path.call(applyRoundedRect, x1, y1, x2, y2, this) : (rect2) => rect2.attr("x", x1).attr("y", y1).attr("width", x2 - x1).attr("height", y2 - y1).attr("rx", rx).attr("ry", ry)
    ).node();
  }
};
function frame(options) {
  return new Frame(options);
}

// node_modules/@observablehq/plot/src/marks/tip.js
var defaults6 = {
  ariaLabel: "tip",
  fill: "var(--plot-background)",
  stroke: "currentColor"
};
var ignoreChannels = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
var Tip = class extends Mark {
  constructor(data, options = {}) {
    if (options.tip) options = { ...options, tip: false };
    if (options.title === void 0 && isIterable(data) && isTextual(data)) options = { ...options, title: identity2 };
    const {
      x,
      y,
      x1,
      x2,
      y1,
      y2,
      anchor,
      preferredAnchor = "bottom",
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      lineHeight = 1,
      lineWidth = 20,
      frameAnchor,
      format: format3,
      textAnchor = "start",
      textOverflow,
      textPadding = 8,
      title,
      pointerSize = 12,
      pathFilter = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
    } = options;
    super(
      data,
      {
        x: { value: x1 != null && x2 != null ? null : x, scale: "x", optional: true },
        // ignore midpoint
        y: { value: y1 != null && y2 != null ? null : y, scale: "y", optional: true },
        // ignore midpoint
        x1: { value: x1, scale: "x", optional: x2 == null },
        y1: { value: y1, scale: "y", optional: y2 == null },
        x2: { value: x2, scale: "x", optional: x1 == null },
        y2: { value: y2, scale: "y", optional: y1 == null },
        title: { value: title, optional: true }
        // filter: defined
      },
      options,
      defaults6
    );
    this.anchor = maybeAnchor(anchor, "anchor");
    this.preferredAnchor = maybeAnchor(preferredAnchor, "preferredAnchor");
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    this.textAnchor = impliedString(textAnchor, "middle");
    this.textPadding = +textPadding;
    this.pointerSize = +pointerSize;
    this.pathFilter = string(pathFilter);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = number(fontSize);
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    for (const key in defaults6) if (key in this.channels) this[key] = defaults6[key];
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
    this.format = typeof format3 === "string" || typeof format3 === "function" ? { title: format3 } : { ...format3 };
  }
  render(index, scales, values2, dimensions, context) {
    const mark = this;
    const { x, y, fx, fy } = scales;
    const { ownerSVGElement: svg, document } = context;
    const { anchor, monospace, lineHeight, lineWidth } = this;
    const { textPadding: r, pointerSize: m, pathFilter } = this;
    const { marginTop, marginLeft } = dimensions;
    const { x1: X1, y1: Y1, x2: X2, y2: Y2, x: X = X1 ?? X2, y: Y = Y1 ?? Y2 } = values2;
    const ox2 = fx ? fx(index.fx) - marginLeft : 0;
    const oy2 = fy ? fy(index.fy) - marginTop : 0;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const px = anchorX(values2, cx);
    const py = anchorY(values2, cy);
    const widthof = monospace ? monospaceWidth : defaultWidth;
    const ee = widthof(ellipsis);
    let sources, format3;
    if ("title" in values2) {
      sources = getSourceChannels.call(this, { title: values2.channels.title }, scales);
      format3 = formatTitle;
    } else {
      sources = getSourceChannels.call(this, values2.channels, scales);
      format3 = formatChannels;
    }
    const g = create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this).call(applyTransform, this, { x: X && x, y: Y && y }).call(
      (g2) => g2.selectAll().data(index).enter().append("g").attr("transform", (i) => `translate(${Math.round(px(i))},${Math.round(py(i))})`).call(applyDirectStyles, this).call((g3) => g3.append("path").attr("filter", pathFilter)).call(
        (g3) => g3.append("text").each(function(i) {
          const that = select_default(this);
          this.setAttribute("fill", "currentColor");
          this.setAttribute("fill-opacity", 1);
          this.setAttribute("stroke", "none");
          const lines = format3.call(mark, i, index, sources, scales, values2);
          if (typeof lines === "string") {
            for (const line2 of mark.splitLines(lines)) {
              renderLine(that, { value: mark.clipLine(line2) });
            }
          } else {
            const labels = /* @__PURE__ */ new Set();
            for (const line2 of lines) {
              const { label = "" } = line2;
              if (label && labels.has(label)) continue;
              else labels.add(label);
              renderLine(that, line2);
            }
          }
        })
      )
    );
    function renderLine(selection, { label, value, color: color2, opacity: opacity2 }) {
      label ?? (label = ""), value ?? (value = "");
      const swatch = color2 != null || opacity2 != null;
      let title;
      let w = lineWidth * 100;
      const [j] = cut(label, w, widthof, ee);
      if (j >= 0) {
        label = label.slice(0, j).trimEnd() + ellipsis;
        title = value.trim();
        value = "";
      } else {
        if (label || !value && !swatch) value = " " + value;
        const [k] = cut(value, w - widthof(label), widthof, ee);
        if (k >= 0) {
          title = value.trim();
          value = value.slice(0, k).trimEnd() + ellipsis;
        }
      }
      const line2 = selection.append("tspan").attr("x", 0).attr("dy", `${lineHeight}em`).text("​");
      if (label) line2.append("tspan").attr("font-weight", "bold").text(label);
      if (value) line2.append(() => document.createTextNode(value));
      if (swatch) line2.append("tspan").text(" ■").attr("fill", color2).attr("fill-opacity", opacity2).style("user-select", "none");
      if (title) line2.append("title").text(title);
    }
    function postrender() {
      const { width, height } = dimensions.facet ?? dimensions;
      g.selectChildren().each(function(i) {
        let { x: tx, width: w, height: h } = this.getBBox();
        w = Math.round(w), h = Math.round(h);
        let a = anchor;
        if (a === void 0) {
          const x2 = px(i) + ox2;
          const y2 = py(i) + oy2;
          const fitLeft = x2 + w + m + r * 2 < width;
          const fitRight = x2 - w - m - r * 2 > 0;
          const fitTop = y2 + h + m + r * 2 < height;
          const fitBottom = y2 - h - m - r * 2 > 0;
          a = fitLeft && fitRight ? fitTop && fitBottom ? mark.preferredAnchor : fitBottom ? "bottom" : "top" : fitTop && fitBottom ? fitLeft ? "left" : "right" : (fitLeft || fitRight) && (fitTop || fitBottom) ? `${fitBottom ? "bottom" : "top"}-${fitLeft ? "left" : "right"}` : mark.preferredAnchor;
        }
        const path = this.firstChild;
        const text2 = this.lastChild;
        path.setAttribute("d", getPath(a, m, r, w, h));
        if (tx) for (const t of text2.childNodes) t.setAttribute("x", -tx);
        text2.setAttribute("y", `${+getLineOffset(a, text2.childNodes.length, lineHeight).toFixed(6)}em`);
        text2.setAttribute("transform", `translate(${getTextTranslate(a, m, r, w, h)})`);
      });
      g.attr("visibility", null);
    }
    if (index.length) {
      g.attr("visibility", "hidden");
      if (svg.isConnected) Promise.resolve().then(postrender);
      else if (typeof requestAnimationFrame !== "undefined") requestAnimationFrame(postrender);
    }
    return g.node();
  }
};
function tip(data, { x, y, ...options } = {}) {
  if (options.frameAnchor === void 0) [x, y] = maybeTuple(x, y);
  return new Tip(data, { ...options, x, y });
}
function getLineOffset(anchor, length2, lineHeight) {
  return /^top(?:-|$)/.test(anchor) ? 0.94 - lineHeight : /^bottom(?:-|$)/ ? -0.29 - length2 * lineHeight : length2 / 2 * lineHeight;
}
function getTextTranslate(anchor, m, r, width, height) {
  switch (anchor) {
    case "middle":
      return [-width / 2, height / 2];
    case "top-left":
      return [r, m + r];
    case "top":
      return [-width / 2, m / 2 + r];
    case "top-right":
      return [-width - r, m + r];
    case "right":
      return [-m / 2 - width - r, height / 2];
    case "bottom-left":
      return [r, -m - r];
    case "bottom":
      return [-width / 2, -m / 2 - r];
    case "bottom-right":
      return [-width - r, -m - r];
    case "left":
      return [r + m / 2, height / 2];
  }
}
function getPath(anchor, m, r, width, height) {
  const w = width + r * 2;
  const h = height + r * 2;
  switch (anchor) {
    case "middle":
      return `M${-w / 2},${-h / 2}h${w}v${h}h${-w}z`;
    case "top-left":
      return `M0,0l${m},${m}h${w - m}v${h}h${-w}z`;
    case "top":
      return `M0,0l${m / 2},${m / 2}h${(w - m) / 2}v${h}h${-w}v${-h}h${(w - m) / 2}z`;
    case "top-right":
      return `M0,0l${-m},${m}h${m - w}v${h}h${w}z`;
    case "right":
      return `M0,0l${-m / 2},${-m / 2}v${m / 2 - h / 2}h${-w}v${h}h${w}v${m / 2 - h / 2}z`;
    case "bottom-left":
      return `M0,0l${m},${-m}h${w - m}v${-h}h${-w}z`;
    case "bottom":
      return `M0,0l${m / 2},${-m / 2}h${(w - m) / 2}v${-h}h${-w}v${h}h${(w - m) / 2}z`;
    case "bottom-right":
      return `M0,0l${-m},${-m}h${m - w}v${-h}h${w}z`;
    case "left":
      return `M0,0l${m / 2},${-m / 2}v${m / 2 - h / 2}h${w}v${h}h${-w}v${m / 2 - h / 2}z`;
  }
}
function getSourceChannels(channels, scales) {
  var _a, _b;
  const sources = {};
  let format3 = this.format;
  format3 = maybeExpandPairedFormat(format3, channels, "x");
  format3 = maybeExpandPairedFormat(format3, channels, "y");
  this.format = format3;
  for (const key in format3) {
    const value = format3[key];
    if (value === null || value === false) {
      continue;
    } else if (key === "fx" || key === "fy") {
      sources[key] = true;
    } else {
      const source = getSource(channels, key);
      if (source) sources[key] = source;
    }
  }
  for (const key in channels) {
    if (key in sources || key in format3 || ignoreChannels.has(key)) continue;
    if ((key === "x" || key === "y") && channels.geometry) continue;
    const source = getSource(channels, key);
    if (source) {
      if (source.scale == null && source.defaultScale === "color") continue;
      sources[key] = source;
    }
  }
  if (this.facet) {
    if (scales.fx && !("fx" in format3)) sources.fx = true;
    if (scales.fy && !("fy" in format3)) sources.fy = true;
  }
  for (const key in sources) {
    const format4 = this.format[key];
    if (typeof format4 === "string") {
      const value = ((_a = sources[key]) == null ? void 0 : _a.value) ?? ((_b = scales[key]) == null ? void 0 : _b.domain()) ?? [];
      this.format[key] = (isTemporal(value) ? utcFormat : format)(format4);
    } else if (format4 === void 0 || format4 === true) {
      const scale2 = scales[key];
      this.format[key] = (scale2 == null ? void 0 : scale2.bandwidth) ? inferTickFormat(scale2, scale2.domain()) : formatDefault;
    }
  }
  return sources;
}
function maybeExpandPairedFormat(format3, channels, key) {
  if (!(key in format3)) return format3;
  const key1 = `${key}1`;
  const key2 = `${key}2`;
  if ((key1 in format3 || !(key1 in channels)) && (key2 in format3 || !(key2 in channels))) return format3;
  const entries = Object.entries(format3);
  const value = format3[key];
  entries.splice(entries.findIndex(([name]) => name === key) + 1, 0, [key1, value], [key2, value]);
  return Object.fromEntries(entries);
}
function formatTitle(i, index, { title }) {
  return this.format.title(title.value[i], i);
}
function* formatChannels(i, index, channels, scales, values2) {
  for (const key in channels) {
    if (key === "fx" || key === "fy") {
      yield {
        label: formatLabel(scales, channels, key),
        value: this.format[key](index[key], i)
      };
      continue;
    }
    if (key === "x1" && "x2" in channels) continue;
    if (key === "y1" && "y2" in channels) continue;
    const channel = channels[key];
    if (key === "x2" && "x1" in channels) {
      yield {
        label: formatPairLabel(scales, channels, "x"),
        value: formatPair(this.format.x2, channels.x1, channel, i)
      };
    } else if (key === "y2" && "y1" in channels) {
      yield {
        label: formatPairLabel(scales, channels, "y"),
        value: formatPair(this.format.y2, channels.y1, channel, i)
      };
    } else {
      const value = channel.value[i];
      const scale2 = channel.scale;
      if (!defined(value) && scale2 == null) continue;
      yield {
        label: formatLabel(scales, channels, key),
        value: this.format[key](value, i),
        color: scale2 === "color" ? values2[key][i] : null,
        opacity: scale2 === "opacity" ? values2[key][i] : null
      };
    }
  }
}
function formatPair(formatValue, c1, c2, i) {
  var _a;
  return ((_a = c2.hint) == null ? void 0 : _a.length) ? `${formatValue(c2.value[i] - c1.value[i], i)}` : `${formatValue(c1.value[i], i)}–${formatValue(c2.value[i], i)}`;
}
function formatPairLabel(scales, channels, key) {
  const l1 = formatLabel(scales, channels, `${key}1`, key);
  const l2 = formatLabel(scales, channels, `${key}2`, key);
  return l1 === l2 ? l1 : `${l1}–${l2}`;
}
function formatLabel(scales, channels, key, defaultLabel = key) {
  const channel = channels[key];
  const scale2 = scales[(channel == null ? void 0 : channel.scale) ?? key];
  return String((scale2 == null ? void 0 : scale2.label) ?? (channel == null ? void 0 : channel.label) ?? defaultLabel);
}

// node_modules/@observablehq/plot/src/plot.js
function plot(options = {}) {
  var _a;
  const { facet, style, title, subtitle, caption, ariaLabel, ariaDescription } = options;
  const className = maybeClassName(options.className);
  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);
  marks2.push(...inferTips(marks2));
  const topFacetState = maybeTopFacet(facet, options);
  const facetStateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState) facetStateByMark.set(mark, facetState);
  }
  const channelsByScale = /* @__PURE__ */ new Map();
  if (topFacetState) addScaleChannels(channelsByScale, [topFacetState], options);
  addScaleChannels(channelsByScale, facetStateByMark, options);
  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));
  for (const mark of axes) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState) facetStateByMark.set(mark, facetState);
  }
  marks2.unshift(...axes);
  let facets = createFacets(channelsByScale, options);
  if (facets !== void 0) {
    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
    for (const mark of marks2) {
      if (mark.facet === null || mark.facet === "super") continue;
      const facetState = facetStateByMark.get(mark);
      if (facetState === void 0) continue;
      facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
    }
    const nonEmpty = /* @__PURE__ */ new Set();
    for (const { facetsIndex } of facetStateByMark.values()) {
      facetsIndex == null ? void 0 : facetsIndex.forEach((index, i) => {
        if ((index == null ? void 0 : index.length) > 0) {
          nonEmpty.add(i);
        }
      });
    }
    facets.forEach(
      0 < nonEmpty.size && nonEmpty.size < facets.length ? (f, i) => f.empty = !nonEmpty.has(i) : (f) => f.empty = false
    );
    for (const mark of marks2) {
      if (mark.facet === "exclude") {
        const facetState = facetStateByMark.get(mark);
        if (facetState !== void 0) facetState.facetsIndex = facetExclude(facetState.facetsIndex);
      }
    }
  }
  for (const key of registry.keys()) {
    if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
      channelsByScale.set(key, []);
    }
  }
  const stateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    if (stateByMark.has(mark)) throw new Error("duplicate mark; each mark must be unique");
    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};
    const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels, options);
    applyScaleTransforms(channels, options);
    stateByMark.set(mark, { data, facets: facets2, channels });
  }
  const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark, options), options);
  const dimensions = createDimensions(scaleDescriptors, marks2, options);
  autoScaleRange(scaleDescriptors, dimensions);
  const scales = createScaleFunctions(scaleDescriptors);
  const { fx, fy } = scales;
  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;
  const context = createContext(options);
  const document = context.document;
  const svg = creator_default("svg").call(document.documentElement);
  let figure = svg;
  context.ownerSVGElement = svg;
  context.className = className;
  context.projection = createProjection(options, subdimensions);
  context.path = function() {
    return path_default(this.projection ?? xyProjection(scales));
  };
  context.filterFacets = (data, channels) => {
    return facetFilter(facets, { channels, groups: facetGroups(data, channels) });
  };
  context.getMarkState = (mark) => {
    const state = stateByMark.get(mark);
    const facetState = facetStateByMark.get(mark);
    return { ...state, channels: { ...state.channels, ...facetState == null ? void 0 : facetState.channels } };
  };
  context.dispatchValue = (value) => {
    if (figure.value === value) return;
    figure.value = value;
    figure.dispatchEvent(new context.document.defaultView.Event("input", { bubbles: true }));
  };
  const newByScale = /* @__PURE__ */ new Set();
  for (const [mark, state] of stateByMark) {
    if (mark.initializer != null) {
      const dimensions2 = mark.facet === "super" ? superdimensions : subdimensions;
      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);
      if (update.data !== void 0) {
        state.data = update.data;
      }
      if (update.facets !== void 0) {
        state.facets = update.facets;
      }
      if (update.channels !== void 0) {
        const { fx: fx2, fy: fy2, ...channels } = update.channels;
        inferChannelScales(channels);
        Object.assign(state.channels, channels);
        for (const channel of Object.values(channels)) {
          const { scale: scale2 } = channel;
          if (scale2 != null && !isPosition(registry.get(scale2))) {
            applyScaleTransform(channel, options);
            newByScale.add(scale2);
          }
        }
        if (fx2 != null || fy2 != null) facetStateByMark.set(mark, true);
      }
    }
  }
  if (newByScale.size) {
    const newChannelsByScale = /* @__PURE__ */ new Map();
    addScaleChannels(newChannelsByScale, stateByMark, options, (key) => newByScale.has(key));
    addScaleChannels(channelsByScale, stateByMark, options, (key) => newByScale.has(key));
    const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
    const { scales: newExposedScales, ...newScales } = createScaleFunctions(newScaleDescriptors);
    Object.assign(scaleDescriptors, newScaleDescriptors);
    Object.assign(scales, newScales);
    Object.assign(scales.scales, newExposedScales);
  }
  let facetDomains, facetTranslate;
  if (facets !== void 0) {
    facetDomains = { x: fx == null ? void 0 : fx.domain(), y: fy == null ? void 0 : fy.domain() };
    facets = recreateFacets(facets, facetDomains);
    facetTranslate = facetTranslator(fx, fy, dimensions);
  }
  for (const [mark, state] of stateByMark) {
    state.values = mark.scale(state.channels, scales, context);
  }
  const { width, height } = dimensions;
  select_default(svg).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `:where(.${className}) {
  --plot-background: white;
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
:where(.${className} text),
:where(.${className} tspan) {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  for (const mark of marks2) {
    const { channels, values: values2, facets: indexes } = stateByMark.get(mark);
    if (facets === void 0 || mark.facet === "super") {
      let index = null;
      if (indexes) {
        index = indexes[0];
        index = mark.filter(index, channels, values2);
        if (index.length === 0) continue;
      }
      const node = mark.render(index, scales, values2, superdimensions, context);
      if (node == null) continue;
      svg.appendChild(node);
    } else {
      let g;
      for (const f of facets) {
        if (!(((_a = mark.facetAnchor) == null ? void 0 : _a.call(mark, facets, facetDomains, f)) ?? !f.empty)) continue;
        let index = null;
        if (indexes) {
          const faceted = facetStateByMark.has(mark);
          index = indexes[faceted ? f.i : 0];
          index = mark.filter(index, channels, values2);
          if (index.length === 0) continue;
          if (!faceted && index === indexes[0]) index = subarray(index);
          index.fx = f.x, index.fy = f.y, index.fi = f.i;
        }
        const node = mark.render(index, scales, values2, subdimensions, context);
        if (node == null) continue;
        (g ?? (g = select_default(svg).append("g"))).append(() => node).datum(f);
        for (const name of ["aria-label", "aria-description", "aria-hidden", "transform"]) {
          if (node.hasAttribute(name)) {
            g.attr(name, node.getAttribute(name));
            node.removeAttribute(name);
          }
        }
      }
      g == null ? void 0 : g.selectChildren().each(facetTranslate);
    }
  }
  const legends = createLegends(scaleDescriptors, context, options);
  const { figure: figured = title != null || subtitle != null || caption != null || legends.length > 0 } = options;
  if (figured) {
    figure = document.createElement("figure");
    figure.className = `${className}-figure`;
    figure.style.maxWidth = "initial";
    if (title != null) figure.append(createTitleElement(document, title, "h2"));
    if (subtitle != null) figure.append(createTitleElement(document, subtitle, "h3"));
    figure.append(...legends, svg);
    if (caption != null) figure.append(createFigcaption(document, caption));
    if ("value" in svg) figure.value = svg.value, delete svg.value;
  }
  figure.scale = exposeScales(scales.scales);
  figure.legend = exposeLegends(scaleDescriptors, context, options);
  const w = consumeWarnings();
  if (w > 0) {
    select_default(svg).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("⚠️").append("title").text(`${w.toLocaleString("en-US")} warning${w === 1 ? "" : "s"}. Please check the console.`);
  }
  return figure;
}
function createTitleElement(document, contents, tag) {
  if (contents.ownerDocument) return contents;
  const e = document.createElement(tag);
  e.append(contents);
  return e;
}
function createFigcaption(document, caption) {
  const e = document.createElement("figcaption");
  e.append(caption);
  return e;
}
function flatMarks(marks2) {
  return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);
}
function markify(mark) {
  return typeof mark.render === "function" ? mark : new Render(mark);
}
var Render = class extends Mark {
  constructor(render) {
    if (typeof render !== "function") throw new TypeError("invalid mark; missing render function");
    super();
    this.render = render;
  }
  render() {
  }
};
function applyScaleTransforms(channels, options) {
  for (const name in channels) applyScaleTransform(channels[name], options);
  return channels;
}
function applyScaleTransform(channel, options) {
  const { scale: scale2, transform: t = true } = channel;
  if (scale2 == null || !t) return;
  const {
    type,
    percent,
    interval,
    transform = percent ? (x) => x == null ? NaN : x * 100 : maybeIntervalTransform(interval, type)
  } = options[scale2] ?? {};
  if (transform == null) return;
  channel.value = map(channel.value, transform);
  channel.transform = false;
}
function inferChannelScales(channels) {
  for (const name in channels) {
    inferChannelScale(name, channels[name]);
  }
}
function addScaleChannels(channelsByScale, stateByMark, options, filter2 = yes) {
  var _a, _b;
  for (const { channels } of stateByMark.values()) {
    for (const name in channels) {
      const channel = channels[name];
      const { scale: scale2 } = channel;
      if (scale2 != null && filter2(scale2)) {
        if (scale2 === "projection") {
          if (!hasProjection(options)) {
            const gx = ((_a = options.x) == null ? void 0 : _a.domain) === void 0;
            const gy = ((_b = options.y) == null ? void 0 : _b.domain) === void 0;
            if (gx || gy) {
              const [x, y] = getGeometryChannels(channel);
              if (gx) addScaleChannel(channelsByScale, "x", x);
              if (gy) addScaleChannel(channelsByScale, "y", y);
            }
          }
        } else {
          addScaleChannel(channelsByScale, scale2, channel);
        }
      }
    }
  }
  return channelsByScale;
}
function addScaleChannel(channelsByScale, scale2, channel) {
  const scaleChannels = channelsByScale.get(scale2);
  if (scaleChannels !== void 0) scaleChannels.push(channel);
  else channelsByScale.set(scale2, [channel]);
}
function maybeTopFacet(facet, options) {
  if (facet == null) return;
  const { x, y } = facet;
  if (x == null && y == null) return;
  const data = dataify(facet.data);
  if (data == null) throw new Error("missing facet data");
  const channels = {};
  if (x != null) channels.fx = createChannel(data, { value: x, scale: "fx" });
  if (y != null) channels.fy = createChannel(data, { value: y, scale: "fy" });
  applyScaleTransforms(channels, options);
  const groups = facetGroups(data, channels);
  return { channels, groups, data: facet.data };
}
function maybeMarkFacet(mark, topFacetState, options) {
  if (mark.facet === null || mark.facet === "super") return;
  const { fx, fy } = mark;
  if (fx != null || fy != null) {
    const data2 = dataify(mark.data ?? fx ?? fy);
    if (data2 === void 0) throw new Error(`missing facet data in ${mark.ariaLabel}`);
    if (data2 === null) return;
    const channels2 = {};
    if (fx != null) channels2.fx = createChannel(data2, { value: fx, scale: "fx" });
    if (fy != null) channels2.fy = createChannel(data2, { value: fy, scale: "fy" });
    applyScaleTransforms(channels2, options);
    return { channels: channels2, groups: facetGroups(data2, channels2) };
  }
  if (topFacetState === void 0) return;
  const { channels, groups, data } = topFacetState;
  if (mark.facet !== "auto" || mark.data === data) return { channels, groups };
  if (data.length > 0 && (groups.size > 1 || groups.size === 1 && channels.fx && channels.fy && [...groups][0][1].size > 1) && lengthof(dataify(mark.data)) === lengthof(data)) {
    warn(
      `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn’t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
    );
  }
}
function derive(mark, options = {}) {
  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, context) => {
    return context.getMarkState(mark);
  });
}
function inferTips(marks2) {
  const tips = [];
  for (const mark of marks2) {
    let tipOptions = mark.tip;
    if (tipOptions) {
      if (tipOptions === true) tipOptions = {};
      else if (typeof tipOptions === "string") tipOptions = { pointer: tipOptions };
      let { pointer: p, preferredAnchor: a } = tipOptions;
      p = /^x$/i.test(p) ? pointerX : /^y$/i.test(p) ? pointerY : pointer;
      tipOptions = p(derive(mark, tipOptions));
      tipOptions.title = null;
      if (a === void 0) tipOptions.preferredAnchor = p === pointerY ? "left" : "bottom";
      const t = tip(mark.data, tipOptions);
      t.facet = mark.facet;
      t.facetAnchor = mark.facetAnchor;
      tips.push(t);
    }
  }
  return tips;
}
function inferAxes(marks2, channelsByScale, options) {
  let {
    projection: projection2,
    x = {},
    y = {},
    fx = {},
    fy = {},
    axis,
    grid,
    facet = {},
    facet: { axis: facetAxis = axis, grid: facetGrid } = facet,
    x: { axis: xAxis = axis, grid: xGrid = xAxis === null ? null : grid } = x,
    y: { axis: yAxis = axis, grid: yGrid = yAxis === null ? null : grid } = y,
    fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx,
    fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy
  } = options;
  if (projection2 || !isScaleOptions(x) && !hasPositionChannel("x", marks2)) xAxis = xGrid = null;
  if (projection2 || !isScaleOptions(y) && !hasPositionChannel("y", marks2)) yAxis = yGrid = null;
  if (!channelsByScale.has("fx")) fxAxis = fxGrid = null;
  if (!channelsByScale.has("fy")) fyAxis = fyGrid = null;
  if (xAxis === void 0) xAxis = !hasAxis(marks2, "x");
  if (yAxis === void 0) yAxis = !hasAxis(marks2, "y");
  if (fxAxis === void 0) fxAxis = !hasAxis(marks2, "fx");
  if (fyAxis === void 0) fyAxis = !hasAxis(marks2, "fy");
  if (xAxis === true) xAxis = "bottom";
  if (yAxis === true) yAxis = "left";
  if (fxAxis === true) fxAxis = xAxis === "top" || xAxis === null ? "bottom" : "top";
  if (fyAxis === true) fyAxis = yAxis === "right" || yAxis === null ? "left" : "right";
  const axes = [];
  maybeGrid(axes, fyGrid, gridFy, fy);
  maybeAxis(axes, fyAxis, axisFy, "right", "left", facet, fy);
  maybeGrid(axes, fxGrid, gridFx, fx);
  maybeAxis(axes, fxAxis, axisFx, "top", "bottom", facet, fx);
  maybeGrid(axes, yGrid, gridY, y);
  maybeAxis(axes, yAxis, axisY, "left", "right", options, y);
  maybeGrid(axes, xGrid, gridX, x);
  maybeAxis(axes, xAxis, axisX, "bottom", "top", options, x);
  return axes;
}
function maybeAxis(axes, axis, axisType, primary, secondary, defaults22, options) {
  if (!axis) return;
  const both = isBoth(axis);
  options = axisOptions(both ? primary : axis, defaults22, options);
  const { line: line2 } = options;
  if ((axisType === axisY || axisType === axisX) && line2 && !isNone(line2)) axes.push(frame(lineOptions(options)));
  axes.push(axisType(options));
  if (both) axes.push(axisType({ ...options, anchor: secondary, label: null }));
}
function maybeGrid(axes, grid, gridType, options) {
  if (!grid || isNone(grid)) return;
  axes.push(gridType(gridOptions(grid, options)));
}
function isBoth(value) {
  return /^\s*both\s*$/i.test(value);
}
function axisOptions(anchor, defaults22, {
  line: line2 = defaults22.line,
  ticks: ticks2,
  tickSize,
  tickSpacing,
  tickPadding,
  tickFormat,
  tickRotate,
  fontVariant,
  ariaLabel,
  ariaDescription,
  label = defaults22.label,
  labelAnchor,
  labelArrow = defaults22.labelArrow,
  labelOffset
}) {
  return {
    anchor,
    line: line2,
    ticks: ticks2,
    tickSize,
    tickSpacing,
    tickPadding,
    tickFormat,
    tickRotate,
    fontVariant,
    ariaLabel,
    ariaDescription,
    label,
    labelAnchor,
    labelArrow,
    labelOffset
  };
}
function lineOptions(options) {
  const { anchor, line: line2 } = options;
  return { anchor, facetAnchor: anchor + "-empty", stroke: line2 === true ? void 0 : line2 };
}
function gridOptions(grid, {
  stroke = isColor(grid) ? grid : void 0,
  ticks: ticks2 = isGridTicks(grid) ? grid : void 0,
  tickSpacing,
  ariaLabel,
  ariaDescription
}) {
  return {
    stroke,
    ticks: ticks2,
    tickSpacing,
    ariaLabel,
    ariaDescription
  };
}
function isGridTicks(grid) {
  switch (typeof grid) {
    case "number":
      return true;
    case "string":
      return !isColor(grid);
  }
  return isIterable(grid) || typeof (grid == null ? void 0 : grid.range) === "function";
}
function hasAxis(marks2, k) {
  const prefix = `${k}-axis `;
  return marks2.some((m) => {
    var _a;
    return (_a = m.ariaLabel) == null ? void 0 : _a.startsWith(prefix);
  });
}
function hasPositionChannel(k, marks2) {
  for (const mark of marks2) {
    for (const key in mark.channels) {
      const { scale: scale2 } = mark.channels[key];
      if (scale2 === k || scale2 === "projection") {
        return true;
      }
    }
  }
  return false;
}
function inheritScaleLabels(newScales, scales) {
  for (const key in newScales) {
    const newScale = newScales[key];
    const scale2 = scales[key];
    if (newScale.label === void 0 && scale2) {
      newScale.label = scale2.label;
    }
  }
  return newScales;
}
function actualDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  const fxr = fx && outerRange(fx);
  const fyr = fy && outerRange(fy);
  return {
    marginTop: fy ? fyr[0] : marginTop,
    marginRight: fx ? width - fxr[1] : marginRight,
    marginBottom: fy ? height - fyr[1] : marginBottom,
    marginLeft: fx ? fxr[0] : marginLeft,
    // Some marks, namely the x- and y-axis labels, want to know what the
    // desired (rather than actual) margins are for positioning.
    inset: {
      marginTop: dimensions.marginTop,
      marginRight: dimensions.marginRight,
      marginBottom: dimensions.marginBottom,
      marginLeft: dimensions.marginLeft
    },
    width,
    height
  };
}
function outerRange(scale2) {
  const domain = scale2.domain();
  if (domain.length === 0) return [0, scale2.bandwidth()];
  let x1 = scale2(domain[0]);
  let x2 = scale2(domain[domain.length - 1]);
  if (x2 < x1) [x1, x2] = [x2, x1];
  return [x1, x2 + scale2.bandwidth()];
}

// node_modules/@observablehq/plot/src/curve.js
var curves = /* @__PURE__ */ new Map([
  ["basis", basis_default],
  ["basis-closed", basisClosed_default],
  ["basis-open", basisOpen_default],
  ["bundle", bundle_default],
  ["bump-x", bumpX],
  ["bump-y", bumpY],
  ["cardinal", cardinal_default],
  ["cardinal-closed", cardinalClosed_default],
  ["cardinal-open", cardinalOpen_default],
  ["catmull-rom", catmullRom_default],
  ["catmull-rom-closed", catmullRomClosed_default],
  ["catmull-rom-open", catmullRomOpen_default],
  ["linear", linear_default],
  ["linear-closed", linearClosed_default],
  ["monotone-x", monotoneX],
  ["monotone-y", monotoneY],
  ["natural", natural_default],
  ["step", step_default],
  ["step-after", stepAfter],
  ["step-before", stepBefore]
]);
function maybeCurve(curve = linear_default, tension) {
  if (typeof curve === "function") return curve;
  const c = curves.get(`${curve}`.toLowerCase());
  if (!c) throw new Error(`unknown curve: ${curve}`);
  if (tension !== void 0) {
    if ("beta" in c) {
      return c.beta(tension);
    } else if ("tension" in c) {
      return c.tension(tension);
    } else if ("alpha" in c) {
      return c.alpha(tension);
    }
  }
  return c;
}
function maybeCurveAuto(curve = curveAuto, tension) {
  return typeof curve !== "function" && `${curve}`.toLowerCase() === "auto" ? curveAuto : maybeCurve(curve, tension);
}
function curveAuto(context) {
  return linear_default(context);
}

// node_modules/@observablehq/plot/src/transforms/bin.js
function binX(outputs = { y: "count" }, options = {}) {
  [outputs, options] = mergeOptions2(outputs, options);
  const { x, y } = options;
  return binn(maybeBinValue(x, options, identity2), null, null, y, outputs, maybeInsetX(options));
}
function binY(outputs = { x: "count" }, options = {}) {
  [outputs, options] = mergeOptions2(outputs, options);
  const { x, y } = options;
  return binn(null, maybeBinValue(y, options, identity2), x, null, outputs, maybeInsetY(options));
}
function bin(outputs = { fill: "count" }, options = {}) {
  [outputs, options] = mergeOptions2(outputs, options);
  const { x, y } = maybeBinValueTuple(options);
  return binn(x, y, null, null, outputs, maybeInsetX(maybeInsetY(options)));
}
function maybeDenseInterval(bin2, k, options = {}) {
  if ((options == null ? void 0 : options.interval) == null) return options;
  const { reduce = reduceFirst } = options;
  const outputs = { filter: null };
  if (options[k] != null) outputs[k] = reduce;
  if (options[`${k}1`] != null) outputs[`${k}1`] = reduce;
  if (options[`${k}2`] != null) outputs[`${k}2`] = reduce;
  return bin2(outputs, options);
}
function maybeDenseIntervalX(options = {}) {
  return maybeDenseInterval(binX, "y", withTip(options, "x"));
}
function maybeDenseIntervalY(options = {}) {
  return maybeDenseInterval(binY, "x", withTip(options, "y"));
}
function binn(bx, by, gx, gy, {
  data: reduceData = reduceIdentity,
  // TODO avoid materializing when unused?
  filter: filter2 = reduceCount,
  // return only non-empty bins by default
  sort: sort3,
  reverse: reverse3,
  ...outputs
  // output channel definitions
} = {}, inputs = {}) {
  bx = maybeBin(bx);
  by = maybeBin(by);
  outputs = maybeBinOutputs(outputs, inputs);
  reduceData = maybeBinReduce(reduceData, identity2);
  sort3 = sort3 == null ? void 0 : maybeBinOutput("sort", sort3, inputs);
  filter2 = filter2 == null ? void 0 : maybeBinEvaluator("filter", filter2, inputs);
  if (gx != null && hasOutput(outputs, "x", "x1", "x2")) gx = null;
  if (gy != null && hasOutput(outputs, "y", "y1", "y2")) gy = null;
  const [BX1, setBX1] = maybeColumn(bx);
  const [BX2, setBX2] = maybeColumn(bx);
  const [BY1, setBY1] = maybeColumn(by);
  const [BY2, setBY2] = maybeColumn(by);
  const [k, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
  const [GK, setGK] = maybeColumn(k);
  const {
    x,
    y,
    z,
    fill,
    stroke,
    x1,
    x2,
    // consumed if x is an output
    y1,
    y2,
    // consumed if y is an output
    domain,
    cumulative,
    thresholds,
    interval,
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets, plotOptions) => {
      const K = maybeApplyInterval(valueof(data, k), plotOptions == null ? void 0 : plotOptions[gk]);
      const Z = valueof(data, z);
      const F = valueof(data, vfill);
      const S = valueof(data, vstroke);
      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });
      const groupFacets = [];
      const groupData = [];
      const GK2 = K && setGK([]);
      const GZ2 = Z && setGZ([]);
      const GF2 = F && setGF([]);
      const GS2 = S && setGS([]);
      const BX12 = bx && setBX1([]);
      const BX22 = bx && setBX2([]);
      const BY12 = by && setBY1([]);
      const BY22 = by && setBY2([]);
      const bin2 = bing(bx, by, data);
      let i = 0;
      for (const o of outputs) o.initialize(data);
      if (sort3) sort3.initialize(data);
      if (filter2) filter2.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o of outputs) o.scope("facet", facet);
        if (sort3) sort3.scope("facet", facet);
        if (filter2) filter2.scope("facet", facet);
        for (const [f, I] of maybeGroup(facet, G)) {
          for (const [k2, g] of maybeGroup(I, K)) {
            for (const [b, extent3] of bin2(g)) {
              if (G) extent3.z = f;
              if (filter2 && !filter2.reduce(b, extent3)) continue;
              groupFacet.push(i++);
              groupData.push(reduceData.reduceIndex(b, data, extent3));
              if (K) GK2.push(k2);
              if (Z) GZ2.push(G === Z ? f : Z[(b.length > 0 ? b : g)[0]]);
              if (F) GF2.push(G === F ? f : F[(b.length > 0 ? b : g)[0]]);
              if (S) GS2.push(G === S ? f : S[(b.length > 0 ? b : g)[0]]);
              if (BX12) BX12.push(extent3.x1), BX22.push(extent3.x2);
              if (BY12) BY12.push(extent3.y1), BY22.push(extent3.y2);
              for (const o of outputs) o.reduce(b, extent3);
              if (sort3) sort3.reduce(b, extent3);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort3, reverse3);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x, x1, x2 }),
    ...!hasOutput(outputs, "y") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y, y1, y2 }),
    ...GK && { [gk]: GK },
    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
  };
}
function mergeOptions2({ cumulative, domain, thresholds, interval, ...outputs }, options) {
  return [outputs, { cumulative, domain, thresholds, interval, ...options }];
}
function maybeBinValue(value, { cumulative, domain, thresholds, interval }, defaultValue) {
  value = { ...maybeValue(value) };
  if (value.domain === void 0) value.domain = domain;
  if (value.cumulative === void 0) value.cumulative = cumulative;
  if (value.thresholds === void 0) value.thresholds = thresholds;
  if (value.interval === void 0) value.interval = interval;
  if (value.value === void 0) value.value = defaultValue;
  value.thresholds = maybeThresholds(value.thresholds, value.interval);
  return value;
}
function maybeBinValueTuple(options) {
  let { x, y } = options;
  x = maybeBinValue(x, options);
  y = maybeBinValue(y, options);
  [x.value, y.value] = maybeTuple(x.value, y.value);
  return { x, y };
}
function maybeBin(options) {
  if (options == null) return;
  const { value, cumulative, domain = extent, thresholds } = options;
  const bin2 = (data) => {
    let V = valueof(data, value);
    let T;
    if (isTemporal(V) || isTimeThresholds(thresholds)) {
      V = map(V, coerceDate, Float64Array);
      let [min2, max2] = typeof domain === "function" ? domain(V) : domain;
      let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min2, max2) : thresholds;
      if (typeof t === "number") t = utcTickInterval(min2, max2, t);
      if (isInterval(t)) {
        if (domain === extent) {
          min2 = t.floor(min2);
          max2 = t.offset(t.floor(max2));
        }
        t = t.range(min2, t.offset(max2));
      }
      T = t;
    } else {
      V = coerceNumbers(V);
      let [min2, max2] = typeof domain === "function" ? domain(V) : domain;
      let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min2, max2) : thresholds;
      if (typeof t === "number") {
        if (domain === extent) {
          let step = tickIncrement(min2, max2, t);
          if (isFinite(step)) {
            if (step > 0) {
              let r0 = Math.round(min2 / step);
              let r1 = Math.round(max2 / step);
              if (!(r0 * step <= min2)) --r0;
              if (!(r1 * step > max2)) ++r1;
              let n = r1 - r0 + 1;
              t = new Float64Array(n);
              for (let i = 0; i < n; ++i) t[i] = (r0 + i) * step;
            } else if (step < 0) {
              step = -step;
              let r0 = Math.round(min2 * step);
              let r1 = Math.round(max2 * step);
              if (!(r0 / step <= min2)) --r0;
              if (!(r1 / step > max2)) ++r1;
              let n = r1 - r0 + 1;
              t = new Float64Array(n);
              for (let i = 0; i < n; ++i) t[i] = (r0 + i) / step;
            } else {
              t = [min2];
            }
          } else {
            t = [min2];
          }
        } else {
          t = ticks(min2, max2, t);
        }
      } else if (isInterval(t)) {
        if (domain === extent) {
          min2 = t.floor(min2);
          max2 = t.offset(t.floor(max2));
        }
        t = t.range(min2, t.offset(max2));
      }
      T = t;
    }
    const E = [];
    if (T.length === 1) E.push([T[0], T[0]]);
    else for (let i = 1; i < T.length; ++i) E.push([T[i - 1], T[i]]);
    E.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E, T, V);
    return E;
  };
  bin2.label = labelof(value);
  return bin2;
}
function maybeThresholds(thresholds, interval, defaultThresholds = thresholdAuto) {
  if (thresholds === void 0) {
    return interval === void 0 ? defaultThresholds : maybeRangeInterval(interval);
  }
  if (typeof thresholds === "string") {
    switch (thresholds.toLowerCase()) {
      case "freedman-diaconis":
        return thresholdFreedmanDiaconis;
      case "scott":
        return thresholdScott;
      case "sturges":
        return thresholdSturges;
      case "auto":
        return thresholdAuto;
    }
    return utcInterval(thresholds);
  }
  return thresholds;
}
function maybeBinOutputs(outputs, inputs) {
  return maybeOutputs(outputs, inputs, maybeBinOutput);
}
function maybeBinOutput(name, reduce, inputs) {
  return maybeOutput(name, reduce, inputs, maybeBinEvaluator);
}
function maybeBinEvaluator(name, reduce, inputs) {
  return maybeEvaluator(name, reduce, inputs, maybeBinReduce);
}
function maybeBinReduce(reduce, value) {
  return maybeReduce(reduce, value, maybeBinReduceFallback);
}
function maybeBinReduceFallback(reduce) {
  switch (`${reduce}`.toLowerCase()) {
    case "x":
      return reduceX2;
    case "x1":
      return reduceX1;
    case "x2":
      return reduceX22;
    case "y":
      return reduceY2;
    case "y1":
      return reduceY1;
    case "y2":
      return reduceY22;
    case "z":
      return reduceZ;
  }
  throw new Error(`invalid bin reduce: ${reduce}`);
}
function thresholdAuto(values2, min2, max2) {
  return Math.min(200, thresholdScott(values2, min2, max2));
}
function isTimeThresholds(t) {
  return isTimeInterval(t) || isIterable(t) && isTemporal(t);
}
function bing(bx, by, data) {
  const EX = bx == null ? void 0 : bx(data);
  const EY = by == null ? void 0 : by(data);
  return EX && EY ? function* (I) {
    const X = EX.bin(I);
    for (const [ix, [x1, x2]] of EX.entries()) {
      const Y = EY.bin(X[ix]);
      for (const [iy, [y1, y2]] of EY.entries()) {
        yield [Y[iy], { data, x1, y1, x2, y2 }];
      }
    }
  } : EX ? function* (I) {
    const X = EX.bin(I);
    for (const [i, [x1, x2]] of EX.entries()) {
      yield [X[i], { data, x1, x2 }];
    }
  } : function* (I) {
    const Y = EY.bin(I);
    for (const [i, [y1, y2]] of EY.entries()) {
      yield [Y[i], { data, y1, y2 }];
    }
  };
}
function bin1(E, T, V) {
  T = coerceNumbers(T);
  return (I) => {
    var _a;
    const B = E.map(() => []);
    for (const i of I) (_a = B[bisect_default(T, V[i]) - 1]) == null ? void 0 : _a.push(i);
    return B;
  };
}
function bin1cp(E, T, V) {
  const bin2 = bin1(E, T, V);
  return (I) => {
    const B = bin2(I);
    for (let i = 1, n = B.length; i < n; ++i) {
      const C = B[i - 1];
      const b = B[i];
      for (const j of C) b.push(j);
    }
    return B;
  };
}
function bin1cn(E, T, V) {
  const bin2 = bin1(E, T, V);
  return (I) => {
    const B = bin2(I);
    for (let i = B.length - 2; i >= 0; --i) {
      const C = B[i + 1];
      const b = B[i];
      for (const j of C) b.push(j);
    }
    return B;
  };
}
function mid1(x1, x2) {
  const m = (+x1 + +x2) / 2;
  return x1 instanceof Date ? new Date(m) : m;
}
var reduceX2 = {
  reduceIndex(I, X, { x1, x2 }) {
    return mid1(x1, x2);
  }
};
var reduceY2 = {
  reduceIndex(I, X, { y1, y2 }) {
    return mid1(y1, y2);
  }
};
var reduceX1 = {
  reduceIndex(I, X, { x1 }) {
    return x1;
  }
};
var reduceX22 = {
  reduceIndex(I, X, { x2 }) {
    return x2;
  }
};
var reduceY1 = {
  reduceIndex(I, X, { y1 }) {
    return y1;
  }
};
var reduceY22 = {
  reduceIndex(I, X, { y2 }) {
    return y2;
  }
};

// node_modules/@observablehq/plot/src/marks/area.js
var defaults7 = {
  ariaLabel: "area",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Area = class extends Mark {
  constructor(data, options = {}) {
    const { x1, y1, x2, y2, z, curve, tension } = options;
    super(
      data,
      {
        x1: { value: x1, scale: "x" },
        y1: { value: y1, scale: "y" },
        x2: { value: x2, scale: "x", optional: true },
        y2: { value: y2, scale: "y", optional: true },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults7
    );
    this.z = z;
    this.curve = maybeCurve(curve, tension);
  }
  filter(index) {
    return index;
  }
  render(index, scales, channels, dimensions, context) {
    const { x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1 } = channels;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call(
      (g) => g.selectAll().data(groupIndex(index, [X1, Y1, X2, Y2], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(
        "d",
        area_default().curve(this.curve).defined((i) => i >= 0).x0((i) => X1[i]).y0((i) => Y1[i]).x1((i) => X2[i]).y1((i) => Y2[i])
      )
    ).node();
  }
};
function area(data, options) {
  if (options === void 0) return areaY(data, { x: first, y: second2 });
  return new Area(data, options);
}
function areaX(data, options) {
  const { y = indexOf, ...rest } = maybeDenseIntervalY(options);
  return new Area(data, maybeStackX(maybeIdentityX({ ...rest, y1: y, y2: void 0 }, y === indexOf ? "x2" : "x")));
}
function areaY(data, options) {
  const { x = indexOf, ...rest } = maybeDenseIntervalX(options);
  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x, x2: void 0 }, x === indexOf ? "y2" : "y")));
}

// node_modules/@observablehq/plot/src/marks/link.js
var defaults8 = {
  ariaLabel: "link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var Link = class extends Mark {
  constructor(data, options = {}) {
    const { x1, y1, x2, y2, curve, tension } = options;
    super(
      data,
      {
        x1: { value: x1, scale: "x" },
        y1: { value: y1, scale: "y" },
        x2: { value: x2, scale: "x", optional: true },
        y2: { value: y2, scale: "y", optional: true }
      },
      options,
      defaults8
    );
    this.curve = maybeCurveAuto(curve, tension);
    markers(this, options);
  }
  project(channels, values2, context) {
    if (this.curve !== curveAuto) {
      super.project(channels, values2, context);
    }
  }
  render(index, scales, channels, dimensions, context) {
    const { x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1 } = channels;
    const { curve } = this;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
      (g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr(
        "d",
        curve === curveAuto && context.projection ? sphereLink(context.path(), X1, Y1, X2, Y2) : (i) => {
          const p = pathRound();
          const c = curve(p);
          c.lineStart();
          c.point(X1[i], Y1[i]);
          c.point(X2[i], Y2[i]);
          c.lineEnd();
          return p;
        }
      ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
function sphereLink(path, X1, Y1, X2, Y2) {
  X1 = coerceNumbers(X1);
  Y1 = coerceNumbers(Y1);
  X2 = coerceNumbers(X2);
  Y2 = coerceNumbers(Y2);
  return (i) => path({
    type: "LineString",
    coordinates: [
      [X1[i], Y1[i]],
      [X2[i], Y2[i]]
    ]
  });
}
function link(data, { x, x1, x2, y, y1, y2, ...options } = {}) {
  [x1, x2] = maybeSameValue(x, x1, x2);
  [y1, y2] = maybeSameValue(y, y1, y2);
  return new Link(data, { ...options, x1, x2, y1, y2 });
}
function maybeSameValue(x, x1, x2) {
  if (x === void 0) {
    if (x1 === void 0) {
      if (x2 !== void 0) return [x2];
    } else {
      if (x2 === void 0) return [x1];
    }
  } else if (x1 === void 0) {
    return x2 === void 0 ? [x] : [x, x2];
  } else if (x2 === void 0) {
    return [x, x1];
  }
  return [x1, x2];
}

// node_modules/@observablehq/plot/src/marks/arrow.js
var defaults9 = {
  ariaLabel: "arrow",
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeMiterlimit: 1,
  strokeWidth: 1.5
};
var Arrow = class extends Mark {
  constructor(data, options = {}) {
    const {
      x1,
      y1,
      x2,
      y2,
      bend = 0,
      headAngle = 60,
      headLength = 8,
      // Disable the arrow with headLength = 0; or, use Plot.link.
      inset = 0,
      insetStart = inset,
      insetEnd = inset,
      sweep
    } = options;
    super(
      data,
      {
        x1: { value: x1, scale: "x" },
        y1: { value: y1, scale: "y" },
        x2: { value: x2, scale: "x", optional: true },
        y2: { value: y2, scale: "y", optional: true }
      },
      options,
      defaults9
    );
    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));
    this.headAngle = +headAngle;
    this.headLength = +headLength;
    this.insetStart = +insetStart;
    this.insetEnd = +insetEnd;
    this.sweep = maybeSweep(sweep);
  }
  render(index, scales, channels, dimensions, context) {
    const { x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1, SW } = channels;
    const { strokeWidth, bend, headAngle, headLength, insetStart, insetEnd } = this;
    const sw = SW ? (i) => SW[i] : constant(strokeWidth === void 0 ? 1 : strokeWidth);
    const wingAngle = headAngle * radians / 2;
    const wingScale = headLength / 1.5;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
      (g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => {
        let x1 = X1[i], y1 = Y1[i], x2 = X2[i], y2 = Y2[i];
        const lineLength = Math.hypot(x2 - x1, y2 - y1);
        if (lineLength <= insetStart + insetEnd) return null;
        let lineAngle = Math.atan2(y2 - y1, x2 - x1);
        const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);
        const bendAngle = this.sweep(x1, y1, x2, y2) * bend * radians;
        const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;
        if (insetStart || insetEnd) {
          if (r < 1e5) {
            const sign = Math.sign(bendAngle);
            const [cx, cy] = pointPointCenter([x1, y1], [x2, y2], r, sign);
            if (insetStart) {
              [x1, y1] = circleCircleIntersect([cx, cy, r], [x1, y1, insetStart], -sign * Math.sign(insetStart));
            }
            if (insetEnd) {
              const [x, y] = circleCircleIntersect([cx, cy, r], [x2, y2, insetEnd], sign * Math.sign(insetEnd));
              lineAngle += Math.atan2(y - cy, x - cx) - Math.atan2(y2 - cy, x2 - cx);
              x2 = x, y2 = y;
            }
          } else {
            const dx = x2 - x1, dy = y2 - y1, d = Math.hypot(dx, dy);
            if (insetStart) x1 += dx / d * insetStart, y1 += dy / d * insetStart;
            if (insetEnd) x2 -= dx / d * insetEnd, y2 -= dy / d * insetEnd;
          }
        }
        const endAngle = lineAngle + bendAngle;
        const leftAngle = endAngle + wingAngle;
        const rightAngle = endAngle - wingAngle;
        const x3 = x2 - headLength2 * Math.cos(leftAngle);
        const y3 = y2 - headLength2 * Math.sin(leftAngle);
        const x4 = x2 - headLength2 * Math.cos(rightAngle);
        const y4 = y2 - headLength2 * Math.sin(rightAngle);
        const a = r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`;
        const h = headLength2 ? `M${x3},${y3}L${x2},${y2}L${x4},${y4}` : "";
        return `M${x1},${y1}${a}${x2},${y2}${h}`;
      }).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function maybeSweep(sweep = 1) {
  if (typeof sweep === "number") return constant(Math.sign(sweep));
  if (typeof sweep === "function") return (x1, y1, x2, y2) => Math.sign(sweep(x1, y1, x2, y2));
  switch (keyword(sweep, "sweep", ["+x", "-x", "+y", "-y"])) {
    case "+x":
      return (x1, y1, x2) => ascending(x1, x2);
    case "-x":
      return (x1, y1, x2) => descending(x1, x2);
    case "+y":
      return (x1, y1, x2, y2) => ascending(y1, y2);
    case "-y":
      return (x1, y1, x2, y2) => descending(y1, y2);
  }
}
function pointPointCenter([ax, ay], [bx, by], r, sign) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const k = sign * Math.sqrt(r * r - d * d / 4) / d;
  return [(ax + bx) / 2 - dy * k, (ay + by) / 2 + dx * k];
}
function circleCircleIntersect([ax, ay, ar], [bx, by, br], sign) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const x = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);
  const y = sign * Math.sqrt(ar * ar - x * x);
  return [ax + (dx * x + dy * y) / d, ay + (dy * x - dx * y) / d];
}
function arrow(data, { x, x1, x2, y, y1, y2, ...options } = {}) {
  [x1, x2] = maybeSameValue(x, x1, x2);
  [y1, y2] = maybeSameValue(y, y1, y2);
  return new Arrow(data, { ...options, x1, x2, y1, y2 });
}

// node_modules/@observablehq/plot/src/marks/bar.js
var barDefaults = {
  ariaLabel: "bar"
};
var AbstractBar = class extends Mark {
  constructor(data, channels, options = {}, defaults22 = barDefaults) {
    super(data, channels, options, defaults22);
    rectInsets(this, options);
    rectRadii(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { rx, ry, rx1y1, rx1y2, rx2y1, rx2y2 } = this;
    const x = this._x(scales, channels, dimensions);
    const y = this._y(scales, channels, dimensions);
    const w = this._width(scales, channels, dimensions);
    const h = this._height(scales, channels, dimensions);
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
      (g) => g.selectAll().data(index).enter().call(
        rx1y1 || rx1y2 || rx2y1 || rx2y2 ? (g2) => g2.append("path").call(applyDirectStyles, this).call(applyRoundedRect, x, y, add(x, w), add(y, h), this).call(applyChannelStyles, this, channels) : (g2) => g2.append("rect").call(applyDirectStyles, this).attr("x", x).attr("width", w).attr("y", y).attr("height", h).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
      )
    ).node();
  }
  _x(scales, { x: X }, { marginLeft }) {
    const { insetLeft } = this;
    return X ? (i) => X[i] + insetLeft : marginLeft + insetLeft;
  }
  _y(scales, { y: Y }, { marginTop }) {
    const { insetTop } = this;
    return Y ? (i) => Y[i] + insetTop : marginTop + insetTop;
  }
  _width({ x }, { x: X }, { marginRight, marginLeft, width }) {
    const { insetLeft, insetRight } = this;
    const bandwidth = X && x ? x.bandwidth() : width - marginRight - marginLeft;
    return Math.max(0, bandwidth - insetLeft - insetRight);
  }
  _height({ y }, { y: Y }, { marginTop, marginBottom, height }) {
    const { insetTop, insetBottom } = this;
    const bandwidth = Y && y ? y.bandwidth() : height - marginTop - marginBottom;
    return Math.max(0, bandwidth - insetTop - insetBottom);
  }
};
function add(a, b) {
  return typeof a === "function" && typeof b === "function" ? (i) => a(i) + b(i) : typeof a === "function" ? (i) => a(i) + b : typeof b === "function" ? (i) => a + b(i) : a + b;
}
var BarX = class extends AbstractBar {
  constructor(data, options = {}, defaults22) {
    const { x1, x2, y } = options;
    super(
      data,
      {
        x1: { value: x1, scale: "x" },
        x2: { value: x2, scale: "x" },
        y: { value: y, scale: "y", type: "band", optional: true }
      },
      options,
      defaults22
    );
  }
  _transform(selection, mark, { x }) {
    selection.call(applyTransform, mark, { x }, 0, 0);
  }
  _x({ x }, { x1: X1, x2: X2 }, { marginLeft }) {
    const { insetLeft } = this;
    return isCollapsed(x) ? marginLeft + insetLeft : (i) => Math.min(X1[i], X2[i]) + insetLeft;
  }
  _width({ x }, { x1: X1, x2: X2 }, { marginRight, marginLeft, width }) {
    const { insetLeft, insetRight } = this;
    return isCollapsed(x) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X2[i] - X1[i]) - insetLeft - insetRight);
  }
};
var BarY = class extends AbstractBar {
  constructor(data, options = {}, defaults22) {
    const { x, y1, y2 } = options;
    super(
      data,
      {
        y1: { value: y1, scale: "y" },
        y2: { value: y2, scale: "y" },
        x: { value: x, scale: "x", type: "band", optional: true }
      },
      options,
      defaults22
    );
  }
  _transform(selection, mark, { y }) {
    selection.call(applyTransform, mark, { y }, 0, 0);
  }
  _y({ y }, { y1: Y1, y2: Y2 }, { marginTop }) {
    const { insetTop } = this;
    return isCollapsed(y) ? marginTop + insetTop : (i) => Math.min(Y1[i], Y2[i]) + insetTop;
  }
  _height({ y }, { y1: Y1, y2: Y2 }, { marginTop, marginBottom, height }) {
    const { insetTop, insetBottom } = this;
    return isCollapsed(y) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y2[i] - Y1[i]) - insetTop - insetBottom);
  }
};
function barX(data, options = {}) {
  if (!hasXY(options)) options = { ...options, y: indexOf, x2: identity2 };
  return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));
}
function barY(data, options = {}) {
  if (!hasXY(options)) options = { ...options, x: indexOf, y2: identity2 };
  return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));
}

// node_modules/@observablehq/plot/src/marks/cell.js
var defaults10 = {
  ariaLabel: "cell"
};
var Cell = class extends AbstractBar {
  constructor(data, { x, y, ...options } = {}) {
    super(
      data,
      {
        x: { value: x, scale: "x", type: "band", optional: true },
        y: { value: y, scale: "y", type: "band", optional: true }
      },
      options,
      defaults10
    );
  }
  _transform(selection, mark) {
    selection.call(applyTransform, mark, {}, 0, 0);
  }
};
function cell(data, { x, y, ...options } = {}) {
  [x, y] = maybeTuple(x, y);
  return new Cell(data, { ...options, x, y });
}
function cellX(data, { x = indexOf, fill, stroke, ...options } = {}) {
  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0) fill = identity2;
  return new Cell(data, { ...options, x, fill, stroke });
}
function cellY(data, { y = indexOf, fill, stroke, ...options } = {}) {
  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0) fill = identity2;
  return new Cell(data, { ...options, y, fill, stroke });
}

// node_modules/@observablehq/plot/src/marks/dot.js
var defaults11 = {
  ariaLabel: "dot",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5
};
function withDefaultSort(options) {
  return options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: "-r" }, options) : options;
}
var Dot = class extends Mark {
  constructor(data, options = {}) {
    const { x, y, r, rotate, symbol: symbol2 = circle_default, frameAnchor } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);
    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        r: { value: vr, scale: "r", filter: positive, optional: true },
        rotate: { value: vrotate, optional: true },
        symbol: { value: vsymbol, scale: "auto", optional: true }
      },
      withDefaultSort(options),
      defaults11
    );
    this.r = cr;
    this.rotate = crotate;
    this.symbol = csymbol;
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    const { channels } = this;
    const { symbol: symbolChannel } = channels;
    if (symbolChannel) {
      const { fill: fillChannel, stroke: strokeChannel } = channels;
      symbolChannel.hint = {
        fill: fillChannel ? fillChannel.value === symbolChannel.value ? "color" : "currentColor" : this.fill ?? "currentColor",
        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? "color" : "currentColor" : this.stroke ?? "none"
      };
    }
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y: Y, r: R, rotate: A, symbol: S } = channels;
    const { r, rotate, symbol: symbol2 } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const circle2 = symbol2 === circle_default;
    const size = R ? void 0 : r * r * Math.PI;
    if (negative(r)) index = [];
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X && x, y: Y && y }).call(
      (g) => g.selectAll().data(index).enter().append(circle2 ? "circle" : "path").call(applyDirectStyles, this).call(
        circle2 ? (selection) => {
          selection.attr("cx", X ? (i) => X[i] : cx).attr("cy", Y ? (i) => Y[i] : cy).attr("r", R ? (i) => R[i] : r);
        } : (selection) => {
          selection.attr(
            "transform",
            template`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${A ? (i) => ` rotate(${A[i]})` : rotate ? ` rotate(${rotate})` : ``}`
          ).attr(
            "d",
            R && S ? (i) => {
              const p = pathRound();
              S[i].draw(p, R[i] * R[i] * Math.PI);
              return p;
            } : R ? (i) => {
              const p = pathRound();
              symbol2.draw(p, R[i] * R[i] * Math.PI);
              return p;
            } : S ? (i) => {
              const p = pathRound();
              S[i].draw(p, size);
              return p;
            } : (() => {
              const p = pathRound();
              symbol2.draw(p, size);
              return p;
            })()
          );
        }
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function dot(data, { x, y, ...options } = {}) {
  if (options.frameAnchor === void 0) [x, y] = maybeTuple(x, y);
  return new Dot(data, { ...options, x, y });
}
function dotX(data, { x = identity2, ...options } = {}) {
  return new Dot(data, maybeIntervalMidY({ ...options, x }));
}
function dotY(data, { y = identity2, ...options } = {}) {
  return new Dot(data, maybeIntervalMidX({ ...options, y }));
}
function circle(data, options) {
  return dot(data, { ...options, symbol: "circle" });
}
function hexagon(data, options) {
  return dot(data, { ...options, symbol: "hexagon" });
}

// node_modules/@observablehq/plot/src/marks/line.js
var defaults12 = {
  ariaLabel: "line",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Line = class extends Mark {
  constructor(data, options = {}) {
    const { x, y, z, curve, tension } = options;
    super(
      data,
      {
        x: { value: x, scale: "x" },
        y: { value: y, scale: "y" },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults12
    );
    this.z = z;
    this.curve = maybeCurveAuto(curve, tension);
    markers(this, options);
  }
  filter(index) {
    return index;
  }
  project(channels, values2, context) {
    if (this.curve !== curveAuto) {
      super.project(channels, values2, context);
    }
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X, y: Y } = channels;
    const { curve } = this;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
      (g) => g.selectAll().data(groupIndex(index, [X, Y], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels, context).attr(
        "d",
        curve === curveAuto && context.projection ? sphereLine(context.path(), X, Y) : line_default().curve(curve).defined((i) => i >= 0).x((i) => X[i]).y((i) => Y[i])
      )
    ).node();
  }
};
function sphereLine(path, X, Y) {
  X = coerceNumbers(X);
  Y = coerceNumbers(Y);
  return (I) => {
    let line2 = [];
    const lines = [line2];
    for (const i of I) {
      if (i === -1) {
        line2 = [];
        lines.push(line2);
      } else {
        line2.push([X[i], Y[i]]);
      }
    }
    return path({ type: "MultiLineString", coordinates: lines });
  };
}
function line(data, { x, y, ...options } = {}) {
  [x, y] = maybeTuple(x, y);
  return new Line(data, { ...options, x, y });
}
function lineX(data, { x = identity2, y = indexOf, ...options } = {}) {
  return new Line(data, maybeDenseIntervalY({ ...options, x, y }));
}
function lineY(data, { x = indexOf, y = identity2, ...options } = {}) {
  return new Line(data, maybeDenseIntervalX({ ...options, x, y }));
}

// node_modules/@observablehq/plot/src/marks/auto.js
function autoSpec(data, options) {
  options = normalizeOptions(options);
  const { x, y, color: color2, size } = options;
  const X = materializeValue(data, x);
  const Y = materializeValue(data, y);
  const C = materializeValue(data, color2);
  const S = materializeValue(data, size);
  let {
    fx,
    fy,
    x: { value: xValue, reduce: xReduce, zero: xZero, ...xOptions },
    y: { value: yValue, reduce: yReduce, zero: yZero, ...yOptions },
    color: { value: colorValue, color: colorColor, reduce: colorReduce },
    size: { value: sizeValue, reduce: sizeReduce },
    // TODO constant radius?
    mark
  } = options;
  if (xReduce === void 0)
    xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? "count" : null;
  if (yReduce === void 0)
    yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? "count" : null;
  if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X)) && (yValue == null || isOrdinal(Y))) {
    sizeReduce = "count";
  }
  if (xZero === void 0) xZero = isZeroReducer(xReduce) ? true : void 0;
  if (yZero === void 0) yZero = isZeroReducer(yReduce) ? true : void 0;
  if (xValue == null && yValue == null) throw new Error("must specify x or y");
  if (xReduce != null && yValue == null) throw new Error("reducing x requires y");
  if (yReduce != null && xValue == null) throw new Error("reducing y requires x");
  if (mark === void 0) {
    mark = sizeValue != null || sizeReduce != null ? "dot" : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null ? "bar" : xValue != null && yValue != null ? isOrdinal(X) || isOrdinal(Y) || xReduce == null && yReduce == null && !isMonotonic(X) && !isMonotonic(Y) ? "dot" : "line" : xValue != null || yValue != null ? "rule" : null;
  }
  let Z;
  let colorMode;
  let markImpl;
  switch (mark) {
    case "dot":
      markImpl = dot;
      colorMode = "stroke";
      break;
    case "line":
      markImpl = X && Y || xReduce != null || yReduce != null ? yZero || yReduce != null || X && isMonotonic(X) ? lineY : xZero || xReduce != null || Y && isMonotonic(Y) ? lineX : line : X ? lineX : lineY;
      colorMode = "stroke";
      if (isHighCardinality(C)) Z = null;
      break;
    case "area":
      markImpl = !(yZero || yReduce != null) && (xZero || xReduce != null || Y && isMonotonic(Y)) ? areaX : areaY;
      colorMode = "fill";
      if (isHighCardinality(C)) Z = null;
      break;
    case "rule":
      markImpl = X ? ruleX : ruleY;
      colorMode = "stroke";
      break;
    case "bar":
      markImpl = xReduce != null ? isOrdinal(Y) ? isSelectReducer(xReduce) && X && isOrdinal(X) ? cell : barX : rectX : yReduce != null ? isOrdinal(X) ? isSelectReducer(yReduce) && Y && isOrdinal(Y) ? cell : barY : rectY : colorReduce != null || sizeReduce != null ? X && isOrdinal(X) && Y && isOrdinal(Y) ? cell : X && isOrdinal(X) ? barY : Y && isOrdinal(Y) ? barX : rect : X && isNumeric(X) && !(Y && isNumeric(Y)) ? barX : Y && isNumeric(Y) && !(X && isNumeric(X)) ? barY : cell;
      colorMode = "fill";
      break;
    default:
      throw new Error(`invalid mark: ${mark}`);
  }
  let markOptions2 = {
    fx,
    fy,
    x: X ?? void 0,
    // treat null x as undefined for implicit stack
    y: Y ?? void 0,
    // treat null y as undefined for implicit stack
    [colorMode]: C ?? colorColor,
    z: Z,
    r: S ?? void 0,
    // treat null size as undefined for default constant radius
    tip: true
  };
  let transformImpl;
  let transformOptions = { [colorMode]: colorReduce ?? void 0, r: sizeReduce ?? void 0 };
  if (xReduce != null && yReduce != null) {
    throw new Error(`cannot reduce both x and y`);
  } else if (yReduce != null) {
    transformOptions.y = yReduce;
    transformImpl = isOrdinal(X) ? groupX : binX;
  } else if (xReduce != null) {
    transformOptions.x = xReduce;
    transformImpl = isOrdinal(Y) ? groupY : binY;
  } else if (colorReduce != null || sizeReduce != null) {
    if (X && Y) {
      transformImpl = isOrdinal(X) && isOrdinal(Y) ? group2 : isOrdinal(X) ? binY : isOrdinal(Y) ? binX : bin;
    } else if (X) {
      transformImpl = isOrdinal(X) ? groupX : binX;
    } else if (Y) {
      transformImpl = isOrdinal(Y) ? groupY : binY;
    }
  }
  if (transformImpl === bin || transformImpl === binX) markOptions2.x = { value: X, ...xOptions };
  if (transformImpl === bin || transformImpl === binY) markOptions2.y = { value: Y, ...yOptions };
  if (xZero === void 0)
    xZero = X && !(transformImpl === bin || transformImpl === binX) && (markImpl === barX || markImpl === areaX || markImpl === rectX || markImpl === ruleY);
  if (yZero === void 0)
    yZero = Y && !(transformImpl === bin || transformImpl === binY) && (markImpl === barY || markImpl === areaY || markImpl === rectY || markImpl === ruleX);
  return {
    fx: fx ?? null,
    fy: fy ?? null,
    x: {
      value: xValue ?? null,
      reduce: xReduce ?? null,
      zero: !!xZero,
      ...xOptions
    },
    y: {
      value: yValue ?? null,
      reduce: yReduce ?? null,
      zero: !!yZero,
      ...yOptions
    },
    color: {
      value: colorValue ?? null,
      reduce: colorReduce ?? null,
      ...colorColor !== void 0 && { color: colorColor }
    },
    size: {
      value: sizeValue ?? null,
      reduce: sizeReduce ?? null
    },
    mark,
    markImpl: implNames[markImpl],
    markOptions: markOptions2,
    transformImpl: implNames[transformImpl],
    transformOptions,
    colorMode
  };
}
function auto(data, options) {
  const spec = autoSpec(data, options);
  const {
    fx,
    fy,
    x: { zero: xZero },
    y: { zero: yZero },
    markOptions: markOptions2,
    transformOptions,
    colorMode
  } = spec;
  const markImpl = impls[spec.markImpl];
  const transformImpl = impls[spec.transformImpl];
  const frames = fx != null || fy != null ? frame({ strokeOpacity: 0.1 }) : null;
  const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];
  const mark = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions2) : markOptions2);
  return colorMode === "stroke" ? marks(frames, rules, mark) : marks(frames, mark, rules);
}
function isMonotonic(values2) {
  let previous;
  let previousOrder;
  for (const value of values2) {
    if (value == null) continue;
    if (previous === void 0) {
      previous = value;
      continue;
    }
    const order = Math.sign(ascending(previous, value));
    if (!order) continue;
    if (previousOrder !== void 0 && order !== previousOrder) return false;
    previous = value;
    previousOrder = order;
  }
  return true;
}
function normalizeOptions({ x, y, color: color2, size, fx, fy, mark } = {}) {
  if (!isOptions(x)) x = makeOptions(x);
  if (!isOptions(y)) y = makeOptions(y);
  if (!isOptions(color2)) color2 = isColor(color2) ? { color: color2 } : makeOptions(color2);
  if (!isOptions(size)) size = makeOptions(size);
  if (isOptions(fx)) ({ value: fx } = makeOptions(fx));
  if (isOptions(fy)) ({ value: fy } = makeOptions(fy));
  if (mark != null) mark = `${mark}`.toLowerCase();
  return { x, y, color: color2, size, fx, fy, mark };
}
function materializeValue(data, options) {
  const V = valueof(data, options.value);
  if (V) V.label = labelof(options.value);
  return V;
}
function makeOptions(value) {
  return isReducer(value) ? { reduce: value } : { value };
}
function isZeroReducer(reduce) {
  return /^(?:distinct|count|sum|proportion)$/i.test(reduce);
}
function isSelectReducer(reduce) {
  return /^(?:first|last|mode)$/i.test(reduce);
}
function isReducer(reduce) {
  if (reduce == null) return false;
  if (typeof reduce.reduceIndex === "function") return true;
  if (typeof reduce.reduce === "function" && isObject(reduce)) return true;
  if (/^p\d{2}$/i.test(reduce)) return true;
  switch (`${reduce}`.toLowerCase()) {
    case "first":
    case "last":
    case "count":
    case "distinct":
    case "sum":
    case "proportion":
    case "proportion-facet":
    case "deviation":
    case "min":
    case "min-index":
    case "max":
    case "max-index":
    case "mean":
    case "median":
    case "variance":
    case "mode":
      return true;
  }
  return false;
}
function isHighCardinality(value) {
  return value ? new InternSet(value).size > value.length >> 1 : false;
}
var impls = {
  dot,
  line,
  lineX,
  lineY,
  areaX,
  areaY,
  ruleX,
  ruleY,
  barX,
  barY,
  rect,
  rectX,
  rectY,
  cell,
  bin,
  binX,
  binY,
  group: group2,
  groupX,
  groupY
};
var implNames = Object.fromEntries(Object.entries(impls).map(([name, impl]) => [impl, name]));

// node_modules/@observablehq/plot/src/transforms/map.js
function mapX(mapper, options = {}) {
  let { x, x1, x2 } = options;
  if (x === void 0 && x1 === void 0 && x2 === void 0) options = { ...options, x: x = identity2 };
  const outputs = {};
  if (x != null) outputs.x = mapper;
  if (x1 != null) outputs.x1 = mapper;
  if (x2 != null) outputs.x2 = mapper;
  return map2(outputs, options);
}
function mapY(mapper, options = {}) {
  let { y, y1, y2 } = options;
  if (y === void 0 && y1 === void 0 && y2 === void 0) options = { ...options, y: y = identity2 };
  const outputs = {};
  if (y != null) outputs.y = mapper;
  if (y1 != null) outputs.y1 = mapper;
  if (y2 != null) outputs.y2 = mapper;
  return map2(outputs, options);
}
function map2(outputs = {}, options = {}) {
  const z = maybeZ(options);
  const channels = Object.entries(outputs).map(([key, map3]) => {
    const input = maybeInput(key, options);
    if (input == null) throw new Error(`missing channel: ${key}`);
    const [output, setOutput] = column(input);
    return { key, input, output, setOutput, map: maybeMap(map3) };
  });
  return {
    ...basic(options, (data, facets) => {
      const Z = valueof(data, z);
      const X = channels.map(({ input }) => valueof(data, input));
      const MX = channels.map(({ setOutput }) => setOutput(new Array(data.length)));
      for (const facet of facets) {
        for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
          channels.forEach(({ map: map3 }, i) => map3.mapIndex(I, X[i], MX[i]));
        }
      }
      return { data, facets };
    }),
    ...Object.fromEntries(channels.map(({ key, output }) => [key, output]))
  };
}
function maybeMap(map3) {
  if (map3 == null) throw new Error("missing map");
  if (typeof map3.mapIndex === "function") return map3;
  if (typeof map3.map === "function" && isObject(map3)) return mapMap(map3);
  if (typeof map3 === "function") return mapFunction(taker(map3));
  switch (`${map3}`.toLowerCase()) {
    case "cumsum":
      return mapCumsum;
    case "rank":
      return mapFunction((I, V) => rank(I, (i) => V[i]));
    case "quantile":
      return mapFunction((I, V) => rankQuantile(I, (i) => V[i]));
  }
  throw new Error(`invalid map: ${map3}`);
}
function mapMap(map3) {
  console.warn("deprecated map interface; implement mapIndex instead.");
  return { mapIndex: map3.map.bind(map3) };
}
function rankQuantile(I, f) {
  const n = count(I, f) - 1;
  return rank(I, f).map((r) => r / n);
}
function mapFunction(f) {
  return {
    mapIndex(I, S, T) {
      const M = f(I, S);
      if (M.length !== I.length) throw new Error("map function returned a mismatched length");
      for (let i = 0, n = I.length; i < n; ++i) T[I[i]] = M[i];
    }
  };
}
var mapCumsum = {
  mapIndex(I, S, T) {
    let sum2 = 0;
    for (const i of I) T[i] = sum2 += S[i];
  }
};

// node_modules/@observablehq/plot/src/transforms/window.js
function windowX(windowOptions = {}, options) {
  if (arguments.length === 1) options = windowOptions;
  return mapX(window2(windowOptions), options);
}
function windowY(windowOptions = {}, options) {
  if (arguments.length === 1) options = windowOptions;
  return mapY(window2(windowOptions), options);
}
function window2(options = {}) {
  if (typeof options === "number") options = { k: options };
  let { k, reduce, shift, anchor, strict } = options;
  if (anchor === void 0 && shift !== void 0) {
    anchor = maybeShift(shift);
    warn(`Warning: the shift option is deprecated; please use anchor "${anchor}" instead.`);
  }
  if (!((k = Math.floor(k)) > 0)) throw new Error(`invalid k: ${k}`);
  return maybeReduce2(reduce)(k, maybeAnchor3(anchor, k), strict);
}
function maybeAnchor3(anchor = "middle", k) {
  switch (`${anchor}`.toLowerCase()) {
    case "middle":
      return k - 1 >> 1;
    case "start":
      return 0;
    case "end":
      return k - 1;
  }
  throw new Error(`invalid anchor: ${anchor}`);
}
function maybeShift(shift) {
  switch (`${shift}`.toLowerCase()) {
    case "centered":
      return "middle";
    case "leading":
      return "start";
    case "trailing":
      return "end";
  }
  throw new Error(`invalid shift: ${shift}`);
}
function maybeReduce2(reduce = "mean") {
  if (typeof reduce === "string") {
    if (/^p\d{2}$/i.test(reduce)) return reduceAccessor2(percentile(reduce));
    switch (reduce.toLowerCase()) {
      case "deviation":
        return reduceAccessor2(deviation);
      case "max":
        return reduceArray((I, V) => max(I, (i) => V[i]));
      case "mean":
        return reduceMean;
      case "median":
        return reduceAccessor2(median);
      case "min":
        return reduceArray((I, V) => min(I, (i) => V[i]));
      case "mode":
        return reduceArray((I, V) => mode(I, (i) => V[i]));
      case "sum":
        return reduceSum2;
      case "variance":
        return reduceAccessor2(variance);
      case "difference":
        return reduceDifference;
      case "ratio":
        return reduceRatio;
      case "first":
        return reduceFirst2;
      case "last":
        return reduceLast2;
    }
  }
  if (typeof reduce !== "function") throw new Error(`invalid reduce: ${reduce}`);
  return reduceArray(taker(reduce));
}
function reduceAccessor2(f) {
  return (k, s, strict) => strict ? {
    mapIndex(I, S, T) {
      const v = (i) => S[i] == null ? NaN : +S[i];
      let nans = 0;
      for (let i = 0; i < k - 1; ++i) if (isNaN(v(i))) ++nans;
      for (let i = 0, n = I.length - k + 1; i < n; ++i) {
        if (isNaN(v(i + k - 1))) ++nans;
        T[I[i + s]] = nans === 0 ? f(subarray(I, i, i + k), v) : NaN;
        if (isNaN(v(i))) --nans;
      }
    }
  } : {
    mapIndex(I, S, T) {
      const v = (i) => S[i] == null ? NaN : +S[i];
      for (let i = -s; i < 0; ++i) {
        T[I[i + s]] = f(subarray(I, 0, i + k), v);
      }
      for (let i = 0, n = I.length - s; i < n; ++i) {
        T[I[i + s]] = f(subarray(I, i, i + k), v);
      }
    }
  };
}
function reduceArray(f) {
  return (k, s, strict) => strict ? {
    mapIndex(I, S, T) {
      let count2 = 0;
      for (let i = 0; i < k - 1; ++i) count2 += defined(S[I[i]]);
      for (let i = 0, n = I.length - k + 1; i < n; ++i) {
        count2 += defined(S[I[i + k - 1]]);
        if (count2 === k) T[I[i + s]] = f(subarray(I, i, i + k), S);
        count2 -= defined(S[I[i]]);
      }
    }
  } : {
    mapIndex(I, S, T) {
      for (let i = -s; i < 0; ++i) {
        T[I[i + s]] = f(subarray(I, 0, i + k), S);
      }
      for (let i = 0, n = I.length - s; i < n; ++i) {
        T[I[i + s]] = f(subarray(I, i, i + k), S);
      }
    }
  };
}
function reduceSum2(k, s, strict) {
  return strict ? {
    mapIndex(I, S, T) {
      let nans = 0;
      let sum2 = 0;
      for (let i = 0; i < k - 1; ++i) {
        const v = S[I[i]];
        if (v === null || isNaN(v)) ++nans;
        else sum2 += +v;
      }
      for (let i = 0, n = I.length - k + 1; i < n; ++i) {
        const a = S[I[i]];
        const b = S[I[i + k - 1]];
        if (b === null || isNaN(b)) ++nans;
        else sum2 += +b;
        T[I[i + s]] = nans === 0 ? sum2 : NaN;
        if (a === null || isNaN(a)) --nans;
        else sum2 -= +a;
      }
    }
  } : {
    mapIndex(I, S, T) {
      let sum2 = 0;
      const n = I.length;
      for (let i = 0, j = Math.min(n, k - s - 1); i < j; ++i) {
        sum2 += +S[I[i]] || 0;
      }
      for (let i = -s, j = n - s; i < j; ++i) {
        sum2 += +S[I[i + k - 1]] || 0;
        T[I[i + s]] = sum2;
        sum2 -= +S[I[i]] || 0;
      }
    }
  };
}
function reduceMean(k, s, strict) {
  if (strict) {
    const sum2 = reduceSum2(k, s, strict);
    return {
      mapIndex(I, S, T) {
        sum2.mapIndex(I, S, T);
        for (let i = 0, n = I.length - k + 1; i < n; ++i) {
          T[I[i + s]] /= k;
        }
      }
    };
  } else {
    return {
      mapIndex(I, S, T) {
        let sum2 = 0;
        let count2 = 0;
        const n = I.length;
        for (let i = 0, j = Math.min(n, k - s - 1); i < j; ++i) {
          let v = S[I[i]];
          if (v !== null && !isNaN(v = +v)) sum2 += v, ++count2;
        }
        for (let i = -s, j = n - s; i < j; ++i) {
          let a = S[I[i + k - 1]];
          let b = S[I[i]];
          if (a !== null && !isNaN(a = +a)) sum2 += a, ++count2;
          T[I[i + s]] = sum2 / count2;
          if (b !== null && !isNaN(b = +b)) sum2 -= b, --count2;
        }
      }
    };
  }
}
function firstDefined(S, I, i, k) {
  for (let j = i + k; i < j; ++i) {
    const v = S[I[i]];
    if (defined(v)) return v;
  }
}
function lastDefined(S, I, i, k) {
  for (let j = i + k - 1; j >= i; --j) {
    const v = S[I[j]];
    if (defined(v)) return v;
  }
}
function firstNumber(S, I, i, k) {
  for (let j = i + k; i < j; ++i) {
    let v = S[I[i]];
    if (v !== null && !isNaN(v = +v)) return v;
  }
}
function lastNumber(S, I, i, k) {
  for (let j = i + k - 1; j >= i; --j) {
    let v = S[I[j]];
    if (v !== null && !isNaN(v = +v)) return v;
  }
}
function reduceDifference(k, s, strict) {
  return strict ? {
    mapIndex(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        const a = S[I[i]];
        const b = S[I[i + k - 1]];
        T[I[i + s]] = a === null || b === null ? NaN : b - a;
      }
    }
  } : {
    mapIndex(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = lastNumber(S, I, i, k) - firstNumber(S, I, i, k);
      }
    }
  };
}
function reduceRatio(k, s, strict) {
  return strict ? {
    mapIndex(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        const a = S[I[i]];
        const b = S[I[i + k - 1]];
        T[I[i + s]] = a === null || b === null ? NaN : b / a;
      }
    }
  } : {
    mapIndex(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = lastNumber(S, I, i, k) / firstNumber(S, I, i, k);
      }
    }
  };
}
function reduceFirst2(k, s, strict) {
  return strict ? {
    mapIndex(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        T[I[i + s]] = S[I[i]];
      }
    }
  } : {
    mapIndex(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = firstDefined(S, I, i, k);
      }
    }
  };
}
function reduceLast2(k, s, strict) {
  return strict ? {
    mapIndex(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        T[I[i + s]] = S[I[i + k - 1]];
      }
    }
  } : {
    mapIndex(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = lastDefined(S, I, i, k);
      }
    }
  };
}

// node_modules/@observablehq/plot/src/marks/bollinger.js
var defaults13 = {
  n: 20,
  k: 2,
  color: "currentColor",
  opacity: 0.2,
  strict: true,
  anchor: "end"
};
function bollingerX(data, {
  x = identity2,
  y,
  k = defaults13.k,
  color: color2 = defaults13.color,
  opacity: opacity2 = defaults13.opacity,
  fill = color2,
  fillOpacity = opacity2,
  stroke = color2,
  strokeOpacity,
  strokeWidth,
  ...options
} = {}) {
  return marks(
    isNoneish(fill) ? null : areaX(
      data,
      map2(
        { x1: bollinger({ k: -k, ...options }), x2: bollinger({ k, ...options }) },
        { x1: x, x2: x, y, fill, fillOpacity, ...options }
      )
    ),
    isNoneish(stroke) ? null : lineX(data, map2({ x: bollinger(options) }, { x, y, stroke, strokeOpacity, strokeWidth, ...options }))
  );
}
function bollingerY(data, {
  x,
  y = identity2,
  k = defaults13.k,
  color: color2 = defaults13.color,
  opacity: opacity2 = defaults13.opacity,
  fill = color2,
  fillOpacity = opacity2,
  stroke = color2,
  strokeOpacity,
  strokeWidth,
  ...options
} = {}) {
  return marks(
    isNoneish(fill) ? null : areaY(
      data,
      map2(
        { y1: bollinger({ k: -k, ...options }), y2: bollinger({ k, ...options }) },
        { x, y1: y, y2: y, fill, fillOpacity, ...options }
      )
    ),
    isNoneish(stroke) ? null : lineY(data, map2({ y: bollinger(options) }, { x, y, stroke, strokeOpacity, strokeWidth, ...options }))
  );
}
function bollinger({ n = defaults13.n, k = 0, strict = defaults13.strict, anchor = defaults13.anchor } = {}) {
  return window2({ k: n, reduce: (Y) => mean(Y) + k * (deviation(Y) || 0), strict, anchor });
}

// node_modules/@observablehq/plot/src/marks/tick.js
var defaults14 = {
  ariaLabel: "tick",
  fill: null,
  stroke: "currentColor"
};
var AbstractTick = class extends Mark {
  constructor(data, channels, options) {
    super(data, channels, options, defaults14);
    markers(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
      (g) => g.selectAll().data(index).enter().append("line").call(applyDirectStyles, this).attr("x1", this._x1(scales, channels, dimensions)).attr("x2", this._x2(scales, channels, dimensions)).attr("y1", this._y1(scales, channels, dimensions)).attr("y2", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
var TickX = class extends AbstractTick {
  constructor(data, options = {}) {
    const { x, y, inset = 0, insetTop = inset, insetBottom = inset } = options;
    super(
      data,
      {
        x: { value: x, scale: "x" },
        y: { value: y, scale: "y", type: "band", optional: true }
      },
      options
    );
    this.insetTop = number(insetTop);
    this.insetBottom = number(insetBottom);
  }
  _transform(selection, mark, { x }) {
    selection.call(applyTransform, mark, { x }, offset, 0);
  }
  _x1(scales, { x: X }) {
    return (i) => X[i];
  }
  _x2(scales, { x: X }) {
    return (i) => X[i];
  }
  _y1({ y }, { y: Y }, { marginTop }) {
    const { insetTop } = this;
    return Y && y ? (i) => Y[i] + insetTop : marginTop + insetTop;
  }
  _y2({ y }, { y: Y }, { height, marginBottom }) {
    const { insetBottom } = this;
    return Y && y ? (i) => Y[i] + y.bandwidth() - insetBottom : height - marginBottom - insetBottom;
  }
};
var TickY = class extends AbstractTick {
  constructor(data, options = {}) {
    const { x, y, inset = 0, insetRight = inset, insetLeft = inset } = options;
    super(
      data,
      {
        y: { value: y, scale: "y" },
        x: { value: x, scale: "x", type: "band", optional: true }
      },
      options
    );
    this.insetRight = number(insetRight);
    this.insetLeft = number(insetLeft);
  }
  _transform(selection, mark, { y }) {
    selection.call(applyTransform, mark, { y }, 0, offset);
  }
  _x1({ x }, { x: X }, { marginLeft }) {
    const { insetLeft } = this;
    return X && x ? (i) => X[i] + insetLeft : marginLeft + insetLeft;
  }
  _x2({ x }, { x: X }, { width, marginRight }) {
    const { insetRight } = this;
    return X && x ? (i) => X[i] + x.bandwidth() - insetRight : width - marginRight - insetRight;
  }
  _y1(scales, { y: Y }) {
    return (i) => Y[i];
  }
  _y2(scales, { y: Y }) {
    return (i) => Y[i];
  }
};
function tickX(data, { x = identity2, ...options } = {}) {
  return new TickX(data, { ...options, x });
}
function tickY(data, { y = identity2, ...options } = {}) {
  return new TickY(data, { ...options, y });
}

// node_modules/@observablehq/plot/src/marks/box.js
function boxX(data, {
  x = identity2,
  y = null,
  r,
  fill = "#ccc",
  fillOpacity,
  stroke = "currentColor",
  strokeOpacity,
  strokeWidth = 2,
  sort: sort3,
  ...options
} = {}) {
  const group3 = y != null ? groupY : groupZ;
  return marks(
    ruleY(data, group3({ x1: loqr1, x2: hiqr2 }, { x, y, stroke, strokeOpacity, ...options })),
    barX(data, group3({ x1: "p25", x2: "p75" }, { x, y, fill, fillOpacity, ...options })),
    tickX(data, group3({ x: "p50" }, { x, y, stroke, strokeOpacity, strokeWidth, sort: sort3, ...options })),
    dot(data, map2({ x: oqr }, { x, y, z: y, r, stroke, strokeOpacity, ...options }))
  );
}
function boxY(data, {
  y = identity2,
  x = null,
  r,
  fill = "#ccc",
  fillOpacity,
  stroke = "currentColor",
  strokeOpacity,
  strokeWidth = 2,
  sort: sort3,
  ...options
} = {}) {
  const group3 = x != null ? groupX : groupZ;
  return marks(
    ruleX(data, group3({ y1: loqr1, y2: hiqr2 }, { x, y, stroke, strokeOpacity, ...options })),
    barY(data, group3({ y1: "p25", y2: "p75" }, { x, y, fill, fillOpacity, ...options })),
    tickY(data, group3({ y: "p50" }, { x, y, stroke, strokeOpacity, strokeWidth, sort: sort3, ...options })),
    dot(data, map2({ y: oqr }, { x, y, z: x, r, stroke, strokeOpacity, ...options }))
  );
}
function oqr(values2) {
  const r1 = loqr1(values2);
  const r2 = hiqr2(values2);
  return values2.map((v) => v < r1 || v > r2 ? v : NaN);
}
function loqr1(values2) {
  const lo = quartile1(values2) * 2.5 - quartile3(values2) * 1.5;
  return min(values2, (d) => d >= lo ? d : NaN);
}
function hiqr2(values2) {
  const hi = quartile3(values2) * 2.5 - quartile1(values2) * 1.5;
  return max(values2, (d) => d <= hi ? d : NaN);
}
function quartile1(values2) {
  return quantile(values2, 0.25);
}
function quartile3(values2) {
  return quantile(values2, 0.75);
}

// node_modules/@observablehq/plot/src/marks/raster.js
var defaults15 = {
  ariaLabel: "raster",
  stroke: null,
  pixelSize: 1
};
function number2(input, name) {
  const x = +input;
  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);
  return x;
}
function integer(input, name) {
  const x = Math.floor(input);
  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);
  return x;
}
var AbstractRaster = class extends Mark {
  constructor(data, channels, options = {}, defaults22) {
    let {
      width,
      height,
      x,
      y,
      x1 = x == null ? 0 : void 0,
      y1 = y == null ? 0 : void 0,
      x2 = x == null ? width : void 0,
      y2 = y == null ? height : void 0,
      pixelSize = defaults22.pixelSize,
      blur = 0,
      interpolate
    } = options;
    if (width != null) width = integer(width, "width");
    if (height != null) height = integer(height, "height");
    if (x1 != null) x1 = number2(x1, "x1");
    if (y1 != null) y1 = number2(y1, "y1");
    if (x2 != null) x2 = number2(x2, "x2");
    if (y2 != null) y2 = number2(y2, "y2");
    if (x == null && (x1 == null || x2 == null)) throw new Error("missing x");
    if (y == null && (y1 == null || y2 == null)) throw new Error("missing y");
    if (data != null && width != null && height != null) {
      if (x === void 0 && x1 != null && x2 != null) x = denseX(x1, x2, width, height);
      if (y === void 0 && y1 != null && y2 != null) y = denseY(y1, y2, width, height);
    }
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        x1: { value: x1 == null ? null : [x1], scale: "x", optional: true, filter: null },
        y1: { value: y1 == null ? null : [y1], scale: "y", optional: true, filter: null },
        x2: { value: x2 == null ? null : [x2], scale: "x", optional: true, filter: null },
        y2: { value: y2 == null ? null : [y2], scale: "y", optional: true, filter: null },
        ...channels
      },
      options,
      defaults22
    );
    this.width = width;
    this.height = height;
    this.pixelSize = number2(pixelSize, "pixelSize");
    this.blur = number2(blur, "blur");
    this.interpolate = x == null || y == null ? null : maybeInterpolate(interpolate);
  }
};
var Raster = class extends AbstractRaster {
  constructor(data, options = {}) {
    const { imageRendering } = options;
    if (data == null) {
      const { fill, fillOpacity } = options;
      if (maybeNumberChannel(fillOpacity)[0] !== void 0) options = sampler("fillOpacity", options);
      if (maybeColorChannel(fill)[0] !== void 0) options = sampler("fill", options);
    }
    super(data, void 0, options, defaults15);
    this.imageRendering = impliedString(imageRendering, "auto");
  }
  // Ignore the color scale, so the fill channel is returned unscaled.
  scale(channels, { color: color2, ...scales }, context) {
    return super.scale(channels, scales, context);
  }
  render(index, scales, values2, dimensions, context) {
    var _a;
    const color2 = scales[(_a = values2.channels.fill) == null ? void 0 : _a.scale] ?? ((x) => x);
    const { x: X, y: Y } = values2;
    const { document } = context;
    const [x1, y1, x2, y2] = renderBounds(values2, dimensions, context);
    const dx = x2 - x1;
    const dy = y2 - y1;
    const { pixelSize: k, width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k) } = this;
    const n = w * h;
    let { fill: F, fillOpacity: FO } = values2;
    let offset2 = 0;
    if (this.interpolate) {
      const kx = w / dx;
      const ky = h / dy;
      const IX = map(X, (x) => (x - x1) * kx, Float64Array);
      const IY = map(Y, (y) => (y - y1) * ky, Float64Array);
      if (F) F = this.interpolate(index, w, h, IX, IY, F);
      if (FO) FO = this.interpolate(index, w, h, IX, IY, FO);
    } else if (this.data == null && index) offset2 = index.fi * n;
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const context2d = canvas.getContext("2d");
    const image2 = context2d.createImageData(w, h);
    const imageData = image2.data;
    let { r, g, b } = rgb(this.fill) ?? { r: 0, g: 0, b: 0 };
    let a = (this.fillOpacity ?? 1) * 255;
    for (let i = 0; i < n; ++i) {
      const j = i << 2;
      if (F) {
        const fi = color2(F[i + offset2]);
        if (fi == null) {
          imageData[j + 3] = 0;
          continue;
        }
        ({ r, g, b } = rgb(fi));
      }
      if (FO) a = FO[i + offset2] * 255;
      imageData[j + 0] = r;
      imageData[j + 1] = g;
      imageData[j + 2] = b;
      imageData[j + 3] = a;
    }
    if (this.blur > 0) blurImage(image2, this.blur);
    context2d.putImageData(image2, 0, 0);
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
      (g2) => g2.append("image").attr("transform", `translate(${x1},${y1}) scale(${Math.sign(x2 - x1)},${Math.sign(y2 - y1)})`).attr("width", Math.abs(dx)).attr("height", Math.abs(dy)).attr("preserveAspectRatio", "none").call(applyAttr, "image-rendering", this.imageRendering).call(applyDirectStyles, this).attr("xlink:href", canvas.toDataURL())
    ).node();
  }
};
function maybeTuples(k, data, options) {
  if (arguments.length < 3) options = data, data = null;
  let { x, y, [k]: z, ...rest } = options;
  if (x === void 0 && y === void 0 && isTuples(data)) {
    x = first, y = second2;
    if (z === void 0) z = third;
  }
  return [data, { ...rest, x, y, [k]: z }];
}
function raster() {
  const [data, options] = maybeTuples("fill", ...arguments);
  return new Raster(
    data,
    data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : { ...options, fill: identity2 }
  );
}
function renderBounds({ x1, y1, x2, y2 }, dimensions, { projection: projection2 }) {
  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;
  return [
    x1 && projection2 == null ? x1[0] : marginLeft,
    y1 && projection2 == null ? y1[0] : marginTop,
    x2 && projection2 == null ? x2[0] : width - marginRight,
    y2 && projection2 == null ? y2[0] : height - marginBottom
  ];
}
function rasterBounds({ x1, y1, x2, y2 }, scales, dimensions, context) {
  const channels = {};
  if (x1) channels.x1 = x1;
  if (y1) channels.y1 = y1;
  if (x2) channels.x2 = x2;
  if (y2) channels.y2 = y2;
  return renderBounds(valueObject(channels, scales), dimensions, context);
}
function sampler(name, options = {}) {
  const { [name]: value } = options;
  if (typeof value !== "function") throw new Error(`invalid ${name}: not a function`);
  return initializer({ ...options, [name]: void 0 }, function(data, facets, channels, scales, dimensions, context) {
    const { x, y } = scales;
    if (!x) throw new Error("missing scale: x");
    if (!y) throw new Error("missing scale: y");
    const [x1, y1, x2, y2] = rasterBounds(channels, scales, dimensions, context);
    const dx = x2 - x1;
    const dy = y2 - y1;
    const { pixelSize: k } = this;
    const { width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k) } = options;
    const V = new Array(w * h * (facets ? facets.length : 1));
    const kx = dx / w;
    const ky = dy / h;
    let i = 0;
    for (const facet of facets ?? [void 0]) {
      for (let yi = 0.5; yi < h; ++yi) {
        for (let xi = 0.5; xi < w; ++xi, ++i) {
          V[i] = value(x.invert(x1 + xi * kx), y.invert(y1 + yi * ky), facet);
        }
      }
    }
    return { data: V, facets, channels: { [name]: { value: V, scale: "auto" } } };
  });
}
function maybeInterpolate(interpolate) {
  if (typeof interpolate === "function") return interpolate;
  if (interpolate == null) return interpolateNone;
  switch (`${interpolate}`.toLowerCase()) {
    case "none":
      return interpolateNone;
    case "nearest":
      return interpolateNearest;
    case "barycentric":
      return interpolatorBarycentric();
    case "random-walk":
      return interpolatorRandomWalk();
  }
  throw new Error(`invalid interpolate: ${interpolate}`);
}
function interpolateNone(index, width, height, X, Y, V) {
  const W = new Array(width * height);
  for (const i of index) {
    if (X[i] < 0 || X[i] >= width || Y[i] < 0 || Y[i] >= height) continue;
    W[Math.floor(Y[i]) * width + Math.floor(X[i])] = V[i];
  }
  return W;
}
function interpolatorBarycentric({ random = lcg(42) } = {}) {
  return (index, width, height, X, Y, V) => {
    const { points, triangles, hull: hull2 } = Delaunay.from(
      index,
      (i) => X[i],
      (i) => Y[i]
    );
    const W = new V.constructor(width * height).fill(NaN);
    const S = new Uint8Array(width * height);
    const mix = mixer(V, random);
    for (let i = 0; i < triangles.length; i += 3) {
      const ta = triangles[i];
      const tb = triangles[i + 1];
      const tc = triangles[i + 2];
      const Ax = points[2 * ta];
      const Bx = points[2 * tb];
      const Cx = points[2 * tc];
      const Ay = points[2 * ta + 1];
      const By = points[2 * tb + 1];
      const Cy = points[2 * tc + 1];
      const x1 = Math.min(Ax, Bx, Cx);
      const x2 = Math.max(Ax, Bx, Cx);
      const y1 = Math.min(Ay, By, Cy);
      const y2 = Math.max(Ay, By, Cy);
      const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);
      if (!z) continue;
      const va = V[index[ta]];
      const vb = V[index[tb]];
      const vc = V[index[tc]];
      for (let x = Math.floor(x1); x < x2; ++x) {
        for (let y = Math.floor(y1); y < y2; ++y) {
          if (x < 0 || x >= width || y < 0 || y >= height) continue;
          const xp = x + 0.5;
          const yp = y + 0.5;
          const s = Math.sign(z);
          const ga = (By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx);
          if (ga * s < 0) continue;
          const gb = (Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx);
          if (gb * s < 0) continue;
          const gc = z - (ga + gb);
          if (gc * s < 0) continue;
          const i2 = x + width * y;
          W[i2] = mix(va, ga / z, vb, gb / z, vc, gc / z, x, y);
          S[i2] = 1;
        }
      }
    }
    extrapolateBarycentric(W, S, X, Y, V, width, height, hull2, index, mix);
    return W;
  };
}
function extrapolateBarycentric(W, S, X, Y, V, width, height, hull2, index, mix) {
  X = Float64Array.from(hull2, (i) => X[index[i]]);
  Y = Float64Array.from(hull2, (i) => Y[index[i]]);
  V = Array.from(hull2, (i) => V[index[i]]);
  const n = X.length;
  const rays = Array.from({ length: n }, (_, j) => ray(j, X, Y));
  let k = 0;
  for (let y = 0; y < height; ++y) {
    const yp = y + 0.5;
    for (let x = 0; x < width; ++x) {
      const i = x + width * y;
      if (!S[i]) {
        const xp = x + 0.5;
        for (let l = 0; l < n; ++l) {
          const j = (n + k + (l % 2 ? (l + 1) / 2 : -l / 2)) % n;
          if (rays[j](xp, yp)) {
            const t = segmentProject(X.at(j - 1), Y.at(j - 1), X[j], Y[j], xp, yp);
            W[i] = mix(V.at(j - 1), t, V[j], 1 - t, V[j], 0, x, y);
            k = j;
            break;
          }
        }
      }
    }
  }
}
function segmentProject(x1, y1, x2, y2, x, y) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const a = dx * (x2 - x) + dy * (y2 - y);
  const b = dx * (x - x1) + dy * (y - y1);
  return a > 0 && b > 0 ? a / (a + b) : +(a > b);
}
function cross2(xa, ya, xb, yb) {
  return xa * yb - xb * ya;
}
function ray(j, X, Y) {
  const n = X.length;
  const xc = X.at(j - 2);
  const yc = Y.at(j - 2);
  const xa = X.at(j - 1);
  const ya = Y.at(j - 1);
  const xb = X[j];
  const yb = Y[j];
  const xd = X.at(j + 1 - n);
  const yd = Y.at(j + 1 - n);
  const dxab = xa - xb;
  const dyab = ya - yb;
  const dxca = xc - xa;
  const dyca = yc - ya;
  const dxbd = xb - xd;
  const dybd = yb - yd;
  const hab = Math.hypot(dxab, dyab);
  const hca = Math.hypot(dxca, dyca);
  const hbd = Math.hypot(dxbd, dybd);
  return (x, y) => {
    const dxa = x - xa;
    const dya = y - ya;
    const dxb = x - xb;
    const dyb = y - yb;
    return cross2(dxa, dya, dxb, dyb) > -1e-6 && cross2(dxa, dya, dxab, dyab) * hca - cross2(dxa, dya, dxca, dyca) * hab > -1e-6 && cross2(dxb, dyb, dxbd, dybd) * hab - cross2(dxb, dyb, dxab, dyab) * hbd <= 0;
  };
}
function interpolateNearest(index, width, height, X, Y, V) {
  const W = new V.constructor(width * height);
  const delaunay = Delaunay.from(
    index,
    (i) => X[i],
    (i) => Y[i]
  );
  let iy, ix;
  for (let y = 0.5, k = 0; y < height; ++y) {
    ix = iy;
    for (let x = 0.5; x < width; ++x, ++k) {
      ix = delaunay.find(x, y, ix);
      if (x === 0.5) iy = ix;
      W[k] = V[index[ix]];
    }
  }
  return W;
}
function interpolatorRandomWalk({ random = lcg(42), minDistance = 0.5, maxSteps = 2 } = {}) {
  return (index, width, height, X, Y, V) => {
    const W = new V.constructor(width * height);
    const delaunay = Delaunay.from(
      index,
      (i) => X[i],
      (i) => Y[i]
    );
    let iy, ix, iw;
    for (let y = 0.5, k = 0; y < height; ++y) {
      ix = iy;
      for (let x = 0.5; x < width; ++x, ++k) {
        let cx = x;
        let cy = y;
        iw = ix = delaunay.find(cx, cy, ix);
        if (x === 0.5) iy = ix;
        let distance;
        let step = 0;
        while ((distance = Math.hypot(X[index[iw]] - cx, Y[index[iw]] - cy)) > minDistance && step < maxSteps) {
          const angle = random(x, y, step) * 2 * Math.PI;
          cx += Math.cos(angle) * distance;
          cy += Math.sin(angle) * distance;
          iw = delaunay.find(cx, cy, iw);
          ++step;
        }
        W[k] = V[index[iw]];
      }
    }
    return W;
  };
}
function blend(a, ca, b, cb, c, cc) {
  return ca * a + cb * b + cc * c;
}
function pick(random) {
  return (a, ca, b, cb, c, cc, x, y) => {
    const u = random(x, y);
    return u < ca ? a : u < ca + cb ? b : c;
  };
}
function mixer(F, random) {
  return isNumeric(F) || isTemporal(F) ? blend : pick(random);
}
function denseX(x1, x2, width) {
  return {
    transform(data) {
      const n = data.length;
      const X = new Float64Array(n);
      const kx = (x2 - x1) / width;
      const x0 = x1 + kx / 2;
      for (let i = 0; i < n; ++i) X[i] = i % width * kx + x0;
      return X;
    }
  };
}
function denseY(y1, y2, width, height) {
  return {
    transform(data) {
      const n = data.length;
      const Y = new Float64Array(n);
      const ky = (y2 - y1) / height;
      const y0 = y1 + ky / 2;
      for (let i = 0; i < n; ++i) Y[i] = Math.floor(i / width) % height * ky + y0;
      return Y;
    }
  };
}

// node_modules/@observablehq/plot/src/marks/contour.js
var defaults16 = {
  ariaLabel: "contour",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1,
  pixelSize: 2
};
var Contour = class extends AbstractRaster {
  constructor(data, { smooth = true, value, ...options } = {}) {
    const channels = styles({}, options, defaults16);
    if (value === void 0) {
      for (const key in channels) {
        if (channels[key].value != null) {
          if (value !== void 0) throw new Error("ambiguous contour value");
          value = options[key];
          options[key] = "value";
        }
      }
    }
    if (value != null) {
      const v = { transform: (D) => D.map((d) => d.value), label: labelof(value) };
      for (const key in channels) {
        if (options[key] === "value") {
          options[key] = v;
        }
      }
    }
    if (data == null) {
      if (value == null) throw new Error("missing contour value");
      options = sampler("value", { value, ...options });
      value = null;
    } else {
      let { interpolate } = options;
      if (value === void 0) value = identity2;
      if (interpolate === void 0) options.interpolate = "nearest";
    }
    super(data, { value: { value, optional: true } }, contourGeometry(options), defaults16);
    const contourChannels = { geometry: { value: identity2 } };
    for (const key in this.channels) {
      const channel = this.channels[key];
      const { scale: scale2 } = channel;
      if (scale2 === "x" || scale2 === "y" || key === "value") continue;
      contourChannels[key] = channel;
      delete this.channels[key];
    }
    this.contourChannels = contourChannels;
    this.smooth = !!smooth;
  }
  filter(index, { x, y, value, ...channels }, values2) {
    return super.filter(index, channels, values2);
  }
  render(index, scales, channels, dimensions, context) {
    const { geometry: G } = channels;
    const path = path_default();
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {
      g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => path(G[i])).call(applyChannelStyles, this, channels);
    }).node();
  }
};
function contourGeometry({ thresholds, interval, ...options }) {
  thresholds = maybeThresholds(thresholds, interval, thresholdSturges);
  return initializer(options, function(data, facets, channels, scales, dimensions, context) {
    const [x1, y1, x2, y2] = rasterBounds(channels, scales, dimensions, context);
    const dx = x2 - x1;
    const dy = y2 - y1;
    const { pixelSize: k, width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k) } = this;
    const kx = w / dx;
    const ky = h / dy;
    const V = channels.value.value;
    const VV = [];
    if (this.interpolate) {
      const { x: X, y: Y } = applyPosition(channels, scales, context);
      const IX = map(X, (x) => (x - x1) * kx, Float64Array);
      const IY = map(Y, (y) => (y - y1) * ky, Float64Array);
      const ichannels = [channels.x, channels.y, channels.value];
      const ivalues = [IX, IY, V];
      for (const facet of facets) {
        const index = this.filter(facet, ichannels, ivalues);
        VV.push(this.interpolate(index, w, h, IX, IY, V));
      }
    } else if (facets) {
      const n = w * h;
      const m = facets.length;
      for (let i = 0; i < m; ++i) VV.push(V.slice(i * n, i * n + n));
    } else {
      VV.push(V);
    }
    if (this.blur > 0) for (const V2 of VV) blur2({ data: V2, width: w, height: h }, this.blur);
    const T = maybeTicks(thresholds, V, ...finiteExtent(VV));
    if (T === null) throw new Error(`unsupported thresholds: ${thresholds}`);
    const { contour: contour2 } = contours_default().size([w, h]).smooth(this.smooth);
    const contourData = [];
    const contourFacets = [];
    for (const V2 of VV) {
      contourFacets.push(range(contourData.length, contourData.push(...map(T, (t) => contour2(V2, t)))));
    }
    for (const { coordinates } of contourData) {
      for (const rings of coordinates) {
        for (const ring of rings) {
          for (const point2 of ring) {
            point2[0] = point2[0] / kx + x1;
            point2[1] = point2[1] / ky + y1;
          }
        }
      }
    }
    return {
      data: contourData,
      facets: contourFacets,
      channels: createChannels(this.contourChannels, contourData)
    };
  });
}
function maybeTicks(thresholds, V, min2, max2) {
  if (typeof (thresholds == null ? void 0 : thresholds.range) === "function") return thresholds.range(thresholds.floor(min2), max2);
  if (typeof thresholds === "function") thresholds = thresholds(V, min2, max2);
  if (typeof thresholds !== "number") return arrayify(thresholds);
  const tz = ticks(...nice(min2, max2, thresholds), thresholds);
  while (tz[tz.length - 1] >= max2) tz.pop();
  while (tz[1] < min2) tz.shift();
  return tz;
}
function contour() {
  return new Contour(...maybeTuples("value", ...arguments));
}
function finiteExtent(VV) {
  return [min(VV, (V) => min(V, finite2)), max(VV, (V) => max(V, finite2))];
}
function finite2(x) {
  return isFinite(x) ? x : NaN;
}

// node_modules/@observablehq/plot/src/marks/crosshair.js
function crosshair(data, options) {
  return crosshairK(pointer, data, options);
}
function crosshairX(data, options = {}) {
  return crosshairK(pointerX, data, options);
}
function crosshairY(data, options = {}) {
  return crosshairK(pointerY, data, options);
}
function crosshairK(pointer2, data, options = {}) {
  const { x, y, maxRadius } = options;
  const p = pointer2({ px: x, py: y, maxRadius });
  const M = [];
  if (x != null) M.push(ruleX(data, ruleOptions("x", { ...p, inset: -6 }, options)));
  if (y != null) M.push(ruleY(data, ruleOptions("y", { ...p, inset: -6 }, options)));
  if (x != null) M.push(text(data, textOptions("x", { ...p, dy: 9, frameAnchor: "bottom", lineAnchor: "top" }, options)));
  if (y != null) M.push(text(data, textOptions("y", { ...p, dx: -9, frameAnchor: "left", textAnchor: "end" }, options)));
  for (const m of M) m.ariaLabel = `crosshair ${m.ariaLabel}`;
  return marks(...M);
}
function markOptions(k, { channels: pointerChannels, ...pointerOptions }, { facet, facetAnchor, fx, fy, [k]: p, channels, transform, initializer: initializer2 }) {
  return {
    ...pointerOptions,
    facet,
    facetAnchor,
    fx,
    fy,
    [k]: p,
    channels: { ...pointerChannels, ...channels },
    transform,
    initializer: pxpy(k, initializer2)
  };
}
function pxpy(k, i) {
  if (i == null) return i;
  return function(data, facets, { x: x1, y: y1, px, py, ...c1 }, ...args) {
    const { channels: { x, y, ...c } = {}, ...rest } = i.call(this, data, facets, { ...c1, x: px, y: py }, ...args);
    return {
      channels: {
        ...c,
        ...x && { px: x, ...k === "x" && { x } },
        ...y && { py: y, ...k === "y" && { y } }
      },
      ...rest
    };
  };
}
function ruleOptions(k, pointerOptions, options) {
  const {
    color: color2 = "currentColor",
    opacity: opacity2 = 0.2,
    ruleStroke: stroke = color2,
    ruleStrokeOpacity: strokeOpacity = opacity2,
    ruleStrokeWidth: strokeWidth
  } = options;
  return {
    ...markOptions(k, pointerOptions, options),
    stroke,
    strokeOpacity,
    strokeWidth
  };
}
function textOptions(k, pointerOptions, options) {
  const {
    color: color2 = "currentColor",
    textFill: fill = color2,
    textFillOpacity: fillOpacity,
    textStroke: stroke = "var(--plot-background)",
    textStrokeOpacity: strokeOpacity,
    textStrokeWidth: strokeWidth = 5
  } = options;
  return {
    ...markOptions(k, pointerOptions, textChannel(k, options)),
    fill,
    fillOpacity,
    stroke,
    strokeOpacity,
    strokeWidth
  };
}
function textChannel(source, options) {
  return initializer(options, (data, facets, channels) => {
    var _a;
    return { channels: { text: { value: (_a = getSource(channels, source)) == null ? void 0 : _a.value } } };
  });
}

// node_modules/@observablehq/plot/src/marks/delaunay.js
var delaunayLinkDefaults = {
  ariaLabel: "delaunay link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var delaunayMeshDefaults = {
  ariaLabel: "delaunay mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
var hullDefaults = {
  ariaLabel: "hull",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeMiterlimit: 1
};
var voronoiDefaults = {
  ariaLabel: "voronoi",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var voronoiMeshDefaults = {
  ariaLabel: "voronoi mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
var DelaunayLink = class extends Mark {
  constructor(data, options = {}) {
    const { x, y, z, curve, tension } = options;
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        z: { value: z, optional: true }
      },
      options,
      delaunayLinkDefaults
    );
    this.curve = maybeCurve(curve, tension);
    markers(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y: Y, z: Z } = channels;
    const { curve } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X ? (i) => X[i] : constant(cx);
    const yi = Y ? (i) => Y[i] : constant(cy);
    const mark = this;
    function links(index2) {
      let i = -1;
      const newIndex = [];
      const newChannels = {};
      for (const k in channels) newChannels[k] = [];
      const X1 = [];
      const X2 = [];
      const Y1 = [];
      const Y2 = [];
      function link2(ti, tj) {
        ti = index2[ti];
        tj = index2[tj];
        newIndex.push(++i);
        X1[i] = xi(ti);
        Y1[i] = yi(ti);
        X2[i] = xi(tj);
        Y2[i] = yi(tj);
        for (const k in channels) newChannels[k].push(channels[k][tj]);
      }
      const { halfedges, hull: hull2, triangles } = Delaunay.from(index2, xi, yi);
      for (let i2 = 0; i2 < halfedges.length; ++i2) {
        const j = halfedges[i2];
        if (j > i2) link2(triangles[i2], triangles[j]);
      }
      for (let i2 = 0; i2 < hull2.length; ++i2) {
        link2(hull2[i2], hull2[(i2 + 1) % hull2.length]);
      }
      select_default(this).selectAll().data(newIndex).enter().append("path").call(applyDirectStyles, mark).attr("d", (i2) => {
        const p = pathRound();
        const c = curve(p);
        c.lineStart();
        c.point(X1[i2], Y1[i2]);
        c.point(X2[i2], Y2[i2]);
        c.lineEnd();
        return p;
      }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels, context);
    }
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X && x, y: Y && y }).call(
      Z ? (g) => g.selectAll().data(group(index, (i) => Z[i]).values()).enter().append("g").each(links) : (g) => g.datum(index).each(links)
    ).node();
  }
};
var AbstractDelaunayMark = class extends Mark {
  constructor(data, options = {}, defaults22, zof = ({ z }) => z) {
    const { x, y } = options;
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        z: { value: zof(options), optional: true }
      },
      options,
      defaults22
    );
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y: Y, z: Z } = channels;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X ? (i) => X[i] : constant(cx);
    const yi = Y ? (i) => Y[i] : constant(cy);
    const mark = this;
    function mesh(index2) {
      const delaunay = Delaunay.from(index2, xi, yi);
      select_default(this).append("path").datum(index2[0]).call(applyDirectStyles, mark).attr("d", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);
    }
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X && x, y: Y && y }).call(
      Z ? (g) => g.selectAll().data(group(index, (i) => Z[i]).values()).enter().append("g").each(mesh) : (g) => g.datum(index).each(mesh)
    ).node();
  }
};
var DelaunayMesh = class extends AbstractDelaunayMark {
  constructor(data, options = {}) {
    super(data, options, delaunayMeshDefaults);
    this.fill = "none";
  }
  _render(delaunay) {
    return delaunay.render();
  }
};
var Hull = class extends AbstractDelaunayMark {
  constructor(data, options = {}) {
    super(data, options, hullDefaults, maybeZ);
  }
  _render(delaunay) {
    return delaunay.renderHull();
  }
};
var Voronoi = class extends Mark {
  constructor(data, options = {}) {
    const { x, y, z } = options;
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        z: { value: z, optional: true }
      },
      initializer(options, function(data2, facets, channels, scales, dimensions, context) {
        let { x: X, y: Y, z: Z } = channels;
        ({ x: X, y: Y } = applyPosition(channels, scales, context));
        Z = Z == null ? void 0 : Z.value;
        const C = new Array((X ?? Y).length).fill(null);
        const [cx, cy] = applyFrameAnchor(this, dimensions);
        const xi = X ? (i) => X[i] : constant(cx);
        const yi = Y ? (i) => Y[i] : constant(cy);
        for (let I of facets) {
          if (X) I = I.filter((i) => defined(xi(i)));
          if (Y) I = I.filter((i) => defined(yi(i)));
          for (const [, J] of maybeGroup(I, Z)) {
            const delaunay = Delaunay.from(J, xi, yi);
            const voronoi2 = voronoiof(delaunay, dimensions);
            for (let i = 0, n = J.length; i < n; ++i) {
              C[J[i]] = voronoi2.renderCell(i);
            }
          }
        }
        return { data: data2, facets, channels: { cells: { value: C } } };
      }),
      voronoiDefaults
    );
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y: Y, cells: C } = channels;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X && x, y: Y && y }).call((g) => {
      g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => C[i]).call(applyChannelStyles, this, channels);
    }).node();
  }
};
var VoronoiMesh = class extends AbstractDelaunayMark {
  constructor(data, options) {
    super(data, options, voronoiMeshDefaults);
    this.fill = "none";
  }
  _render(delaunay, dimensions) {
    return voronoiof(delaunay, dimensions).render();
  }
};
function voronoiof(delaunay, dimensions) {
  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;
  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);
}
function delaunayMark(DelaunayMark, data, { x, y, ...options } = {}) {
  [x, y] = maybeTuple(x, y);
  return new DelaunayMark(data, { ...options, x, y });
}
function delaunayLink(data, options) {
  return delaunayMark(DelaunayLink, data, options);
}
function delaunayMesh(data, options) {
  return delaunayMark(DelaunayMesh, data, options);
}
function hull(data, options) {
  return delaunayMark(Hull, data, options);
}
function voronoi(data, { x, y, initializer: initializer2, ...options } = {}) {
  return delaunayMark(Voronoi, data, { ...basic({ ...options, x, y }, exclusiveFacets), initializer: initializer2 });
}
function voronoiMesh(data, options) {
  return delaunayMark(VoronoiMesh, data, options);
}

// node_modules/@observablehq/plot/src/marks/density.js
var defaults17 = {
  ariaLabel: "density",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var Density = class extends Mark {
  constructor(data, { x, y, z, weight, fill, stroke, ...options } = {}) {
    const fillDensity = isDensity(fill) && (fill = "currentColor", true);
    const strokeDensity = isDensity(stroke) && (stroke = "currentColor", true);
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        z: { value: maybeZ({ z, fill, stroke }), optional: true },
        weight: { value: weight, optional: true }
      },
      densityInitializer({ ...options, fill, stroke }, fillDensity, strokeDensity),
      defaults17
    );
    if (fillDensity) this.fill = void 0;
    if (strokeDensity) this.stroke = void 0;
    this.z = z;
  }
  filter(index) {
    return index;
  }
  render(index, scales, channels, dimensions, context) {
    const { contours } = channels;
    const path = path_default();
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call(
      (g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", (i) => path(contours[i]))
    ).node();
  }
};
function density(data, { x, y, ...options } = {}) {
  [x, y] = maybeTuple(x, y);
  return new Density(data, { ...options, x, y });
}
var dropChannels = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
function densityInitializer(options, fillDensity, strokeDensity) {
  const k = 100;
  let { bandwidth, thresholds } = options;
  bandwidth = bandwidth === void 0 ? 20 : +bandwidth;
  thresholds = thresholds === void 0 ? 20 : typeof (thresholds == null ? void 0 : thresholds[Symbol.iterator]) === "function" ? coerceNumbers(thresholds) : +thresholds;
  return initializer(options, function(data, facets, channels, scales, dimensions, context) {
    var _a;
    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;
    const Z = (_a = channels.z) == null ? void 0 : _a.value;
    const { z } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const { width, height } = dimensions;
    const { x: X, y: Y } = applyPosition(channels, scales, context);
    const newChannels = Object.fromEntries(
      Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, { ...channel, value: [] }])
    );
    const FD = fillDensity && [];
    const SD = strokeDensity && [];
    const density2 = density_default().x(X ? (i) => X[i] : cx).y(Y ? (i) => Y[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);
    const facetsContours = [];
    for (const facet of facets) {
      const facetContours = [];
      facetsContours.push(facetContours);
      for (const index of Z ? groupZ2(facet, Z, z) : [facet]) {
        const contour2 = density2.contours(index);
        facetContours.push([index, contour2]);
      }
    }
    let T = thresholds;
    if (!(T instanceof TypedArray)) {
      let maxValue = 0;
      for (const facetContours of facetsContours) {
        for (const [, contour2] of facetContours) {
          const max2 = contour2.max;
          if (max2 > maxValue) maxValue = max2;
        }
      }
      T = Float64Array.from({ length: thresholds - 1 }, (_, i) => maxValue * k * (i + 1) / thresholds);
    }
    const newFacets = [];
    const contours = [];
    for (const facetContours of facetsContours) {
      const newFacet = [];
      newFacets.push(newFacet);
      for (const [index, contour2] of facetContours) {
        for (const t of T) {
          newFacet.push(contours.length);
          contours.push(contour2(t / k));
          if (FD) FD.push(t);
          if (SD) SD.push(t);
          for (const key in newChannels) {
            newChannels[key].value.push(channels[key].value[index[0]]);
          }
        }
      }
    }
    if (FD) FD.push(0);
    if (SD) SD.push(0);
    return {
      data,
      facets: newFacets,
      channels: {
        ...newChannels,
        ...FD && { fill: { value: FD, scale: "color" } },
        ...SD && { stroke: { value: SD, scale: "color" } },
        contours: { value: contours }
      }
    };
  });
}
function isDensity(value) {
  return /^density$/i.test(value);
}

// node_modules/@observablehq/plot/src/marks/difference.js
function differenceX(data, options) {
  return differenceK("x", data, options);
}
function differenceY(data, options) {
  return differenceK("y", data, options);
}
function differenceK(k, data, {
  x1,
  x2,
  y1,
  y2,
  x = x1 === void 0 && x2 === void 0 ? k === "y" ? indexOf : identity2 : void 0,
  y = y1 === void 0 && y2 === void 0 ? k === "x" ? indexOf : identity2 : void 0,
  fill,
  // ignored
  positiveFill = "#3ca951",
  negativeFill = "#4269d0",
  fillOpacity = 1,
  positiveFillOpacity = fillOpacity,
  negativeFillOpacity = fillOpacity,
  stroke,
  strokeOpacity,
  z = maybeColorChannel(stroke)[0],
  clip,
  // optional additional clip for area
  tip: tip2,
  render,
  ...options
} = {}) {
  [x1, x2] = memoTuple(x, x1, x2);
  [y1, y2] = memoTuple(y, y1, y2);
  if (x1 === x2 && y1 === y2) {
    if (k === "y") y1 = memo(0);
    else x1 = memo(0);
  }
  ({ tip: tip2 } = withTip({ tip: tip2 }, k === "y" ? "x" : "y"));
  return marks(
    !isNoneish(positiveFill) ? Object.assign(
      area(data, {
        x1,
        x2,
        y1,
        y2,
        z,
        fill: positiveFill,
        fillOpacity: positiveFillOpacity,
        render: composeRender(render, clipDifference(k, true)),
        clip,
        ...options
      }),
      { ariaLabel: "positive difference" }
    ) : null,
    !isNoneish(negativeFill) ? Object.assign(
      area(data, {
        x1,
        x2,
        y1,
        y2,
        z,
        fill: negativeFill,
        fillOpacity: negativeFillOpacity,
        render: composeRender(render, clipDifference(k, false)),
        clip,
        ...options
      }),
      { ariaLabel: "negative difference" }
    ) : null,
    line(data, {
      x: x2,
      y: y2,
      z,
      stroke,
      strokeOpacity,
      tip: tip2,
      clip: true,
      ...options
    })
  );
}
function memoTuple(x, x1, x2) {
  if (x1 === void 0 && x2 === void 0) {
    x1 = x2 = memo(x);
  } else if (x1 === void 0) {
    x2 = memo(x2);
    x1 = x === void 0 ? x2 : memo(x);
  } else if (x2 === void 0) {
    x1 = memo(x1);
    x2 = x === void 0 ? x1 : memo(x);
  } else {
    x1 = memo(x1);
    x2 = memo(x2);
  }
  return [x1, x2];
}
function memo(v) {
  let V;
  const { value, label = labelof(value) } = maybeValue(v);
  return { transform: (data) => V || (V = valueof(data, value)), label };
}
function clipDifference(k, positive2) {
  const f = k === "x" ? "y" : "x";
  const f1 = `${f}1`;
  const f2 = `${f}2`;
  const k1 = `${k}1`;
  const k2 = `${k}2`;
  return (index, scales, channels, dimensions, context, next) => {
    const { [f1]: F1, [f2]: F2 } = channels;
    const K1 = new Float32Array(F1.length);
    const K2 = new Float32Array(F2.length);
    const m = dimensions[k === "y" ? "height" : "width"];
    (positive2 === inferScaleOrder(scales[k]) < 0 ? K1 : K2).fill(m);
    const oc = next(index, scales, { ...channels, [f2]: F1, [k2]: K2 }, dimensions, context);
    const og = next(index, scales, { ...channels, [f1]: F2, [k1]: K1 }, dimensions, context);
    const c = oc.querySelector("g") ?? oc;
    const g = og.querySelector("g") ?? og;
    for (let i = 0; c.firstChild; i += 2) {
      const id = getClipId();
      const clipPath = create("svg:clipPath", context).attr("id", id).node();
      clipPath.appendChild(c.firstChild);
      g.childNodes[i].setAttribute("clip-path", `url(#${id})`);
      g.insertBefore(clipPath, g.childNodes[i]);
    }
    return og;
  };
}

// node_modules/@observablehq/plot/src/transforms/centroid.js
function centroid({ geometry = identity2, ...options } = {}) {
  const getG = memoize1((data) => valueof(data, geometry));
  return initializer(
    // Suppress defaults for x and y since they will be computed by the initializer.
    // Propagate the (memoized) geometry channel in case it’s still needed.
    { ...options, x: null, y: null, geometry: { transform: getG } },
    (data, facets, channels, scales, dimensions, context) => {
      const G = getG(data);
      const n = G.length;
      const X = new Float64Array(n);
      const Y = new Float64Array(n);
      const { centroid: centroid2 } = context.path();
      for (let i = 0; i < n; ++i) [X[i], Y[i]] = centroid2(G[i]);
      return {
        data,
        facets,
        channels: { x: { value: X, scale: null, source: null }, y: { value: Y, scale: null, source: null } }
      };
    }
  );
}
function geoCentroid({ geometry = identity2, ...options } = {}) {
  const getG = memoize1((data) => valueof(data, geometry));
  const getC = memoize1((data) => valueof(getG(data), centroid_default));
  return {
    ...options,
    x: { transform: (data) => Float64Array.from(getC(data), ([x]) => x) },
    y: { transform: (data) => Float64Array.from(getC(data), ([, y]) => y) },
    geometry: { transform: getG }
  };
}

// node_modules/@observablehq/plot/src/marks/geo.js
var defaults18 = {
  ariaLabel: "geo",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Geo = class extends Mark {
  constructor(data, options = {}) {
    const [vr, cr] = maybeNumberChannel(options.r, 3);
    super(
      data,
      {
        x: { value: options.tip ? options.x : null, scale: "x", optional: true },
        y: { value: options.tip ? options.y : null, scale: "y", optional: true },
        r: { value: vr, scale: "r", filter: positive, optional: true },
        geometry: { value: options.geometry, scale: "projection" }
      },
      withDefaultSort(options),
      defaults18
    );
    this.r = cr;
  }
  render(index, scales, channels, dimensions, context) {
    const { geometry: G, r: R } = channels;
    const path = context.path();
    const { r } = this;
    if (negative(r)) index = [];
    else if (r !== void 0) path.pointRadius(r);
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {
      g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr("d", R ? (i) => path.pointRadius(R[i])(G[i]) : (i) => path(G[i])).call(applyChannelStyles, this, channels);
    }).node();
  }
};
function geo(data, options = {}) {
  if (options.tip && options.x === void 0 && options.y === void 0) options = centroid(options);
  else if (options.geometry === void 0) options = { ...options, geometry: identity2 };
  return new Geo(data, options);
}
function sphere2({ strokeWidth = 1.5, ...options } = {}) {
  return geo({ type: "Sphere" }, { strokeWidth, ...options });
}
function graticule({ strokeOpacity = 0.1, ...options } = {}) {
  return geo(graticule10(), { strokeOpacity, ...options });
}

// node_modules/@observablehq/plot/src/transforms/hexbin.js
var ox = 0.5;
var oy = 0;
function hexbin(outputs = { fill: "count" }, { binWidth, ...options } = {}) {
  const { z } = options;
  binWidth = binWidth === void 0 ? 20 : number(binWidth);
  outputs = maybeGroupOutputs(outputs, options);
  if (hasOutput(outputs, "fill")) options.channels = { ...options.channels, fill: { value: [] } };
  if (options.symbol === void 0) options.symbol = "hexagon";
  if (options.r === void 0 && !hasOutput(outputs, "r")) options.r = binWidth / 2;
  return initializer(options, (data, facets, channels, scales, _, context) => {
    let { x: X, y: Y, z: Z, fill: F, stroke: S, symbol: Q } = channels;
    if (X === void 0) throw new Error("missing channel: x");
    if (Y === void 0) throw new Error("missing channel: y");
    ({ x: X, y: Y } = applyPosition(channels, scales, context));
    Z = Z ? Z.value : valueof(data, z);
    F = F == null ? void 0 : F.value;
    S = S == null ? void 0 : S.value;
    Q = Q == null ? void 0 : Q.value;
    const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S, symbol: Q });
    const GZ = Z && [];
    const GF = F && [];
    const GS = S && [];
    const GQ = Q && [];
    const binFacets = [];
    const BX = [];
    const BY = [];
    let i = -1;
    for (const o of outputs) o.initialize(data);
    for (const facet of facets) {
      const binFacet = [];
      for (const o of outputs) o.scope("facet", facet);
      for (const [f, I] of maybeGroup(facet, G)) {
        for (const { index: b, extent: extent3 } of hbin(data, I, X, Y, binWidth)) {
          binFacet.push(++i);
          BX.push(extent3.x);
          BY.push(extent3.y);
          if (Z) GZ.push(G === Z ? f : Z[b[0]]);
          if (F) GF.push(G === F ? f : F[b[0]]);
          if (S) GS.push(G === S ? f : S[b[0]]);
          if (Q) GQ.push(G === Q ? f : Q[b[0]]);
          for (const o of outputs) o.reduce(b, extent3);
        }
      }
      binFacets.push(binFacet);
    }
    const sx = channels.x.scale;
    const sy = channels.y.scale;
    const binChannels = {
      x: { value: BX, source: scales[sx] ? { value: map(BX, scales[sx].invert), scale: sx } : null },
      y: { value: BY, source: scales[sy] ? { value: map(BY, scales[sy].invert), scale: sy } : null },
      ...Z && { z: { value: GZ } },
      ...F && { fill: { value: GF, scale: "auto" } },
      ...S && { stroke: { value: GS, scale: "auto" } },
      ...Q && { symbol: { value: GQ, scale: "auto" } },
      ...Object.fromEntries(
        outputs.map(({ name, output }) => [
          name,
          {
            scale: "auto",
            label: output.label,
            radius: name === "r" ? binWidth / 2 : void 0,
            value: output.transform()
          }
        ])
      )
    };
    return { data, facets: binFacets, channels: binChannels };
  });
}
function hbin(data, I, X, Y, dx) {
  const dy = dx * (1.5 / sqrt3);
  const bins = /* @__PURE__ */ new Map();
  for (const i of I) {
    let px = X[i], py = Y[i];
    if (isNaN(px) || isNaN(py)) continue;
    let pj = Math.round(py = (py - oy) / dy), pi2 = Math.round(px = (px - ox) / dx - (pj & 1) / 2), py1 = py - pj;
    if (Math.abs(py1) * 3 > 1) {
      let px1 = px - pi2, pi22 = pi2 + (px < pi2 ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi22, py2 = py - pj2;
      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi2 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
    }
    const key = `${pi2},${pj}`;
    let bin2 = bins.get(key);
    if (bin2 === void 0) {
      bin2 = { index: [], extent: { data, x: (pi2 + (pj & 1) / 2) * dx + ox, y: pj * dy + oy } };
      bins.set(key, bin2);
    }
    bin2.index.push(i);
  }
  return bins.values();
}

// node_modules/@observablehq/plot/src/marks/hexgrid.js
var defaults19 = {
  ariaLabel: "hexgrid",
  fill: "none",
  stroke: "currentColor",
  strokeOpacity: 0.1
};
function hexgrid(options) {
  return new Hexgrid(options);
}
var Hexgrid = class extends Mark {
  constructor({ binWidth = 20, clip = true, ...options } = {}) {
    super(singleton, void 0, { clip, ...options }, defaults19);
    this.binWidth = number(binWidth);
  }
  render(index, scales, channels, dimensions, context) {
    const { binWidth } = this;
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const x0 = marginLeft - ox, x1 = width - marginRight - ox, y0 = marginTop - oy, y1 = height - marginBottom - oy, rx = binWidth / 2, ry = rx * sqrt4_3, hy = ry / 2, wx = rx * 2, wy = ry * 1.5, i0 = Math.floor(x0 / wx), i1 = Math.ceil(x1 / wx), j0 = Math.floor((y0 + hy) / wy), j1 = Math.ceil((y1 - hy) / wy) + 1, path = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;
    let d = path;
    for (let j = j0; j < j1; ++j) {
      for (let i = i0; i < i1; ++i) {
        d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path}`;
      }
    }
    return create("svg:g", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g) => g.append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", d)).node();
  }
};
function round(x) {
  return Math.round(x * 1e3) / 1e3;
}

// node_modules/@observablehq/plot/src/marks/image.js
var defaults20 = {
  ariaLabel: "image",
  fill: null,
  stroke: null
};
function isPath(string2) {
  return /^\.*\//.test(string2);
}
function isUrl(string2) {
  return /^(blob|data|file|http|https):/i.test(string2);
}
function maybePathChannel(value) {
  return typeof value === "string" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];
}
var Image = class extends Mark {
  constructor(data, options = {}) {
    let { x, y, r, width, height, rotate, src, preserveAspectRatio, crossOrigin, frameAnchor, imageRendering } = options;
    if (r == null) r = void 0;
    if (r === void 0 && width === void 0 && height === void 0) width = height = 16;
    else if (width === void 0 && height !== void 0) width = height;
    else if (height === void 0 && width !== void 0) height = width;
    const [vs, cs] = maybePathChannel(src);
    const [vr, cr] = maybeNumberChannel(r);
    const [vw, cw] = maybeNumberChannel(width, cr !== void 0 ? cr * 2 : void 0);
    const [vh, ch] = maybeNumberChannel(height, cr !== void 0 ? cr * 2 : void 0);
    const [va, ca] = maybeNumberChannel(rotate, 0);
    super(
      data,
      {
        x: { value: x, scale: "x", optional: true },
        y: { value: y, scale: "y", optional: true },
        r: { value: vr, scale: "r", filter: positive, optional: true },
        width: { value: vw, filter: positive, optional: true },
        height: { value: vh, filter: positive, optional: true },
        rotate: { value: va, optional: true },
        src: { value: vs, optional: true }
      },
      withDefaultSort(options),
      defaults20
    );
    this.src = cs;
    this.width = cw;
    this.rotate = ca;
    this.height = ch;
    this.r = cr;
    this.preserveAspectRatio = impliedString(preserveAspectRatio, "xMidYMid");
    this.crossOrigin = string(crossOrigin);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    this.imageRendering = impliedString(imageRendering, "auto");
  }
  render(index, scales, channels, dimensions, context) {
    const { x, y } = scales;
    const { x: X, y: Y, width: W, height: H, r: R, rotate: A, src: S } = channels;
    const { r, width, height, rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X && x, y: Y && y }).call(
      (g) => g.selectAll().data(index).enter().append("image").call(applyDirectStyles, this).attr("x", position2(X, W, R, cx, width, r)).attr("y", position2(Y, H, R, cy, height, r)).attr("width", W ? (i) => W[i] : width !== void 0 ? width : R ? (i) => R[i] * 2 : r * 2).attr("height", H ? (i) => H[i] : height !== void 0 ? height : R ? (i) => R[i] * 2 : r * 2).attr("transform", A ? (i) => `rotate(${A[i]})` : rotate ? `rotate(${rotate})` : null).attr("transform-origin", A || rotate ? template`${X ? (i) => X[i] : cx}px ${Y ? (i) => Y[i] : cy}px` : null).call(applyAttr, "href", S ? (i) => S[i] : this.src).call(applyAttr, "preserveAspectRatio", this.preserveAspectRatio).call(applyAttr, "crossorigin", this.crossOrigin).call(applyAttr, "image-rendering", this.imageRendering).call(applyAttr, "clip-path", R ? (i) => `circle(${R[i]}px)` : r !== void 0 ? `circle(${r}px)` : null).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function position2(X, W, R, x, w, r) {
  return W && X ? (i) => X[i] - W[i] / 2 : W ? (i) => x - W[i] / 2 : X && w !== void 0 ? (i) => X[i] - w / 2 : w !== void 0 ? x - w / 2 : R && X ? (i) => X[i] - R[i] : R ? (i) => x - R[i] : X ? (i) => X[i] - r : x - r;
}
function image(data, { x, y, ...options } = {}) {
  if (options.frameAnchor === void 0) [x, y] = maybeTuple(x, y);
  return new Image(data, { ...options, x, y });
}

// node_modules/@observablehq/plot/src/stats.js
function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0) return 0;
  if (p >= 1) return 1;
  if (a >= 1 && b >= 1) {
    pp = p < 0.5 ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5) x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
    w = x * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w) x = Math.pow(a * w * p, 1 / a);
    else x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -gammaln(a) - gammaln(b) + gammaln(a + b);
  for (; j < 10; j++) {
    if (x === 0 || x === 1) return x;
    err = ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x))));
    if (x <= 0) x = 0.5 * (x + t);
    if (x >= 1) x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0) break;
  }
  return x;
}
function ibeta(x, a, b) {
  var bt = x === 0 || x === 1 ? 0 : Math.exp(gammaln(a + b) - gammaln(a) - gammaln(b) + a * Math.log(x) + b * Math.log(1 - x));
  if (x < 0 || x > 1) return false;
  if (x < (a + 1) / (a + b + 2))
    return bt * betacf(x, a, b) / a;
  return 1 - bt * betacf(1 - x, b, a) / b;
}
function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;
  if (Math.abs(d) < fpmin) d = fpmin;
  d = 1 / d;
  h = d;
  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1) < 3e-7) break;
  }
  return h;
}
function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++) ser += cof[j] / ++y;
  return Math.log(2.506628274631 * ser / xx) - tmp;
}
function qt(p, dof) {
  var x = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
  x = Math.sqrt(dof * (1 - x) / x);
  return p > 0.5 ? x : -x;
}

// node_modules/@observablehq/plot/src/marks/linearRegression.js
var defaults21 = {
  ariaLabel: "linear-regression",
  fill: "currentColor",
  fillOpacity: 0.1,
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var LinearRegression = class extends Mark {
  constructor(data, options = {}) {
    const { x, y, z, ci = 0.95, precision = 4 } = options;
    super(
      data,
      {
        x: { value: x, scale: "x" },
        y: { value: y, scale: "y" },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults21
    );
    this.z = z;
    this.ci = +ci;
    this.precision = +precision;
    if (!(0 <= this.ci && this.ci < 1)) throw new Error(`invalid ci; not in [0, 1): ${ci}`);
    if (!(this.precision > 0)) throw new Error(`invalid precision: ${precision}`);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X, y: Y, z: Z } = channels;
    const { ci } = this;
    return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
      (g) => g.selectAll().data(Z ? groupZ2(index, Z, this.z) : [index]).enter().call(
        (enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr("d", (I) => this._renderLine(I, X, Y)).call(
          ci && !isNone(this.fill) ? (path) => path.select(pathBefore).attr("stroke", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
            ...channels,
            stroke: null,
            strokeOpacity: null,
            strokeWidth: null
          }).attr("d", (I) => this._renderBand(I, X, Y)) : () => {
          }
        )
      )
    ).node();
  }
};
function pathBefore() {
  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, "path"), this);
}
var LinearRegressionX = class extends LinearRegression {
  constructor(data, options) {
    super(data, options);
  }
  _renderBand(I, X, Y) {
    const { ci, precision } = this;
    const [y1, y2] = extent(I, (i) => Y[i]);
    const f = linearRegressionF(I, Y, X);
    const g = confidenceIntervalF(I, Y, X, (1 - ci) / 2, f);
    return area_default().y((y) => y).x0((y) => g(y, -1)).x1((y) => g(y, 1))(range(y1, y2 - precision / 2, precision).concat(y2));
  }
  _renderLine(I, X, Y) {
    const [y1, y2] = extent(I, (i) => Y[i]);
    const f = linearRegressionF(I, Y, X);
    return `M${f(y1)},${y1}L${f(y2)},${y2}`;
  }
};
var LinearRegressionY = class extends LinearRegression {
  constructor(data, options) {
    super(data, options);
  }
  _renderBand(I, X, Y) {
    const { ci, precision } = this;
    const [x1, x2] = extent(I, (i) => X[i]);
    const f = linearRegressionF(I, X, Y);
    const g = confidenceIntervalF(I, X, Y, (1 - ci) / 2, f);
    return area_default().x((x) => x).y0((x) => g(x, -1)).y1((x) => g(x, 1))(range(x1, x2 - precision / 2, precision).concat(x2));
  }
  _renderLine(I, X, Y) {
    const [x1, x2] = extent(I, (i) => X[i]);
    const f = linearRegressionF(I, X, Y);
    return `M${x1},${f(x1)}L${x2},${f(x2)}`;
  }
};
function linearRegressionX(data, { y = indexOf, x = identity2, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...options } = {}) {
  return new LinearRegressionX(data, maybeDenseIntervalY({ ...options, x, y, fill, stroke }));
}
function linearRegressionY(data, { x = indexOf, y = identity2, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...options } = {}) {
  return new LinearRegressionY(data, maybeDenseIntervalX({ ...options, x, y, fill, stroke }));
}
function linearRegressionF(I, X, Y) {
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (const i of I) {
    const xi = X[i];
    const yi = Y[i];
    sumX += xi;
    sumY += yi;
    sumXY += xi * yi;
    sumX2 += xi * xi;
  }
  const n = I.length;
  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  return (x) => slope * x + intercept;
}
function confidenceIntervalF(I, X, Y, p, f) {
  const mean2 = sum(I, (i) => X[i]) / I.length;
  let a = 0, b = 0;
  for (const i of I) {
    a += (X[i] - mean2) ** 2;
    b += (Y[i] - f(X[i])) ** 2;
  }
  const sy = Math.sqrt(b / (I.length - 2));
  const t = qt(p, I.length - 2);
  return (x, k) => {
    const Y2 = f(x);
    const se = sy * Math.sqrt(1 / I.length + (x - mean2) ** 2 / a);
    return Y2 + k * t * se;
  };
}

// node_modules/@observablehq/plot/src/transforms/tree.js
function treeNode({
  path = identity2,
  // the delimited path
  delimiter,
  // how the path is separated
  frameAnchor,
  treeLayout = tree_default,
  treeSort,
  treeSeparation,
  treeAnchor,
  treeFilter,
  ...options
} = {}) {
  treeAnchor = maybeTreeAnchor(treeAnchor);
  treeSort = maybeTreeSort(treeSort);
  if (treeFilter != null) treeFilter = maybeNodeValue(treeFilter);
  if (frameAnchor === void 0) frameAnchor = treeAnchor.frameAnchor;
  const normalize2 = normalizer(delimiter);
  const outputs = treeOutputs(options, maybeNodeValue);
  const [X, setX] = column();
  const [Y, setY] = column();
  return {
    x: X,
    y: Y,
    frameAnchor,
    ...basic(options, (data, facets) => {
      const P = normalize2(valueof(data, path));
      const X2 = setX([]);
      const Y2 = setY([]);
      let treeIndex = -1;
      const treeData = [];
      const treeFacets = [];
      const rootof = stratify_default().path((i) => P[i]);
      const setData = isArray(data) ? (node) => node.data = data[node.data] : (node) => node.data = data.get(node.data);
      const layout = treeLayout();
      if (layout.nodeSize) layout.nodeSize([1, 1]);
      if (layout.separation && treeSeparation !== void 0) layout.separation(treeSeparation ?? one);
      for (const o of outputs) o[output_values] = o[output_setValues]([]);
      for (const facet of facets) {
        const treeFacet = [];
        const root = rootof(facet.filter((i) => P[i] != null)).each(setData);
        if (treeSort != null) root.sort(treeSort);
        layout(root);
        for (const node of root.descendants()) {
          if (treeFilter != null && !treeFilter(node)) continue;
          treeFacet.push(++treeIndex);
          treeData[treeIndex] = node.data;
          treeAnchor.position(node, treeIndex, X2, Y2);
          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](node);
        }
        treeFacets.push(treeFacet);
      }
      return { data: treeData, facets: treeFacets };
    }),
    ...Object.fromEntries(outputs)
  };
}
function treeLink({
  path = identity2,
  // the delimited path
  delimiter,
  // how the path is separated
  curve = "bump-x",
  stroke = "#555",
  strokeWidth = 1.5,
  strokeOpacity = 0.5,
  treeLayout = tree_default,
  treeSort,
  treeSeparation,
  treeAnchor,
  treeFilter,
  ...options
} = {}) {
  treeAnchor = maybeTreeAnchor(treeAnchor);
  treeSort = maybeTreeSort(treeSort);
  if (treeFilter != null) treeFilter = maybeLinkValue(treeFilter);
  options = { curve, stroke, strokeWidth, strokeOpacity, ...options };
  const normalize2 = normalizer(delimiter);
  const outputs = treeOutputs(options, maybeLinkValue);
  const [X1, setX1] = column();
  const [X2, setX2] = column();
  const [Y1, setY1] = column();
  const [Y2, setY2] = column();
  return {
    x1: X1,
    x2: X2,
    y1: Y1,
    y2: Y2,
    ...basic(options, (data, facets) => {
      const P = normalize2(valueof(data, path));
      const X12 = setX1([]);
      const X22 = setX2([]);
      const Y12 = setY1([]);
      const Y22 = setY2([]);
      let treeIndex = -1;
      const treeData = [];
      const treeFacets = [];
      const rootof = stratify_default().path((i) => P[i]);
      const layout = treeLayout();
      if (layout.nodeSize) layout.nodeSize([1, 1]);
      if (layout.separation && treeSeparation !== void 0) layout.separation(treeSeparation ?? one);
      for (const o of outputs) o[output_values] = o[output_setValues]([]);
      for (const facet of facets) {
        const treeFacet = [];
        const root = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
        if (treeSort != null) root.sort(treeSort);
        layout(root);
        for (const { source, target } of root.links()) {
          if (treeFilter != null && !treeFilter(target, source)) continue;
          treeFacet.push(++treeIndex);
          treeData[treeIndex] = target.data;
          treeAnchor.position(source, treeIndex, X12, Y12);
          treeAnchor.position(target, treeIndex, X22, Y22);
          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](target, source);
        }
        treeFacets.push(treeFacet);
      }
      return { data: treeData, facets: treeFacets };
    }),
    ...Object.fromEntries(outputs)
  };
}
function maybeTreeAnchor(anchor = "left") {
  switch (`${anchor}`.trim().toLowerCase()) {
    case "left":
      return treeAnchorLeft;
    case "right":
      return treeAnchorRight;
  }
  throw new Error(`invalid tree anchor: ${anchor}`);
}
var treeAnchorLeft = {
  frameAnchor: "left",
  dx: 6,
  position({ x, y }, i, X, Y) {
    X[i] = y;
    Y[i] = -x;
  }
};
var treeAnchorRight = {
  frameAnchor: "right",
  dx: -6,
  position({ x, y }, i, X, Y) {
    X[i] = -y;
    Y[i] = -x;
  }
};
function maybeTreeSort(sort3) {
  return sort3 == null || typeof sort3 === "function" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith("node:") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));
}
function nodeSort(value) {
  return (a, b) => ascendingDefined(value(a), value(b));
}
function nodeData(field2) {
  return (node) => {
    var _a;
    return (_a = node.data) == null ? void 0 : _a[field2];
  };
}
function normalizer(delimiter = "/") {
  delimiter = `${delimiter}`;
  if (delimiter === "/") return (P) => P;
  if (delimiter.length !== 1) throw new Error("delimiter must be exactly one character");
  const delimiterCode = delimiter.charCodeAt(0);
  return (P) => P.map((p) => slashDelimiter(p, delimiterCode));
}
var CODE_BACKSLASH = 92;
var CODE_SLASH = 47;
function slashDelimiter(input, delimiterCode) {
  if (delimiterCode === CODE_BACKSLASH) throw new Error("delimiter cannot be backslash");
  let afterBackslash = false;
  for (let i = 0, n = input.length; i < n; ++i) {
    switch (input.charCodeAt(i)) {
      case CODE_BACKSLASH:
        if (!afterBackslash) {
          afterBackslash = true;
          continue;
        }
        break;
      case delimiterCode:
        if (afterBackslash) {
          input = input.slice(0, i - 1) + input.slice(i), --i, --n;
        } else {
          input = input.slice(0, i) + "/" + input.slice(i + 1);
        }
        break;
      case CODE_SLASH:
        if (afterBackslash) {
          input = input.slice(0, i) + "\\\\" + input.slice(i), i += 2, n += 2;
        } else {
          input = input.slice(0, i) + "\\" + input.slice(i), ++i, ++n;
        }
        break;
    }
    afterBackslash = false;
  }
  return input;
}
function slashUnescape(input) {
  let afterBackslash = false;
  for (let i = 0, n = input.length; i < n; ++i) {
    switch (input.charCodeAt(i)) {
      case CODE_BACKSLASH:
        if (!afterBackslash) {
          afterBackslash = true;
          continue;
        }
      case CODE_SLASH:
        if (afterBackslash) {
          input = input.slice(0, i - 1) + input.slice(i), --i, --n;
        }
        break;
    }
    afterBackslash = false;
  }
  return input;
}
function isNodeValue(option) {
  return isObject(option) && typeof option.node === "function";
}
function isLinkValue(option) {
  return isObject(option) && typeof option.link === "function";
}
function maybeNodeValue(value) {
  if (isNodeValue(value)) return value.node;
  value = `${value}`.trim().toLowerCase();
  if (!value.startsWith("node:")) return;
  switch (value) {
    case "node:name":
      return nodeName;
    case "node:path":
      return nodePath;
    case "node:internal":
      return nodeInternal;
    case "node:external":
      return nodeExternal;
    case "node:depth":
      return nodeDepth;
    case "node:height":
      return nodeHeight;
  }
  throw new Error(`invalid node value: ${value}`);
}
function maybeLinkValue(value) {
  if (isNodeValue(value)) return value.node;
  if (isLinkValue(value)) return value.link;
  value = `${value}`.trim().toLowerCase();
  if (!value.startsWith("node:") && !value.startsWith("parent:")) return;
  switch (value) {
    case "parent:name":
      return parentValue(nodeName);
    case "parent:path":
      return parentValue(nodePath);
    case "parent:depth":
      return parentValue(nodeDepth);
    case "parent:height":
      return parentValue(nodeHeight);
    case "node:name":
      return nodeName;
    case "node:path":
      return nodePath;
    case "node:internal":
      return nodeInternal;
    case "node:external":
      return nodeExternal;
    case "node:depth":
      return nodeDepth;
    case "node:height":
      return nodeHeight;
  }
  throw new Error(`invalid link value: ${value}`);
}
function nodePath(node) {
  return node.id;
}
function nodeName(node) {
  return nameof(node.id);
}
function nodeDepth(node) {
  return node.depth;
}
function nodeHeight(node) {
  return node.height;
}
function nodeInternal(node) {
  return !!node.children;
}
function nodeExternal(node) {
  return !node.children;
}
function parentValue(evaluate) {
  return (child, parent) => parent == null ? void 0 : evaluate(parent);
}
function nameof(path) {
  let i = path.length;
  while (--i > 0) if (slash(path, i)) break;
  return slashUnescape(path.slice(i + 1));
}
function slash(path, i) {
  if (path[i] === "/") {
    let k = 0;
    while (i > 0 && path[--i] === "\\") ++k;
    if ((k & 1) === 0) return true;
  }
  return false;
}
var output_setValues = 2;
var output_evaluate = 3;
var output_values = 4;
function treeOutputs(options, maybeTreeValue) {
  const outputs = [];
  for (const name in options) {
    const value = options[name];
    const treeValue = maybeTreeValue(value);
    if (treeValue !== void 0) {
      outputs.push([name, ...column(value), treeValue]);
    }
  }
  return outputs;
}

// node_modules/@observablehq/plot/src/marks/tree.js
function tree(data, {
  fill,
  stroke,
  strokeWidth,
  strokeOpacity,
  strokeLinejoin,
  strokeLinecap,
  strokeMiterlimit,
  strokeDasharray,
  strokeDashoffset,
  marker,
  markerStart = marker,
  markerEnd = marker,
  dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd),
  text: textText = "node:name",
  textStroke = "var(--plot-background)",
  title = "node:path",
  dx,
  dy,
  textAnchor,
  treeLayout = tree_default,
  textLayout = treeLayout === tree_default || treeLayout === cluster_default ? "mirrored" : "normal",
  tip: tip2,
  ...options
} = {}) {
  if (dx === void 0) dx = maybeTreeAnchor(options.treeAnchor).dx;
  if (textAnchor !== void 0) throw new Error("textAnchor is not a configurable tree option");
  textLayout = keyword(textLayout, "textLayout", ["mirrored", "normal"]);
  function treeText(textOptions2) {
    return text(
      data,
      treeNode({
        treeLayout,
        text: textText,
        fill: fill === void 0 ? "currentColor" : fill,
        stroke: textStroke,
        dx,
        dy,
        title,
        ...textOptions2,
        ...options
      })
    );
  }
  return marks(
    link(
      data,
      treeLink({
        treeLayout,
        markerStart,
        markerEnd,
        stroke: stroke !== void 0 ? stroke : fill === void 0 ? "node:internal" : fill,
        strokeWidth,
        strokeOpacity,
        strokeLinejoin,
        strokeLinecap,
        strokeMiterlimit,
        strokeDasharray,
        strokeDashoffset,
        ...options
      })
    ),
    dotDot ? dot(data, treeNode({ treeLayout, fill: fill === void 0 ? "node:internal" : fill, title, tip: tip2, ...options })) : null,
    textText != null ? textLayout === "mirrored" ? [
      treeText({ textAnchor: "start", treeFilter: "node:external" }),
      treeText({ textAnchor: "end", treeFilter: "node:internal", dx: -dx })
    ] : treeText() : null
  );
}
function cluster(data, options) {
  return tree(data, { ...options, treeLayout: cluster_default });
}

// node_modules/@observablehq/plot/src/marks/waffle.js
var waffleDefaults = {
  ariaLabel: "waffle"
};
var WaffleX = class extends BarX {
  constructor(data, { unit: unit2 = 1, gap = 1, round: round2, multiple, ...options } = {}) {
    super(data, wafflePolygon("x", options), waffleDefaults);
    this.unit = Math.max(0, unit2);
    this.gap = +gap;
    this.round = maybeRound2(round2);
    this.multiple = maybeMultiple(multiple);
  }
};
var WaffleY = class extends BarY {
  constructor(data, { unit: unit2 = 1, gap = 1, round: round2, multiple, ...options } = {}) {
    super(data, wafflePolygon("y", options), waffleDefaults);
    this.unit = Math.max(0, unit2);
    this.gap = +gap;
    this.round = maybeRound2(round2);
    this.multiple = maybeMultiple(multiple);
  }
};
function wafflePolygon(y, options) {
  const x = y === "y" ? "x" : "y";
  const y1 = `${y}1`;
  const y2 = `${y}2`;
  return initializer(waffleRender(options), function(data, facets, channels, scales, dimensions) {
    const { round: round2, unit: unit2 } = this;
    const Y1 = channels[y1].value;
    const Y2 = channels[y2].value;
    const xy = valueObject({ ...x in channels && { [x]: channels[x] }, [y1]: channels[y1], [y2]: channels[y2] }, scales);
    const barwidth = this[y === "y" ? "_width" : "_height"](scales, xy, dimensions);
    const barx = this[y === "y" ? "_x" : "_y"](scales, xy, dimensions);
    const scale2 = unit2 * scaleof(scales.scales[y]);
    const { multiple = Math.max(1, Math.floor(Math.sqrt(barwidth / scale2))) } = this;
    const cx = Math.min(barwidth / multiple, scale2 * multiple);
    const cy = scale2 * multiple;
    const tx = (barwidth - multiple * cx) / 2;
    const x0 = typeof barx === "function" ? (i) => barx(i) + tx : barx + tx;
    const y0 = scales[y](0);
    const transform = y === "y" ? ([x2, y3]) => [x2 * cx, -y3 * cy] : ([x2, y3]) => [y3 * cy, x2 * cx];
    const mx = typeof x0 === "function" ? (i) => x0(i) - barwidth / 2 : () => x0;
    const [ix, iy] = y === "y" ? [0, 1] : [1, 0];
    const n = Y2.length;
    const P = new Array(n);
    const X = new Float64Array(n);
    const Y = new Float64Array(n);
    for (let i = 0; i < n; ++i) {
      P[i] = wafflePoints(round2(Y1[i] / unit2), round2(Y2[i] / unit2), multiple).map(transform);
      const c = P[i].pop();
      X[i] = c[ix] + mx(i);
      Y[i] = c[iy] + y0;
    }
    return {
      channels: {
        polygon: { value: P, source: null, filter: null },
        [`c${x}`]: { value: [cx, x0], source: null, filter: null },
        [`c${y}`]: { value: [cy, y0], source: null, filter: null },
        [x]: { value: X, scale: null, source: null },
        [y1]: { value: Y, scale: null, source: channels[y1] },
        [y2]: { value: Y, scale: null, source: channels[y2] }
      }
    };
  });
}
function waffleRender({ render, ...options }) {
  return {
    ...options,
    render: composeRender(render, function(index, scales, values2, dimensions, context) {
      const { gap, rx, ry } = this;
      const { channels, ariaLabel, href, title, ...visualValues } = values2;
      const { document } = context;
      const polygon = channels.polygon.value;
      const [cx, x0] = channels.cx.value;
      const [cy, y0] = channels.cy.value;
      const patternId = getPatternId();
      const basePattern = document.createElementNS(namespaces_default.svg, "pattern");
      basePattern.setAttribute("width", cx);
      basePattern.setAttribute("height", cy);
      basePattern.setAttribute("patternUnits", "userSpaceOnUse");
      const basePatternRect = basePattern.appendChild(document.createElementNS(namespaces_default.svg, "rect"));
      basePatternRect.setAttribute("x", gap / 2);
      basePatternRect.setAttribute("y", gap / 2);
      basePatternRect.setAttribute("width", cx - gap);
      basePatternRect.setAttribute("height", cy - gap);
      if (rx != null) basePatternRect.setAttribute("rx", rx);
      if (ry != null) basePatternRect.setAttribute("ry", ry);
      return create("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
        (g) => g.selectAll().data(index).enter().append(() => basePattern.cloneNode(true)).attr("id", (i) => `${patternId}-${i}`).select("rect").call(applyDirectStyles, this).call(applyChannelStyles, this, visualValues)
      ).call(
        (g) => g.selectAll().data(index).enter().append("path").attr("transform", template`translate(${x0},${y0})`).attr("d", (i) => `M${polygon[i].join("L")}Z`).attr("fill", (i) => `url(#${patternId}-${i})`).attr("stroke", this.stroke == null ? null : "none").call(applyChannelStyles, this, { ariaLabel, href, title })
      ).node();
    })
  };
}
function wafflePoints(i1, i2, columns) {
  if (i2 < i1) return wafflePoints(i2, i1, columns);
  if (i1 < 0) return wafflePointsOffset(i1, i2, columns, Math.ceil(-Math.min(i1, i2) / columns));
  const x1f = Math.floor(i1 % columns);
  const x1c = Math.ceil(i1 % columns);
  const x2f = Math.floor(i2 % columns);
  const x2c = Math.ceil(i2 % columns);
  const y1f = Math.floor(i1 / columns);
  const y1c = Math.ceil(i1 / columns);
  const y2f = Math.floor(i2 / columns);
  const y2c = Math.ceil(i2 / columns);
  const points = [];
  if (y2c > y1c) points.push([0, y1c]);
  points.push([x1f, y1c], [x1f, y1f + i1 % 1], [x1c, y1f + i1 % 1]);
  if (!(i1 % columns > columns - 1)) {
    points.push([x1c, y1f]);
    if (y2f > y1f) points.push([columns, y1f]);
  }
  if (y2f > y1f) points.push([columns, y2f]);
  points.push([x2c, y2f], [x2c, y2f + i2 % 1], [x2f, y2f + i2 % 1]);
  if (!(i2 % columns < 1)) {
    points.push([x2f, y2c]);
    if (y2c > y1c) points.push([0, y2c]);
  }
  points.push(waffleCentroid(i1, i2, columns));
  return points;
}
function wafflePointsOffset(i1, i2, columns, k) {
  return wafflePoints(i1 + k * columns, i2 + k * columns, columns).map(([x, y]) => [x, y - k]);
}
function waffleCentroid(i1, i2, columns) {
  const r = Math.floor(i2 / columns) - Math.floor(i1 / columns);
  return r === 0 ? (
    // Single row
    waffleRowCentroid(i1, i2, columns)
  ) : r === 1 ? (
    // Two incomplete rows; use the midpoint of their overlap if any, otherwise the larger row
    Math.floor(i2 % columns) > Math.ceil(i1 % columns) ? [(Math.floor(i2 % columns) + Math.ceil(i1 % columns)) / 2, Math.floor(i2 / columns)] : i2 % columns > columns - i1 % columns ? waffleRowCentroid(i2 - i2 % columns, i2, columns) : waffleRowCentroid(i1, columns * Math.ceil(i1 / columns), columns)
  ) : (
    // At least one full row; take the midpoint of all the rows that include the middle
    [columns / 2, (Math.round(i1 / columns) + Math.round(i2 / columns)) / 2]
  );
}
function waffleRowCentroid(i1, i2, columns) {
  const c = Math.floor(i2) - Math.floor(i1);
  return c === 0 ? (
    // Single cell
    [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (i1 + i2) / 2 % 1]
  ) : c === 1 ? (
    // Two incomplete cells; use the overlap if large enough, otherwise use the largest
    i2 % 1 - i1 % 1 > 0.5 ? [Math.ceil(i1 % columns), Math.floor(i2 / columns) + (i1 % 1 + i2 % 1) / 2] : i2 % 1 > 1 - i1 % 1 ? [Math.floor(i2 % columns) + 0.5, Math.floor(i2 / columns) + i2 % 1 / 2] : [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (1 + i1 % 1) / 2]
  ) : (
    // At least one full cell; take the midpoint
    [
      Math.ceil(i1 % columns) + Math.ceil(Math.floor(i2) - Math.ceil(i1)) / 2,
      Math.floor(i1 / columns) + (i2 >= 1 + i1 ? 0.5 : (i1 + i2) / 2 % 1)
    ]
  );
}
function maybeRound2(round2) {
  if (round2 === void 0 || round2 === false) return Number;
  if (round2 === true) return Math.round;
  if (typeof round2 !== "function") throw new Error(`invalid round: ${round2}`);
  return round2;
}
function maybeMultiple(multiple) {
  return multiple === void 0 ? void 0 : Math.max(1, Math.floor(multiple));
}
function scaleof({ domain, range: range3 }) {
  return spread(range3) / spread(domain);
}
function spread(domain) {
  const [min2, max2] = extent(domain);
  return max2 - min2;
}
function waffleX(data, { tip: tip2, ...options } = {}) {
  if (!hasXY(options)) options = { ...options, y: indexOf, x2: identity2 };
  return new WaffleX(data, { tip: waffleTip(tip2), ...maybeStackX(maybeIntervalX(maybeIdentityX(options))) });
}
function waffleY(data, { tip: tip2, ...options } = {}) {
  if (!hasXY(options)) options = { ...options, x: indexOf, y2: identity2 };
  return new WaffleY(data, { tip: waffleTip(tip2), ...maybeStackY(maybeIntervalY(maybeIdentityY(options))) });
}
function waffleTip(tip2) {
  return tip2 === true ? { maxRadius: Infinity } : isObject(tip2) && tip2.maxRadius === void 0 ? { ...tip2, maxRadius: Infinity } : void 0;
}

// node_modules/@observablehq/plot/src/transforms/dodge.js
var import_interval_tree_1d = __toESM(require_interval_tree(), 1);
var anchorXLeft = ({ marginLeft }) => [1, marginLeft];
var anchorXRight = ({ width, marginRight }) => [-1, width - marginRight];
var anchorXMiddle = ({ width, marginLeft, marginRight }) => [0, (marginLeft + width - marginRight) / 2];
var anchorYTop = ({ marginTop }) => [1, marginTop];
var anchorYBottom = ({ height, marginBottom }) => [-1, height - marginBottom];
var anchorYMiddle = ({ height, marginTop, marginBottom }) => [0, (marginTop + height - marginBottom) / 2];
function maybeAnchor4(anchor) {
  return typeof anchor === "string" ? { anchor } : anchor;
}
function dodgeX(dodgeOptions = {}, options = {}) {
  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions3(dodgeOptions);
  let { anchor = "left", padding = 1, r = options.r } = maybeAnchor4(dodgeOptions);
  switch (`${anchor}`.toLowerCase()) {
    case "left":
      anchor = anchorXLeft;
      break;
    case "right":
      anchor = anchorXRight;
      break;
    case "middle":
      anchor = anchorXMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("x", "y", anchor, number(padding), r, options);
}
function dodgeY(dodgeOptions = {}, options = {}) {
  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions3(dodgeOptions);
  let { anchor = "bottom", padding = 1, r = options.r } = maybeAnchor4(dodgeOptions);
  switch (`${anchor}`.toLowerCase()) {
    case "top":
      anchor = anchorYTop;
      break;
    case "bottom":
      anchor = anchorYBottom;
      break;
    case "middle":
      anchor = anchorYMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("y", "x", anchor, number(padding), r, options);
}
function mergeOptions3(options) {
  const { anchor, padding, ...rest } = options;
  const { r } = rest;
  return [{ anchor, padding, r }, rest];
}
function dodge(y, x, anchor, padding, r, options) {
  if (r != null && typeof r !== "number") {
    let { channels, sort: sort3, reverse: reverse3 } = options;
    channels = maybeNamed(channels);
    if ((channels == null ? void 0 : channels.r) === void 0) options = { ...options, channels: { ...channels, r: { value: r, scale: "r" } } };
    if (sort3 === void 0 && reverse3 === void 0) options.sort = { channel: "-r" };
  }
  return initializer(options, function(data, facets, channels, scales, dimensions, context) {
    let { [x]: X, r: R } = channels;
    if (!channels[x]) throw new Error(`missing channel: ${x}`);
    ({ [x]: X } = applyPosition(channels, scales, context));
    const cr = R ? void 0 : r !== void 0 ? number(r) : this.r !== void 0 ? this.r : 3;
    if (R) R = valueof(R.value, scales[R.scale] || identity2, Float64Array);
    let [ky, ty] = anchor(dimensions);
    const compare = ky ? compareAscending : compareSymmetric;
    const Y = new Float64Array(X.length);
    const radius2 = R ? (i) => R[i] : () => cr;
    for (let I of facets) {
      const tree2 = (0, import_interval_tree_1d.default)();
      I = I.filter(R ? (i) => finite(X[i]) && positive(R[i]) : (i) => finite(X[i]));
      const intervals = new Float64Array(2 * I.length + 2);
      for (const i of I) {
        const ri = radius2(i);
        const y0 = ky ? ri + padding : 0;
        const l = X[i] - ri;
        const h = X[i] + ri;
        let k = 2;
        tree2.queryInterval(l - padding, h + padding, ([, , j]) => {
          const yj = Y[j] - y0;
          const dx = X[i] - X[j];
          const dr = padding + (R ? R[i] + R[j] : 2 * cr);
          const dy = Math.sqrt(dr * dr - dx * dx);
          intervals[k++] = yj - dy;
          intervals[k++] = yj + dy;
        });
        let candidates = intervals.slice(0, k);
        if (ky) candidates = candidates.filter((y2) => y2 >= 0);
        out: for (const y2 of candidates.sort(compare)) {
          for (let j = 0; j < k; j += 2) {
            if (intervals[j] + 1e-6 < y2 && y2 < intervals[j + 1] - 1e-6) {
              continue out;
            }
          }
          Y[i] = y2 + y0;
          break;
        }
        tree2.insert([l, h, i]);
      }
    }
    if (!ky) ky = 1;
    for (const I of facets) {
      for (const i of I) {
        Y[i] = Y[i] * ky + ty;
      }
    }
    return {
      data,
      facets,
      channels: {
        [y]: { value: Y, source: null },
        // don’t show in tooltip
        [x]: { value: X, source: channels[x] },
        ...R && { r: { value: R, source: channels.r } }
      }
    };
  });
}
function compareSymmetric(a, b) {
  return Math.abs(a) - Math.abs(b);
}
function compareAscending(a, b) {
  return a - b;
}

// node_modules/@observablehq/plot/src/transforms/normalize.js
function normalizeX(basis, options) {
  if (arguments.length === 1) ({ basis, ...options } = basis);
  return mapX(normalize(basis), options);
}
function normalizeY(basis, options) {
  if (arguments.length === 1) ({ basis, ...options } = basis);
  return mapY(normalize(basis), options);
}
function normalize(basis) {
  if (basis === void 0) return normalizeFirst;
  if (typeof basis === "function") return normalizeBasis(taker(basis));
  if (/^p\d{2}$/i.test(basis)) return normalizeAccessor(percentile(basis));
  switch (`${basis}`.toLowerCase()) {
    case "deviation":
      return normalizeDeviation;
    case "first":
      return normalizeFirst;
    case "last":
      return normalizeLast;
    case "max":
      return normalizeMax;
    case "mean":
      return normalizeMean;
    case "median":
      return normalizeMedian;
    case "min":
      return normalizeMin;
    case "sum":
      return normalizeSum;
    case "extent":
      return normalizeExtent;
  }
  throw new Error(`invalid basis: ${basis}`);
}
function normalizeBasis(basis) {
  return {
    mapIndex(I, S, T) {
      const b = +basis(I, S);
      for (const i of I) {
        T[i] = S[i] === null ? NaN : S[i] / b;
      }
    }
  };
}
function normalizeAccessor(f) {
  return normalizeBasis((I, S) => f(I, (i) => S[i]));
}
var normalizeExtent = {
  mapIndex(I, S, T) {
    const [s1, s2] = extent(I, (i) => S[i]);
    const d = s2 - s1;
    for (const i of I) {
      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;
    }
  }
};
var normalizeFirst = normalizeBasis((I, S) => {
  for (let i = 0; i < I.length; ++i) {
    const s = S[I[i]];
    if (defined(s)) return s;
  }
});
var normalizeLast = normalizeBasis((I, S) => {
  for (let i = I.length - 1; i >= 0; --i) {
    const s = S[I[i]];
    if (defined(s)) return s;
  }
});
var normalizeDeviation = {
  mapIndex(I, S, T) {
    const m = mean(I, (i) => S[i]);
    const d = deviation(I, (i) => S[i]);
    for (const i of I) {
      T[i] = S[i] === null ? NaN : d ? (S[i] - m) / d : 0;
    }
  }
};
var normalizeMax = normalizeAccessor(max);
var normalizeMean = normalizeAccessor(mean);
var normalizeMedian = normalizeAccessor(median);
var normalizeMin = normalizeAccessor(min);
var normalizeSum = normalizeAccessor(sum);

// node_modules/@observablehq/plot/src/transforms/shift.js
function shiftX(interval, options) {
  return shiftK("x", interval, options);
}
function shiftY(interval, options) {
  return shiftK("y", interval, options);
}
function shiftK(x, interval, options = {}) {
  let offset2;
  let k = 1;
  if (typeof interval === "number") {
    k = interval;
    offset2 = (x3, k2) => +x3 + k2;
  } else {
    if (typeof interval === "string") {
      const sign = interval.startsWith("-") ? -1 : 1;
      [interval, k] = parseTimeInterval(interval.replace(/^[+-]/, ""));
      k *= sign;
    }
    interval = maybeInterval(interval);
    offset2 = (x3, k2) => interval.offset(x3, k2);
  }
  const x1 = `${x}1`;
  const x2 = `${x}2`;
  const mapped = map2(
    {
      [x1]: (D) => D.map((d) => offset2(d, k)),
      [x2]: (D) => D
    },
    options
  );
  const t = mapped[x2].transform;
  mapped[x2].transform = () => {
    const V = t();
    const [x0, x12] = extent(V);
    V.domain = k < 0 ? [x0, offset2(x12, k)] : [offset2(x0, k), x12];
    return V;
  };
  return mapped;
}

// node_modules/@observablehq/plot/src/transforms/select.js
function select(selector, options = {}) {
  if (typeof selector === "string") {
    switch (selector.toLowerCase()) {
      case "first":
        return selectFirst(options);
      case "last":
        return selectLast(options);
    }
  }
  if (typeof selector === "function") {
    return selectChannel(null, selector, options);
  }
  let key, value;
  for (key in selector) {
    if (value !== void 0) throw new Error("ambiguous selector; multiple inputs");
    value = maybeSelector(selector[key]);
  }
  if (value === void 0) throw new Error(`invalid selector: ${selector}`);
  return selectChannel(key, value, options);
}
function maybeSelector(selector) {
  if (typeof selector === "function") return selector;
  switch (`${selector}`.toLowerCase()) {
    case "min":
      return selectorMin;
    case "max":
      return selectorMax;
  }
  throw new Error(`unknown selector: ${selector}`);
}
function selectFirst(options) {
  return selectChannel(null, selectorFirst, options);
}
function selectLast(options) {
  return selectChannel(null, selectorLast, options);
}
function selectMinX(options) {
  return selectChannel("x", selectorMin, options);
}
function selectMinY(options) {
  return selectChannel("y", selectorMin, options);
}
function selectMaxX(options) {
  return selectChannel("x", selectorMax, options);
}
function selectMaxY(options) {
  return selectChannel("y", selectorMax, options);
}
function* selectorFirst(I) {
  yield I[0];
}
function* selectorLast(I) {
  yield I[I.length - 1];
}
function* selectorMin(I, X) {
  yield least(I, (i) => X[i]);
}
function* selectorMax(I, X) {
  yield greatest(I, (i) => X[i]);
}
function selectChannel(v, selector, options) {
  if (v != null) {
    if (options[v] == null) throw new Error(`missing channel: ${v}`);
    v = options[v];
  }
  const z = maybeZ(options);
  return basic(options, (data, facets) => {
    const Z = valueof(data, z);
    const V = valueof(data, v);
    const selectFacets = [];
    for (const facet of facets) {
      const selectFacet = [];
      for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
        for (const i of selector(I, V)) {
          selectFacet.push(i);
        }
      }
      selectFacets.push(selectFacet);
    }
    return { data, facets: selectFacets };
  });
}

// node_modules/@observablehq/plot/src/index.js
Mark.prototype.plot = function({ marks: marks2 = [], ...options } = {}) {
  return plot({ ...options, marks: [...marks2, this] });
};
export {
  Area,
  Arrow,
  BarX,
  BarY,
  Cell,
  Contour,
  Density,
  Dot,
  Frame,
  Geo,
  Hexgrid,
  Image,
  Line,
  Link,
  Mark,
  Raster,
  Rect,
  RuleX,
  RuleY,
  Text,
  TickX,
  TickY,
  Tip,
  Vector,
  WaffleX,
  WaffleY,
  area,
  areaX,
  areaY,
  arrow,
  auto,
  autoSpec,
  axisFx,
  axisFy,
  axisX,
  axisY,
  barX,
  barY,
  bin,
  binX,
  binY,
  bollinger,
  bollingerX,
  bollingerY,
  boxX,
  boxY,
  cell,
  cellX,
  cellY,
  centroid,
  circle,
  cluster,
  column,
  contour,
  crosshair,
  crosshairX,
  crosshairY,
  delaunayLink,
  delaunayMesh,
  density,
  differenceX,
  differenceY,
  dodgeX,
  dodgeY,
  dot,
  dotX,
  dotY,
  filter,
  find,
  formatIsoDate,
  formatMonth,
  formatNumber,
  formatWeekday,
  frame,
  geo,
  geoCentroid,
  graticule,
  gridFx,
  gridFy,
  gridX,
  gridY,
  group2 as group,
  groupX,
  groupY,
  groupZ,
  hexagon,
  hexbin,
  hexgrid,
  hull,
  identity2 as identity,
  image,
  indexOf,
  initializer,
  interpolateNearest,
  interpolateNone,
  interpolatorBarycentric,
  interpolatorRandomWalk,
  legend,
  line,
  lineX,
  lineY,
  linearRegressionX,
  linearRegressionY,
  link,
  map2 as map,
  mapX,
  mapY,
  marks,
  normalize,
  normalizeX,
  normalizeY,
  numberInterval,
  plot,
  pointer,
  pointerX,
  pointerY,
  raster,
  rect,
  rectX,
  rectY,
  reverse2 as reverse,
  ruleX,
  ruleY,
  scale,
  select,
  selectFirst,
  selectLast,
  selectMaxX,
  selectMaxY,
  selectMinX,
  selectMinY,
  shiftX,
  shiftY,
  shuffle,
  sort2 as sort,
  sphere2 as sphere,
  spike,
  stackX,
  stackX1,
  stackX2,
  stackY,
  stackY1,
  stackY2,
  text,
  textX,
  textY,
  tickX,
  tickY,
  timeInterval,
  tip,
  basic as transform,
  tree,
  treeLink,
  treeNode,
  utcInterval,
  valueof,
  vector,
  vectorX,
  vectorY,
  voronoi,
  voronoiMesh,
  waffleX,
  waffleY,
  window2 as window,
  windowX,
  windowY
};
//# sourceMappingURL=@observablehq_plot.js.map

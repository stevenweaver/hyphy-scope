import {
  axisTop,
  basis_default2 as basis_default,
  brush_default,
  create_default,
  format,
  hierarchy,
  line_default,
  linear2 as linear,
  max,
  select_default,
  stepBefore,
  timeParse,
  zoom_default2 as zoom_default
} from "./chunk-3P4ERZQU.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-B4Q33VKO.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX2 = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee2, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee2(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee2) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee2(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee2) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee2(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee2) {
        var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
        while (++index < length) {
          result2[index] = iteratee2(array[index], index, array);
        }
        return result2;
      }
      function arrayPush(array, values2) {
        var index = -1, length = values2.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee2, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee2(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee2, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee2(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result2;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result2 = key;
            return false;
          }
        });
        return result2;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee2) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee2) / length : NAN;
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee2) {
        var result2, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee2(array[index]);
          if (current !== undefined2) {
            result2 = result2 === undefined2 ? current : result2 + current;
          }
        }
        return result2;
      }
      function baseTimes(n, iteratee2) {
        var index = -1, result2 = Array(n);
        while (++index < n) {
          result2[index] = iteratee2(index);
        }
        return result2;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key) {
          return [key, object2[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key) {
          return object2[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result2 = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result2;
          }
        }
        return result2;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object2, key) {
        return object2 == null ? undefined2 : object2[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result2 = [];
        while (!(data = iterator.next()).done) {
          result2.push(data.value);
        }
        return result2;
      }
      function mapToArray(map4) {
        var index = -1, result2 = Array(map4.size);
        map4.forEach(function(value, key) {
          result2[++index] = [key, value];
        });
        return result2;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result2[resIndex++] = index;
          }
        }
        return result2;
      }
      function setToArray(set) {
        var index = -1, result2 = Array(set.size);
        set.forEach(function(value) {
          result2[++index] = value;
        });
        return result2;
      }
      function setToPairs(set) {
        var index = -1, result2 = Array(set.size);
        set.forEach(function(value) {
          result2[++index] = [value, value];
        });
        return result2;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result2 = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result2;
        }
        return result2;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _6.defaults(root2.Object(), context, _6.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter2 = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys2 = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate2 = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate2 = /* @__PURE__ */ function() {
          function object2() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object2.prototype = proto;
            var result3 = new object2();
            object2.prototype = undefined2;
            return result3;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result3 = new LazyWrapper(this.__wrapped__);
          result3.__actions__ = copyArray(this.__actions__);
          result3.__dir__ = this.__dir__;
          result3.__filtered__ = this.__filtered__;
          result3.__iteratees__ = copyArray(this.__iteratees__);
          result3.__takeCount__ = this.__takeCount__;
          result3.__views__ = copyArray(this.__views__);
          return result3;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result3 = new LazyWrapper(this);
            result3.__dir__ = -1;
            result3.__filtered__ = true;
          } else {
            result3 = this.clone();
            result3.__dir__ *= -1;
          }
          return result3;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result3 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee3 = data.iteratee, type = data.type, computed = iteratee3(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result3[resIndex++] = value;
            }
          return result3;
        }
        LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result3 = this.has(key) && delete this.__data__[key];
          this.size -= result3 ? 1 : 0;
          return result3;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate2) {
            var result3 = data[key];
            return result3 === HASH_UNDEFINED ? undefined2 : result3;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate2 ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate2 && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result3 = getMapData(this, key)["delete"](key);
          this.size -= result3 ? 1 : 0;
          return result3;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size3 = data.size;
          data.set(key, value);
          this.size += data.size == size3 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values3) {
          var index = -1, length = values3 == null ? 0 : values3.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values3[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result3 = data["delete"](key);
          this.size = data.size;
          return result3;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs2 = data.__data__;
            if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
              pairs2.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs2);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes(value.length, String2) : [], length = result3.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result3.push(key);
            }
          }
          return result3;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object2, key, value) {
          if (value !== undefined2 && !eq2(object2[key], value) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assignValue(object2, key, value) {
          var objValue = object2[key];
          if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee3, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee3(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys3(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object2, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object2[key] = value;
          }
        }
        function baseAt(object2, paths) {
          var index = -1, length = paths.length, result3 = Array2(length), skip = object2 == null;
          while (++index < length) {
            result3[index] = skip ? undefined2 : get2(object2, paths[index]);
          }
          return result3;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object2, stack) {
          var result3, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result3 = object2 ? customizer(value, key, object2, stack) : customizer(value);
          }
          if (result3 !== undefined2) {
            return result3;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result3 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result3);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              result3 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result3, value)) : copySymbols(value, baseAssign(result3, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result3 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result3);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result3.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result3.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys3;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result3, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result3;
        }
        function baseConforms(source) {
          var props = keys3(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length = props.length;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (length--) {
            var key = props[length], predicate = source[key], value = object2[key];
            if (value === undefined2 && !(key in object2) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values3, iteratee3, comparator) {
          var index = -1, includes3 = arrayIncludes, isCommon = true, length = array.length, result3 = [], valuesLength = values3.length;
          if (!length) {
            return result3;
          }
          if (iteratee3) {
            values3 = arrayMap(values3, baseUnary(iteratee3));
          }
          if (comparator) {
            includes3 = arrayIncludesWith;
            isCommon = false;
          } else if (values3.length >= LARGE_ARRAY_SIZE) {
            includes3 = cacheHas;
            isCommon = false;
            values3 = new SetCache(values3);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee3 == null ? value : iteratee3(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values3[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result3.push(value);
              } else if (!includes3(values3, computed, comparator)) {
                result3.push(value);
              }
            }
          return result3;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result3 = true;
          baseEach(collection, function(value, index, collection2) {
            result3 = !!predicate(value, index, collection2);
            return result3;
          });
          return result3;
        }
        function baseExtremum(array, iteratee3, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee3(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result3 = value;
            }
          }
          return result3;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result3 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result3.push(value);
            }
          });
          return result3;
        }
        function baseFlatten(array, depth, predicate, isStrict, result3) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result3 || (result3 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result3);
              } else {
                arrayPush(result3, value);
              }
            } else if (!isStrict) {
              result3[result3.length] = value;
            }
          }
          return result3;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee3) {
          return object2 && baseFor(object2, iteratee3, keys3);
        }
        function baseForOwnRight(object2, iteratee3) {
          return object2 && baseForRight(object2, iteratee3, keys3);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object2[key]);
          });
        }
        function baseGet(object2, path) {
          path = castPath(path, object2);
          var index = 0, length = path.length;
          while (object2 != null && index < length) {
            object2 = object2[toKey(path[index++])];
          }
          return index && index == length ? object2 : undefined2;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result3 = keysFunc(object2);
          return isArray(object2) ? result3 : arrayPush(result3, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object2, key) {
          return object2 != null && hasOwnProperty2.call(object2, key);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object2(object2);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee3, comparator) {
          var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result3 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee3) {
              array = arrayMap(array, baseUnary(iteratee3));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee3 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result3.length < maxLength) {
              var value = array[index], computed = iteratee3 ? iteratee3(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes3(result3, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes3(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result3.push(value);
              }
            }
          return result3;
        }
        function baseInverter(object2, setter, iteratee3, accumulator) {
          baseForOwn(object2, function(value, key, object3) {
            setter(accumulator, iteratee3(value), key, object3);
          });
          return accumulator;
        }
        function baseInvoke(object2, path, args) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          var func = object2 == null ? object2 : object2[toKey(last2(path))];
          return func == null ? undefined2 : apply(func, object2, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object2)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result3 = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result3 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result3)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee2(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property2(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys2(object2);
          }
          var result3 = [];
          for (var key in Object2(object2)) {
            if (hasOwnProperty2.call(object2, key) && key != "constructor") {
              result3.push(key);
            }
          }
          return result3;
        }
        function baseKeysIn(object2) {
          if (!isObject2(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result3 = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
              result3.push(key);
            }
          }
          return result3;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee3) {
          var index = -1, result3 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result3[++index] = iteratee3(value, key, collection2);
          });
          return result3;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object2) {
            var objValue = get2(object2, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments2(srcValue)) {
              newValue = objValue;
              if (isArguments2(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee3) {
              if (isArray(iteratee3)) {
                return function(value) {
                  return baseGet(value, iteratee3.length === 1 ? iteratee3[0] : iteratee3);
                };
              }
              return iteratee3;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result3 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee3) {
              return iteratee3(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result3, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths) {
          return basePickBy(object2, paths, function(value, path) {
            return hasIn(object2, path);
          });
        }
        function basePickBy(object2, paths, predicate) {
          var index = -1, length = paths.length, result3 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object2, path);
            if (predicate(value, path)) {
              baseSet(result3, castPath(path, object2), value);
            }
          }
          return result3;
        }
        function basePropertyDeep(path) {
          return function(object2) {
            return baseGet(object2, path);
          };
        }
        function basePullAll(array, values3, iteratee3, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values3.length, seen = array;
          if (array === values3) {
            values3 = copyArray(values3);
          }
          if (iteratee3) {
            seen = arrayMap(array, baseUnary(iteratee3));
          }
          while (++index < length) {
            var fromIndex = 0, value = values3[index], computed = iteratee3 ? iteratee3(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result3 = Array2(length);
          while (length--) {
            result3[fromRight ? length : ++index] = start;
            start += step;
          }
          return result3;
        }
        function baseRepeat(string, n) {
          var result3 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result3;
          }
          do {
            if (n % 2) {
              result3 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result3;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values2(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object2, path, value, customizer) {
          if (!isObject2(object2)) {
            return object2;
          }
          path = castPath(path, object2);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant3(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result3 = Array2(length);
          while (++index < length) {
            result3[index] = array[index + start];
          }
          return result3;
        }
        function baseSome(collection, predicate) {
          var result3;
          baseEach(collection, function(value, index, collection2) {
            result3 = predicate(value, index, collection2);
            return !result3;
          });
          return !!result3;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee3, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee3(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee3(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX2);
        }
        function baseSortedUniq(array, iteratee3) {
          var index = -1, length = array.length, resIndex = 0, result3 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee3 ? iteratee3(value) : value;
            if (!index || !eq2(computed, seen)) {
              var seen = computed;
              result3[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result3;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result3 = value + "";
          return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
        }
        function baseUniq(array, iteratee3, comparator) {
          var index = -1, includes3 = arrayIncludes, length = array.length, isCommon = true, result3 = [], seen = result3;
          if (comparator) {
            isCommon = false;
            includes3 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee3 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes3 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee3 ? [] : result3;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee3 ? iteratee3(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee3) {
                  seen.push(computed);
                }
                result3.push(value);
              } else if (!includes3(seen, computed, comparator)) {
                if (seen !== result3) {
                  seen.push(computed);
                }
                result3.push(value);
              }
            }
          return result3;
        }
        function baseUnset(object2, path) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          return object2 == null || delete object2[toKey(last2(path))];
        }
        function baseUpdate(object2, path, updater, customizer) {
          return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result3 = value;
          if (result3 instanceof LazyWrapper) {
            result3 = result3.value();
          }
          return arrayReduce(actions, function(result4, action) {
            return action.func.apply(action.thisArg, arrayPush([result4], action.args));
          }, result3);
        }
        function baseXor(arrays, iteratee3, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result3 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result3[index] = baseDifference(result3[index] || array, arrays[othIndex], iteratee3, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result3, 1), iteratee3, comparator);
        }
        function baseZipObject(props, values3, assignFunc) {
          var index = -1, length = props.length, valsLength = values3.length, result3 = {};
          while (++index < length) {
            var value = index < valsLength ? values3[index] : undefined2;
            assignFunc(result3, props[index], value);
          }
          return result3;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object2) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object2) ? [value] : stringToPath(toString2(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result3);
          return result3;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result3).set(new Uint8Array2(arrayBuffer));
          return result3;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result3 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result3.lastIndex = regexp.lastIndex;
          return result3;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result3 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result3) {
              if (index >= ordersLength) {
                return result3;
              }
              var order = orders[index];
              return result3 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result3[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result3[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result3[leftIndex++] = args[argsIndex++];
          }
          return result3;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result3[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result3[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result3[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result3;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object2, key, newValue);
            } else {
              assignValue(object2, key, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee3) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee3, 2), accumulator);
          };
        }
        function createAssigner2(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object2 = Object2(object2);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee3) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee3);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee3(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee3, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee3(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString2(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate2(Ctor.prototype), result3 = Ctor.apply(thisBinding, args);
            return isObject2(result3) ? result3 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee3 = getIteratee(predicate, 3);
              collection = keys3(collection);
              predicate = function(key) {
                return iteratee3(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee3 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result3 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result3 = funcs[index2].call(this, result3);
              }
              return result3;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee3) {
            return baseInverter(object2, setter, toIteratee(iteratee3), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result3;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result3 = value;
            }
            if (other !== undefined2) {
              if (result3 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result3 = operator(value, other);
            }
            return result3;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee3) {
                return apply(iteratee3, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result3 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result3), 0, length).join("") : result3.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result3 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result3, newData);
          }
          result3.placeholder = placeholder;
          return setWrapToString(result3, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber2(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop2 : function(values3) {
          return new Set(values3);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag(object2);
            if (tag == mapTag) {
              return mapToArray(object2);
            }
            if (tag == setTag) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result3 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result3 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result3 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result3 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result3, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object2) {
          if (objValue === undefined2 || eq2(objValue, objectProto[key]) && !hasOwnProperty2.call(object2, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result3 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result3 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result3 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result3 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result3;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq2(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result3 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result3;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result3 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result3 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result3 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result3 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result3;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten3), func + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys3, getSymbols);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result3 = func.name + "", array = realNames[result3], length = hasOwnProperty2.call(realNames, result3) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result3;
        }
        function getHolder(func) {
          var object2 = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object2.placeholder;
        }
        function getIteratee() {
          var result3 = lodash.iteratee || iteratee2;
          result3 = result3 === iteratee2 ? baseIteratee2 : result3;
          return arguments.length ? result3(arguments[0], arguments[1]) : result3;
        }
        function getMapData(map5, key) {
          var data = map5.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result3 = keys3(object2), length = result3.length;
          while (length--) {
            var key = result3[length], value = object2[key];
            result3[length] = [key, value, isStrictComparable(value)];
          }
          return result3;
        }
        function getNative(object2, key) {
          var value = getValue(object2, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result3 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result3;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result3 = [];
          while (object2) {
            arrayPush(result3, getSymbols(object2));
            object2 = getPrototype(object2);
          }
          return result3;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result3 = baseGetTag(value), Ctor = result3 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result3;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size3 = data.size;
            switch (data.type) {
              case "drop":
                start += size3;
                break;
              case "dropRight":
                end -= size3;
                break;
              case "take":
                end = nativeMin(end, start + size3);
                break;
              case "takeRight":
                start = nativeMax(start, end - size3);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path, hasFunc) {
          path = castPath(path, object2);
          var index = -1, length = path.length, result3 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result3 = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result3 || ++index != length) {
            return result3;
          }
          length = object2 == null ? 0 : object2.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments2(object2));
        }
        function initCloneArray(array) {
          var length = array.length, result3 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result3.index = array.index;
            result3.input = array.input;
          }
          return result3;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate2(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object2) {
          if (!isObject2(object2)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
            return eq2(object2[index], value);
          }
          return false;
        }
        function isKey(value, object2) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
          };
        }
        function memoizeCapped(func) {
          var result3 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result3.cache;
          return result3;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object2) {
          var result3 = [];
          if (object2 != null) {
            for (var key in Object2(object2)) {
              result3.push(key);
            }
          }
          return result3;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object2, path) {
          return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object2, key) {
          if (key === "constructor" && typeof object2[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object2[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size3) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size3 = size3 === undefined2 ? length : size3;
          while (++index < size3) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size3;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result3 = [];
          if (string.charCodeAt(0) === 46) {
            result3.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result3.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result3;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result3 = value + "";
          return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result3 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result3.__actions__ = copyArray(wrapper.__actions__);
          result3.__index__ = wrapper.__index__;
          result3.__values__ = wrapper.__values__;
          return result3;
        }
        function chunk3(array, size3, guard) {
          if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined2) {
            size3 = 1;
          } else {
            size3 = nativeMax(toInteger(size3), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size3 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result3 = Array2(nativeCeil(length / size3));
          while (index < length) {
            result3[resIndex++] = baseSlice(array, index, index += size3);
          }
          return result3;
        }
        function compact2(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result3 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result3[resIndex++] = value;
            }
          }
          return result3;
        }
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values3) {
          var iteratee3 = last2(values3);
          if (isArrayLikeObject(iteratee3)) {
            iteratee3 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee3, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values3) {
          var comparator = last2(values3);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill2(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten3(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs2) {
          var index = -1, length = pairs2 == null ? 0 : pairs2.length, result3 = {};
          while (++index < length) {
            var pair = pairs2[index];
            result3[pair[0]] = pair[1];
          }
          return result3;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection2 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee3 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee3 === last2(mapped)) {
            iteratee3 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee3, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values3) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
        }
        function pullAllBy(array, values3, iteratee3) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee3, 2)) : array;
        }
        function pullAllWith(array, values3, comparator) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result3 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result3;
        });
        function remove3(array, predicate) {
          var result3 = [];
          if (!(array && array.length)) {
            return result3;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result3.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result3;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice3(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex2(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee3) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee3, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq2(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee3) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee3, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq2(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee3) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee3, 2)) : [];
        }
        function tail2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee3 = last2(arrays);
          if (isArrayLikeObject(iteratee3)) {
            iteratee3 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee3, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq2(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee3) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee3, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip2(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group2) {
            if (isArrayLikeObject(group2)) {
              length = nativeMax(group2.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee3) {
          if (!(array && array.length)) {
            return [];
          }
          var result3 = unzip2(array);
          if (iteratee3 == null) {
            return result3;
          }
          return arrayMap(result3, function(group2) {
            return apply(iteratee3, undefined2, group2);
          });
        }
        var without = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee3 = last2(arrays);
          if (isArrayLikeObject(iteratee3)) {
            iteratee3 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee3, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip2);
        function zipObject(props, values3) {
          return baseZipObject(props || [], values3 || [], assignValue);
        }
        function zipObjectDeep(props, values3) {
          return baseZipObject(props || [], values3 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee3 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee3 = typeof iteratee3 == "function" ? (arrays.pop(), iteratee3) : undefined2;
          return unzipWith(arrays, iteratee3);
        });
        function chain3(value) {
          var result3 = lodash(value);
          result3.__chain__ = true;
          return result3;
        }
        function tap2(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain3(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray2(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result3, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result3) {
              previous.__wrapped__ = clone3;
            } else {
              result3 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result3;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result3, value, key) {
          if (hasOwnProperty2.call(result3, key)) {
            ++result3[key];
          } else {
            baseAssignValue(result3, key, 1);
          }
        });
        function every2(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter3(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee3) {
          return baseFlatten(map4(collection, iteratee3), 1);
        }
        function flatMapDeep(collection, iteratee3) {
          return baseFlatten(map4(collection, iteratee3), INFINITY);
        }
        function flatMapDepth(collection, iteratee3, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map4(collection, iteratee3), depth);
        }
        function forEach(collection, iteratee3) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee3, 3));
        }
        function forEachRight(collection, iteratee3) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee3, 3));
        }
        var groupBy = createAggregator(function(result3, value, key) {
          if (hasOwnProperty2.call(result3, key)) {
            result3[key].push(value);
          } else {
            baseAssignValue(result3, key, [value]);
          }
        });
        function includes2(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result3 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result3[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result3;
        });
        var keyBy = createAggregator(function(result3, value, key) {
          baseAssignValue(result3, key, value);
        });
        function map4(collection, iteratee3) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee3, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result3, value, key) {
          result3[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee3, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee3, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee3, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee3, 4), accumulator, initAccum, baseEachRight);
        }
        function reject2(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate2(getIteratee(predicate, 3)));
        }
        function sample2(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle2(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size2(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some2(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy2 = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root2.Date.now();
        };
        function after2(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before2(n, func) {
          var result3;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result3 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result3;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object2, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object2, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result3 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result3.placeholder = curry.placeholder;
          return result3;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result3 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result3.placeholder = curryRight.placeholder;
          return result3;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber2(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result3 = func.apply(thisArg, args);
            return result3;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result3;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result3;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result3 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result3;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result3 = func.apply(this, args);
            memoized.cache = cache.set(key, result3) || cache;
            return result3;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate2(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before2(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial2 = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial2));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest2(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap2(value, wrapper) {
          return partial2(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys3(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments2 = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement2(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments2(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result3 = customizer ? customizer(value, other) : undefined2;
          return result3 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result3;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite3(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch2(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN3(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull2(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result3 = toFinite(value), remainder = result3 % 1;
          return result3 === result3 ? remainder ? result3 - remainder : result3 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner2(function(object2, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys3(source), object2);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object2, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner2(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner2(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner2(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys3(source), object2, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result3 = baseCreate2(prototype);
          return properties == null ? result3 : baseAssign(result3, properties);
        }
        var defaults = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object2[key];
              if (value === undefined2 || eq2(value, objectProto[key]) && !hasOwnProperty2.call(object2, key)) {
                object2[key] = source[key];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey2(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee3) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee3, 3), keysIn);
        }
        function forInRight(object2, iteratee3) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee3, 3), keysIn);
        }
        function forOwn(object2, iteratee3) {
          return object2 && baseForOwn(object2, getIteratee(iteratee3, 3));
        }
        function forOwnRight(object2, iteratee3) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee3, 3));
        }
        function functions2(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys3(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get2(object2, path, defaultValue) {
          var result3 = object2 == null ? undefined2 : baseGet(object2, path);
          return result3 === undefined2 ? defaultValue : result3;
        }
        function has3(object2, path) {
          return object2 != null && hasPath(object2, path, baseHas);
        }
        function hasIn(object2, path) {
          return object2 != null && hasPath(object2, path, baseHasIn);
        }
        var invert2 = createInverter(function(result3, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result3[value] = key;
        }, constant3(identity2));
        var invertBy = createInverter(function(result3, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result3, value)) {
            result3[value].push(key);
          } else {
            result3[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys3(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys(object2, iteratee3) {
          var result3 = {};
          iteratee3 = getIteratee(iteratee3, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result3, iteratee3(value, key, object3), value);
          });
          return result3;
        }
        function mapValues2(object2, iteratee3) {
          var result3 = {};
          iteratee3 = getIteratee(iteratee3, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result3, key, iteratee3(value, key, object3));
          });
          return result3;
        }
        var merge = createAssigner2(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith = createAssigner2(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object2, paths) {
          var result3 = {};
          if (object2 == null) {
            return result3;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object2);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object2, getAllKeysIn(object2), result3);
          if (isDeep) {
            result3 = baseClone(result3, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result3, paths[length]);
          }
          return result3;
        });
        function omitBy(object2, predicate) {
          return pickBy(object2, negate2(getIteratee(predicate)));
        }
        var pick = flatRest(function(object2, paths) {
          return object2 == null ? {} : basePick(object2, paths);
        });
        function pickBy(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result2(object2, path, defaultValue) {
          path = castPath(path, object2);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object2 = undefined2;
          }
          while (++index < length) {
            var value = object2 == null ? undefined2 : object2[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object2 = isFunction2(value) ? value.call(object2) : value;
          }
          return object2;
        }
        function set(object2, path, value) {
          return object2 == null ? object2 : baseSet(object2, path, value);
        }
        function setWith(object2, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseSet(object2, path, value, customizer);
        }
        var toPairs = createToPairs(keys3);
        var toPairsIn = createToPairs(keysIn);
        function transform(object2, iteratee3, accumulator) {
          var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray2(object2);
          iteratee3 = getIteratee(iteratee3, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object2)) {
              accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object3) {
            return iteratee3(accumulator, value, index, object3);
          });
          return accumulator;
        }
        function unset(object2, path) {
          return object2 == null ? true : baseUnset(object2, path);
        }
        function update(object2, path, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
        }
        function updateWith(object2, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
        }
        function values2(object2) {
          return object2 == null ? [] : baseValues(object2, keys3(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber2(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber2(number);
          return baseInRange(number, start, end);
        }
        function random2(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result3, word, index) {
          word = word.toLowerCase();
          return result3 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString2(string).toLowerCase());
        }
        function deburr(string) {
          string = toString2(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString2(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString2(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp2(string) {
          string = toString2(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt3(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString2(string), n);
        }
        function replace() {
          var args = arguments, string = toString2(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? "_" : "") + word.toLowerCase();
        });
        function split3(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString2(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString2(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template2(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString2(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys3(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result3 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result3.source = source;
          if (isError(result3)) {
            throw result3;
          }
          return result3;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim2(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString2(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result3 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result3 + omission;
          }
          if (strSymbols) {
            end += result3.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result3;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result3 = result3.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result3.lastIndexOf(separator);
            if (index > -1) {
              result3 = result3.slice(0, index);
            }
          }
          return result3 + omission;
        }
        function unescape(string) {
          string = toString2(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString2(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object2, key, bind(object2[key], object2));
          });
          return object2;
        });
        function cond(pairs2) {
          var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
          pairs2 = !length ? [] : arrayMap(pairs2, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs2[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant3(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee2(func) {
          return baseIteratee2(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object2) {
            return baseInvoke(object2, path, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path) {
            return baseInvoke(object2, path, args);
          };
        });
        function mixin2(object2, source, options) {
          var props = keys3(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys3(source));
          }
          var chain4 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object2);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object2[methodName] = func;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain4 || chainAll) {
                  var result3 = object2(this.__wrapped__), actions = result3.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                  result3.__chain__ = chainAll;
                  return result3;
                }
                return func.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property2(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf2(object2) {
          return function(path) {
            return object2 == null ? undefined2 : baseGet(object2, path);
          };
        }
        var range3 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times2(n, iteratee3) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee3 = getIteratee(iteratee3);
          n -= MAX_ARRAY_LENGTH;
          var result3 = baseTimes(length, iteratee3);
          while (++index < n) {
            iteratee3(index);
          }
          return result3;
        }
        function toPath3(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
        }
        function uniqueId2(prefix) {
          var id = ++idCounter2;
          return toString2(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max4(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
        }
        function maxBy(array, iteratee3) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee3, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee3) {
          return baseMean(array, getIteratee(iteratee3, 2));
        }
        function min3(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
        }
        function minBy(array, iteratee3) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee3, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum2(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee3) {
          return array && array.length ? baseSum(array, getIteratee(iteratee3, 2)) : 0;
        }
        lodash.after = after2;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before2;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain3;
        lodash.chunk = chunk3;
        lodash.compact = compact2;
        lodash.concat = concat2;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant3;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill2;
        lodash.filter = filter3;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten3;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions2;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial2;
        lodash.intersection = intersection2;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert2;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee2;
        lodash.keyBy = keyBy;
        lodash.keys = keys3;
        lodash.keysIn = keysIn;
        lodash.map = map4;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues2;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin2;
        lodash.negate = negate2;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial2;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property2;
        lodash.propertyOf = propertyOf2;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range3;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject2;
        lodash.remove = remove3;
        lodash.rest = rest2;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle2;
        lodash.slice = slice3;
        lodash.sortBy = sortBy2;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split3;
        lodash.spread = spread;
        lodash.tail = tail2;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap2;
        lodash.throttle = throttle2;
        lodash.thru = thru;
        lodash.toArray = toArray2;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath3;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq2;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip2;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values2;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap2;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin2(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq2;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp2;
        lodash.every = every2;
        lodash.find = find2;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey2;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get2;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has3;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes2;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments2;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement2;
        lodash.isEmpty = isEmpty2;
        lodash.isEqual = isEqual2;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite3;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch2;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN3;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray2;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last2;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max4;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min3;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt3;
        lodash.random = random2;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result2;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample2;
        lodash.size = size2;
        lodash.snakeCase = snakeCase;
        lodash.some = some2;
        lodash.sortedIndex = sortedIndex2;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum2;
        lodash.sumBy = sumBy;
        lodash.template = template2;
        lodash.times = times2;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber2;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString2;
        lodash.toUpper = toUpper;
        lodash.trim = trim2;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId2;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin2(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result3 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result3.__filtered__) {
              result3.__takeCount__ = nativeMin(n, result3.__takeCount__);
            } else {
              result3.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result3.__dir__ < 0 ? "Right" : "")
              });
            }
            return result3;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee3) {
            var result3 = this.clone();
            result3.__iteratees__.push({
              "iteratee": getIteratee(iteratee3, 3),
              "type": type
            });
            result3.__filtered__ = result3.__filtered__ || isFilter;
            return result3;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate2(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result3 = this;
          if (result3.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result3);
          }
          if (start < 0) {
            result3 = result3.takeRight(-start);
          } else if (start) {
            result3 = result3.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result3 = end < 0 ? result3.dropRight(-end) : result3.take(end - start);
          }
          return result3;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee3 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result4 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result4[0] : result4;
            };
            if (useLazy && checkIteratee && typeof iteratee3 == "function" && iteratee3.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result3 = func.apply(value, args);
              result3.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result3, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result3 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _6 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _6;
        define(function() {
          return _6;
        });
      } else if (freeModule) {
        (freeModule.exports = _6)._ = _6;
        freeExports._ = _6;
      } else {
        root2._ = _6;
      }
    }).call(exports2);
  }
});

// node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max2,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});

// node_modules/underscore/modules/_setup.js
var VERSION = "1.13.7";
var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
var push = ArrayProto.push;
var slice = ArrayProto.slice;
var toString = ObjProto.toString;
var hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
var supportsDataView = typeof DataView !== "undefined";
var nativeIsArray = Array.isArray;
var nativeKeys = Object.keys;
var nativeCreate = Object.create;
var nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN;
var _isFinite = isFinite;
var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
var nonEnumerableProps = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

// node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}

// node_modules/underscore/modules/isObject.js
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}

// node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}

// node_modules/underscore/modules/isUndefined.js
function isUndefined(obj) {
  return obj === void 0;
}

// node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}

// node_modules/underscore/modules/isElement.js
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

// node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}

// node_modules/underscore/modules/isString.js
var isString_default = tagTester("String");

// node_modules/underscore/modules/isNumber.js
var isNumber_default = tagTester("Number");

// node_modules/underscore/modules/isDate.js
var isDate_default = tagTester("Date");

// node_modules/underscore/modules/isRegExp.js
var isRegExp_default = tagTester("RegExp");

// node_modules/underscore/modules/isError.js
var isError_default = tagTester("Error");

// node_modules/underscore/modules/isSymbol.js
var isSymbol_default = tagTester("Symbol");

// node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default = tagTester("ArrayBuffer");

// node_modules/underscore/modules/isFunction.js
var isFunction = tagTester("Function");
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
  isFunction = function(obj) {
    return typeof obj == "function" || false;
  };
}
var isFunction_default = isFunction;

// node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default = tagTester("Object");

// node_modules/underscore/modules/_stringTagBug.js
var hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag_default(new DataView(new ArrayBuffer(8))));
var isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());

// node_modules/underscore/modules/isDataView.js
var isDataView = tagTester("DataView");
function alternateIsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView_default = hasDataViewBug ? alternateIsDataView : isDataView;

// node_modules/underscore/modules/isArray.js
var isArray_default = nativeIsArray || tagTester("Array");

// node_modules/underscore/modules/_has.js
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}

// node_modules/underscore/modules/isArguments.js
var isArguments = tagTester("Arguments");
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has(obj, "callee");
    };
  }
})();
var isArguments_default = isArguments;

// node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}

// node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}

// node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}

// node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}

// node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}

// node_modules/underscore/modules/_getByteLength.js
var getByteLength_default = shallowProperty("byteLength");

// node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default = createSizePropertyCheck(getByteLength_default);

// node_modules/underscore/modules/isTypedArray.js
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString.call(obj));
}
var isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);

// node_modules/underscore/modules/_getLength.js
var getLength_default = shallowProperty("length");

// node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys3) {
  var hash = {};
  for (var l = keys3.length, i = 0; i < l; ++i) hash[keys3[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys3.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys3) {
  keys3 = emulatedSet(keys3);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj, prop) && !keys3.contains(prop)) keys3.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys3.contains(prop)) {
      keys3.push(prop);
    }
  }
}

// node_modules/underscore/modules/keys.js
function keys(obj) {
  if (!isObject(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys3 = [];
  for (var key in obj) if (has(obj, key)) keys3.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys3);
  return keys3;
}

// node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null) return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj))) return length === 0;
  return getLength_default(keys(obj)) === 0;
}

// node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null) return !length;
  var obj = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}

// node_modules/underscore/modules/underscore.js
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}
_.VERSION = VERSION;
_.prototype.value = function() {
  return this._wrapped;
};
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
_.prototype.toString = function() {
  return String(this._wrapped);
};

// node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}

// node_modules/underscore/modules/isEqual.js
var tagDataView = "[object DataView]";
function eq(a, b, aStack, bStack) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null) return false;
  if (a !== a) return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _) a = a._wrapped;
  if (b instanceof _) b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  if (hasDataViewBug && className == "[object Object]" && isDataView_default(a)) {
    if (!isDataView_default(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a)) {
    var byteLength = getByteLength_default(a);
    if (byteLength !== getByteLength_default(b)) return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length) return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}

// node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject(obj)) return [];
  var keys3 = [];
  for (var key in obj) keys3.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys3);
  return keys3;
}

// node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null) return false;
    var keys3 = allKeys(obj);
    if (getLength_default(keys3)) return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction_default(obj[methods[i]])) return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName = "forEach";
var hasName = "has";
var commonInit = ["clear", "delete"];
var mapTail = ["get", hasName, "set"];
var mapMethods = commonInit.concat(forEachName, mapTail);
var weakMapMethods = commonInit.concat(mapTail);
var setMethods = ["add"].concat(commonInit, forEachName, hasName);

// node_modules/underscore/modules/isMap.js
var isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");

// node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");

// node_modules/underscore/modules/isSet.js
var isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");

// node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default = tagTester("WeakSet");

// node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj[_keys[i]];
  }
  return values2;
}

// node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs2;
}

// node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj[_keys[i]]] = _keys[i];
  }
  return result2;
}

// node_modules/underscore/modules/functions.js
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction_default(obj[key])) names.push(key);
  }
  return names.sort();
}

// node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys3 = keysFunc(source), l = keys3.length;
      for (var i = 0; i < l; i++) {
        var key = keys3[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}

// node_modules/underscore/modules/extend.js
var extend_default = createAssigner(allKeys);

// node_modules/underscore/modules/extendOwn.js
var extendOwn_default = createAssigner(keys);

// node_modules/underscore/modules/defaults.js
var defaults_default = createAssigner(allKeys, true);

// node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}

// node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props) extendOwn_default(result2, props);
  return result2;
}

// node_modules/underscore/modules/clone.js
function clone(obj) {
  if (!isObject(obj)) return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}

// node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}

// node_modules/underscore/modules/toPath.js
function toPath(path) {
  return isArray_default(path) ? path : [path];
}
_.toPath = toPath;

// node_modules/underscore/modules/_toPath.js
function toPath2(path) {
  return _.toPath(path);
}

// node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}

// node_modules/underscore/modules/get.js
function get(object2, path, defaultValue) {
  var value = deepGet(object2, toPath2(path));
  return isUndefined(value) ? defaultValue : value;
}

// node_modules/underscore/modules/has.js
function has2(obj, path) {
  path = toPath2(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}

// node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}

// node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}

// node_modules/underscore/modules/property.js
function property(path) {
  path = toPath2(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}

// node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}

// node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (isFunction_default(value)) return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray_default(value)) return matcher(value);
  return property(value);
}

// node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_.iteratee = iteratee;

// node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee) return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}

// node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}

// node_modules/underscore/modules/noop.js
function noop() {
}

// node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path) {
    return get(obj, path);
  };
}

// node_modules/underscore/modules/times.js
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee2(i);
  return accum;
}

// node_modules/underscore/modules/random.js
function random(min3, max4) {
  if (max4 == null) {
    max4 = min3;
    min3 = 0;
  }
  return min3 + Math.floor(Math.random() * (max4 - min3 + 1));
}

// node_modules/underscore/modules/now.js
var now_default = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};

// node_modules/underscore/modules/_createEscaper.js
function createEscaper(map4) {
  var escaper = function(match) {
    return map4[match];
  };
  var source = "(?:" + keys(map4).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}

// node_modules/underscore/modules/_escapeMap.js
var escapeMap_default = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

// node_modules/underscore/modules/escape.js
var escape_default = createEscaper(escapeMap_default);

// node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default = invert(escapeMap_default);

// node_modules/underscore/modules/unescape.js
var unescape_default = createEscaper(unescapeMap_default);

// node_modules/underscore/modules/templateSettings.js
var templateSettings_default = _.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};

// node_modules/underscore/modules/template.js
var noMatch = /(.)^/;
var escapes = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
  return "\\" + escapes[match];
}
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;
    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument)) throw new Error(
      "variable is not a bare identifier: " + argument
    );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}

// node_modules/underscore/modules/result.js
function result(obj, path, fallback) {
  path = toPath2(path);
  var length = path.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}

// node_modules/underscore/modules/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}

// node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}

// node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject(result2)) return result2;
  return self2;
}

// node_modules/underscore/modules/partial.js
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});
partial.placeholder = _;
var partial_default = partial;

// node_modules/underscore/modules/bind.js
var bind_default = restArguments(function(func, context, args) {
  if (!isFunction_default(func)) throw new TypeError("Bind must be called on a function");
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
});

// node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default = createSizePropertyCheck(getLength_default);

// node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength_default(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

// node_modules/underscore/modules/bindAll.js
var bindAll_default = restArguments(function(obj, keys3) {
  keys3 = flatten(keys3, false, false);
  var index = keys3.length;
  if (index < 1) throw new Error("bindAll must be passed function names");
  while (index--) {
    var key = keys3[index];
    obj[key] = bind_default(obj[key], obj);
  }
  return obj;
});

// node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}

// node_modules/underscore/modules/delay.js
var delay_default = restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
});

// node_modules/underscore/modules/defer.js
var defer_default = partial_default(delay_default, _, 1);

// node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options) options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}

// node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result2 = func.apply(context, args);
      if (!timeout) args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}

// node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}

// node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

// node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--) result2 = args[i].call(this, result2);
    return result2;
  };
}

// node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}

// node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1) func = null;
    return memo;
  };
}

// node_modules/underscore/modules/once.js
var once_default = partial_default(before, 2);

// node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}

// node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}

// node_modules/underscore/modules/findIndex.js
var findIndex_default = createPredicateIndexFinder(1);

// node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default = createPredicateIndexFinder(-1);

// node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value) low = mid + 1;
    else high = mid;
  }
  return low;
}

// node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN2);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}

// node_modules/underscore/modules/indexOf.js
var indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);

// node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);

// node_modules/underscore/modules/find.js
function find(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}

// node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}

// node_modules/underscore/modules/each.js
function each(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i, length;
  if (isArrayLike_default(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee2(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}

// node_modules/underscore/modules/map.js
function map(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}

// node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}

// node_modules/underscore/modules/reduce.js
var reduce_default = createReduce(1);

// node_modules/underscore/modules/reduceRight.js
var reduceRight_default = createReduce(-1);

// node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}

// node_modules/underscore/modules/reject.js
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}

// node_modules/underscore/modules/every.js
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}

// node_modules/underscore/modules/some.js
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}

// node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj)) obj = values(obj);
  if (typeof fromIndex != "number" || guard) fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}

// node_modules/underscore/modules/invoke.js
var invoke_default = restArguments(function(obj, path, args) {
  var contextPath, func;
  if (isFunction_default(path)) {
    func = path;
  } else {
    path = toPath2(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
});

// node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map(obj, property(key));
}

// node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}

// node_modules/underscore/modules/max.js
function max2(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}

// node_modules/underscore/modules/min.js
function min(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}

// node_modules/underscore/modules/toArray.js
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (isArray_default(obj)) return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj)) return map(obj, identity);
  return values(obj);
}

// node_modules/underscore/modules/sample.js
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike_default(obj)) obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength_default(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}

// node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}

// node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), "value");
}

// node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj, function(value, index) {
      var key = iteratee2(value, index, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}

// node_modules/underscore/modules/groupBy.js
var groupBy_default = group(function(result2, value, key) {
  if (has(result2, key)) result2[key].push(value);
  else result2[key] = [value];
});

// node_modules/underscore/modules/indexBy.js
var indexBy_default = group(function(result2, value, key) {
  result2[key] = value;
});

// node_modules/underscore/modules/countBy.js
var countBy_default = group(function(result2, value, key) {
  if (has(result2, key)) result2[key]++;
  else result2[key] = 1;
});

// node_modules/underscore/modules/partition.js
var partition_default = group(function(result2, value, pass) {
  result2[pass ? 0 : 1].push(value);
}, true);

// node_modules/underscore/modules/size.js
function size(obj) {
  if (obj == null) return 0;
  return isArrayLike_default(obj) ? obj.length : keys(obj).length;
}

// node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}

// node_modules/underscore/modules/pick.js
var pick_default = restArguments(function(obj, keys3) {
  var result2 = {}, iteratee2 = keys3[0];
  if (obj == null) return result2;
  if (isFunction_default(iteratee2)) {
    if (keys3.length > 1) iteratee2 = optimizeCb(iteratee2, keys3[1]);
    keys3 = allKeys(obj);
  } else {
    iteratee2 = keyInObj;
    keys3 = flatten(keys3, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys3.length; i < length; i++) {
    var key = keys3[i];
    var value = obj[key];
    if (iteratee2(value, key, obj)) result2[key] = value;
  }
  return result2;
});

// node_modules/underscore/modules/omit.js
var omit_default = restArguments(function(obj, keys3) {
  var iteratee2 = keys3[0], context;
  if (isFunction_default(iteratee2)) {
    iteratee2 = negate(iteratee2);
    if (keys3.length > 1) context = keys3[1];
  } else {
    keys3 = map(flatten(keys3, false, false), String);
    iteratee2 = function(value, key) {
      return !contains(keys3, key);
    };
  }
  return pick_default(obj, iteratee2, context);
});

// node_modules/underscore/modules/initial.js
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}

// node_modules/underscore/modules/first.js
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}

// node_modules/underscore/modules/rest.js
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}

// node_modules/underscore/modules/last.js
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}

// node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}

// node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}

// node_modules/underscore/modules/difference.js
var difference_default = restArguments(function(array, rest2) {
  rest2 = flatten(rest2, true, true);
  return filter(array, function(value) {
    return !contains(rest2, value);
  });
});

// node_modules/underscore/modules/without.js
var without_default = restArguments(function(array, otherArrays) {
  return difference_default(array, otherArrays);
});

// node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null) iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed) result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}

// node_modules/underscore/modules/union.js
var union_default = restArguments(function(arrays) {
  return uniq(flatten(arrays, true, true));
});

// node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result2.push(item);
  }
  return result2;
}

// node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max2(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}

// node_modules/underscore/modules/zip.js
var zip_default = restArguments(unzip);

// node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength_default(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}

// node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range3 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range3[idx] = start;
  }
  return range3;
}

// node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice.call(array, i, i += count));
  }
  return result2;
}

// node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}

// node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}

// node_modules/underscore/modules/underscore-array-methods.js
each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === "shift" || name === "splice") && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});
each(["concat", "join", "slice"], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});
var underscore_array_methods_default = _;

// node_modules/underscore/modules/index-default.js
var _2 = mixin(modules_exports);
_2._ = _2;

// node_modules/fast-xml-parser/src/util.js
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
var regexName = new RegExp("^" + nameRegexp + "$");
function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
}
var isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === "undefined");
};
function isExist(v) {
  return typeof v !== "undefined";
}

// node_modules/fast-xml-parser/src/validator.js
var defaultOptions = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
function validate(xmlData, options) {
  options = Object.assign({}, defaultOptions, options);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err) return i;
    } else if (xmlData[i] === "<") {
      let tagStartPos = i;
      i++;
      if (xmlData[i] === "!") {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === "/") {
          closingTag = true;
          i++;
        }
        let tagName = "";
        for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
        }
        const result2 = readAttributeStr(xmlData, i);
        if (result2 === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result2.value;
        i = result2.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result2.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
          } else if (options.unpairedTags.indexOf(tagName) !== -1) {
          } else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "!") {
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === "?") {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else {
              break;
            }
          } else if (xmlData[i] === "&") {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        }
        if (xmlData[i] === "<") {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
}
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == "?" || xmlData[i] == " ") {
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  }
  return i;
}
var doubleQuote = '"';
var singleQuote = "'";
function readAttributeStr(xmlData, i) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
      } else {
        startChar = "";
      }
    } else if (xmlData[i] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed
  };
}
var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString(attrStr, options) {
  const matches = getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === "x") {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ";")
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  i++;
  if (xmlData[i] === ";")
    return -1;
  if (xmlData[i] === "#") {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ";")
      break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return isName(attrName);
}
function validateTagName(tagname) {
  return isName(tagname);
}
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var defaultOptions2 = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(tagName, val) {
    return val;
  },
  attributeValueProcessor: function(attrName, val) {
    return val;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(tagName, jPath, attrs) {
    return tagName;
  },
  // skipEmptyListItem: false
  captureMetaData: false
};
var buildOptions = function(options) {
  return Object.assign({}, defaultOptions2, options);
};

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var METADATA_SYMBOL;
if (typeof Symbol !== "function") {
  METADATA_SYMBOL = "@@xmlMetadata";
} else {
  METADATA_SYMBOL = Symbol("XML Node Metadata");
}
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname;
    this.child = [];
    this[":@"] = {};
  }
  add(key, val) {
    if (key === "__proto__") key = "#__proto__";
    this.child.push({ [key]: val });
  }
  addChild(node, startIndex) {
    if (node.tagname === "__proto__") node.tagname = "#__proto__";
    if (node[":@"] && Object.keys(node[":@"]).length > 0) {
      this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
    } else {
      this.child.push({ [node.tagname]: node.child });
    }
    if (startIndex !== void 0) {
      this.child[this.child.length - 1][METADATA_SYMBOL] = { startIndex };
    }
  }
  /** symbol used for metadata */
  static getMetaDataSymbol() {
    return METADATA_SYMBOL;
  }
};

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
function readDocType(xmlData, i) {
  const entities = {};
  if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
    i = i + 9;
    let angleBracketsCount = 1;
    let hasBody = false, comment = false;
    let exp = "";
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && !comment) {
        if (hasBody && hasSeq(xmlData, "!ENTITY", i)) {
          i += 7;
          let entityName, val;
          [entityName, val, i] = readEntityExp(xmlData, i + 1);
          if (val.indexOf("&") === -1)
            entities[entityName] = {
              regx: RegExp(`&${entityName};`, "g"),
              val
            };
        } else if (hasBody && hasSeq(xmlData, "!ELEMENT", i)) {
          i += 8;
          const { index } = readElementExp(xmlData, i + 1);
          i = index;
        } else if (hasBody && hasSeq(xmlData, "!ATTLIST", i)) {
          i += 8;
        } else if (hasBody && hasSeq(xmlData, "!NOTATION", i)) {
          i += 9;
          const { index } = readNotationExp(xmlData, i + 1);
          i = index;
        } else if (hasSeq(xmlData, "!--", i)) comment = true;
        else throw new Error(`Invalid DOCTYPE`);
        angleBracketsCount++;
        exp = "";
      } else if (xmlData[i] === ">") {
        if (comment) {
          if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
            comment = false;
            angleBracketsCount--;
          }
        } else {
          angleBracketsCount--;
        }
        if (angleBracketsCount === 0) {
          break;
        }
      } else if (xmlData[i] === "[") {
        hasBody = true;
      } else {
        exp += xmlData[i];
      }
    }
    if (angleBracketsCount !== 0) {
      throw new Error(`Unclosed DOCTYPE`);
    }
  } else {
    throw new Error(`Invalid Tag instead of DOCTYPE`);
  }
  return { entities, i };
}
var skipWhitespace = (data, index) => {
  while (index < data.length && /\s/.test(data[index])) {
    index++;
  }
  return index;
};
function readEntityExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let entityName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i]) && xmlData[i] !== '"' && xmlData[i] !== "'") {
    entityName += xmlData[i];
    i++;
  }
  validateEntityName(entityName);
  i = skipWhitespace(xmlData, i);
  if (xmlData.substring(i, i + 6).toUpperCase() === "SYSTEM") {
    throw new Error("External entities are not supported");
  } else if (xmlData[i] === "%") {
    throw new Error("Parameter entities are not supported");
  }
  let entityValue = "";
  [i, entityValue] = readIdentifierVal(xmlData, i, "entity");
  i--;
  return [entityName, entityValue, i];
}
function readNotationExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let notationName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i])) {
    notationName += xmlData[i];
    i++;
  }
  validateEntityName(notationName);
  i = skipWhitespace(xmlData, i);
  const identifierType = xmlData.substring(i, i + 6).toUpperCase();
  if (identifierType !== "SYSTEM" && identifierType !== "PUBLIC") {
    throw new Error(`Expected SYSTEM or PUBLIC, found "${identifierType}"`);
  }
  i += identifierType.length;
  i = skipWhitespace(xmlData, i);
  let publicIdentifier = null;
  let systemIdentifier = null;
  if (identifierType === "PUBLIC") {
    [i, publicIdentifier] = readIdentifierVal(xmlData, i, "publicIdentifier");
    i = skipWhitespace(xmlData, i);
    if (xmlData[i] === '"' || xmlData[i] === "'") {
      [i, systemIdentifier] = readIdentifierVal(xmlData, i, "systemIdentifier");
    }
  } else if (identifierType === "SYSTEM") {
    [i, systemIdentifier] = readIdentifierVal(xmlData, i, "systemIdentifier");
    if (!systemIdentifier) {
      throw new Error("Missing mandatory system identifier for SYSTEM notation");
    }
  }
  return { notationName, publicIdentifier, systemIdentifier, index: --i };
}
function readIdentifierVal(xmlData, i, type) {
  let identifierVal = "";
  const startChar = xmlData[i];
  if (startChar !== '"' && startChar !== "'") {
    throw new Error(`Expected quoted string, found "${startChar}"`);
  }
  i++;
  while (i < xmlData.length && xmlData[i] !== startChar) {
    identifierVal += xmlData[i];
    i++;
  }
  if (xmlData[i] !== startChar) {
    throw new Error(`Unterminated ${type} value`);
  }
  i++;
  return [i, identifierVal];
}
function readElementExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let elementName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i])) {
    elementName += xmlData[i];
    i++;
  }
  if (!validateEntityName(elementName)) {
    throw new Error(`Invalid element name: "${elementName}"`);
  }
  i = skipWhitespace(xmlData, i);
  let contentModel = "";
  if (xmlData[i] === "E" && hasSeq(xmlData, "MPTY", i)) i += 4;
  else if (xmlData[i] === "A" && hasSeq(xmlData, "NY", i)) i += 2;
  else if (xmlData[i] === "(") {
    i++;
    while (i < xmlData.length && xmlData[i] !== ")") {
      contentModel += xmlData[i];
      i++;
    }
    if (xmlData[i] !== ")") {
      throw new Error("Unterminated content model");
    }
  } else {
    throw new Error(`Invalid Element Expression, found "${xmlData[i]}"`);
  }
  return {
    elementName,
    contentModel: contentModel.trim(),
    index: i
  };
}
function hasSeq(data, seq, i) {
  for (let j = 0; j < seq.length; j++) {
    if (seq[j] !== data[i + j + 1]) return false;
  }
  return true;
}
function validateEntityName(name) {
  if (isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}

// node_modules/strnum/strnum.js
var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
var consider = {
  hex: true,
  // oct: false,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function toNumber(str, options = {}) {
  options = Object.assign({}, consider, options);
  if (!str || typeof str !== "string") return str;
  let trimmedStr = str.trim();
  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;
  else if (str === "0") return 0;
  else if (options.hex && hexRegex.test(trimmedStr)) {
    return parse_int(trimmedStr, 16);
  } else if (trimmedStr.search(/.+[eE].+/) !== -1) {
    return resolveEnotation(str, trimmedStr, options);
  } else {
    const match = numRegex.exec(trimmedStr);
    if (match) {
      const sign = match[1] || "";
      const leadingZeros = match[2];
      let numTrimmedByZeros = trimZeros(match[3]);
      const decimalAdjacentToLeadingZeros = sign ? (
        // 0., -00., 000.
        str[leadingZeros.length + 1] === "."
      ) : str[leadingZeros.length] === ".";
      if (!options.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {
        return str;
      } else {
        const num = Number(trimmedStr);
        const parsedStr = String(num);
        if (num === 0) return num;
        if (parsedStr.search(/[eE]/) !== -1) {
          if (options.eNotation) return num;
          else return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (parsedStr === "0") return num;
          else if (parsedStr === numTrimmedByZeros) return num;
          else if (parsedStr === `${sign}${numTrimmedByZeros}`) return num;
          else return str;
        }
        let n = leadingZeros ? numTrimmedByZeros : trimmedStr;
        if (leadingZeros) {
          return n === parsedStr || sign + n === parsedStr ? num : str;
        } else {
          return n === parsedStr || n === sign + parsedStr ? num : str;
        }
      }
    } else {
      return str;
    }
  }
}
var eNotationRegx = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
function resolveEnotation(str, trimmedStr, options) {
  if (!options.eNotation) return str;
  const notation = trimmedStr.match(eNotationRegx);
  if (notation) {
    let sign = notation[1] || "";
    const eChar = notation[3].indexOf("e") === -1 ? "E" : "e";
    const leadingZeros = notation[2];
    const eAdjacentToLeadingZeros = sign ? (
      // 0E.
      str[leadingZeros.length + 1] === eChar
    ) : str[leadingZeros.length] === eChar;
    if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;
    else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {
      return Number(trimmedStr);
    } else if (options.leadingZeros && !eAdjacentToLeadingZeros) {
      trimmedStr = (notation[1] || "") + notation[3];
      return Number(trimmedStr);
    } else return str;
  } else {
    return str;
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".") numStr = "0";
    else if (numStr[0] === ".") numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".") numStr = numStr.substring(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
function parse_int(numStr, base) {
  if (parseInt) return parseInt(numStr, base);
  else if (Number.parseInt) return Number.parseInt(numStr, base);
  else if (window && window.parseInt) return window.parseInt(numStr, base);
  else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}

// node_modules/fast-xml-parser/src/ignoreAttributes.js
function getIgnoreAttributesFn(ignoreAttributes) {
  if (typeof ignoreAttributes === "function") {
    return ignoreAttributes;
  }
  if (Array.isArray(ignoreAttributes)) {
    return (attrName) => {
      for (const pattern of ignoreAttributes) {
        if (typeof pattern === "string" && attrName === pattern) {
          return true;
        }
        if (pattern instanceof RegExp && pattern.test(attrName)) {
          return true;
        }
      }
    };
  }
  return () => false;
}

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var OrderedObjParser = class {
  constructor(options) {
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
      "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
      "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
      "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent": { regex: /&(cent|#162);/g, val: "¢" },
      "pound": { regex: /&(pound|#163);/g, val: "£" },
      "yen": { regex: /&(yen|#165);/g, val: "¥" },
      "euro": { regex: /&(euro|#8364);/g, val: "€" },
      "copyright": { regex: /&(copy|#169);/g, val: "©" },
      "reg": { regex: /&(reg|#174);/g, val: "®" },
      "inr": { regex: /&(inr|#8377);/g, val: "₹" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_6, str) => String.fromCodePoint(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_6, str) => String.fromCodePoint(Number.parseInt(str, 16)) }
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
  }
};
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode2, escapeEntities) {
  if (val !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if (val.length > 0) {
      if (!escapeEntities) val = this.replaceEntitiesValue(val);
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode2);
      if (newval === null || newval === void 0) {
        return val;
      } else if (typeof newval !== typeof val || newval !== val) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val.trim();
        if (trimmedVal === val) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap(attrStr, jPath, tagName) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
    const matches = getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue;
      }
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__") aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
var parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  const xmlObj = new XmlNode("!xml");
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for (let i = 0; i < xmlData.length; i++) {
    const ch = xmlData[i];
    if (ch === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }
        const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop();
        textData = "";
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        let tagData = readTagExp(xmlData, i, false, "?>");
        if (!tagData) throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
        } else {
          const childNode = new XmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath, i);
        }
        i = tagData.closeIndex + 1;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const comment = xmlData.substring(i + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
        }
        i = endIndex;
      } else if (xmlData.substr(i + 1, 2) === "!D") {
        const result2 = readDocType(xmlData, i);
        this.docTypeEntities = result2.entities;
        i = result2.i;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9, closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val == void 0) val = "";
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
        } else {
          currentNode.add(this.options.textNodeName, val);
        }
        i = closeIndex + 2;
      } else {
        let result2 = readTagExp(xmlData, i, this.options.removeNSPrefix);
        let tagName = result2.tagName;
        const rawTagName = result2.rawTagName;
        let tagExp = result2.tagExp;
        let attrExpPresent = result2.attrExpPresent;
        let closeIndex = result2.closeIndex;
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode && textData) {
          if (currentNode.tagname !== "!xml") {
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }
        const lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + tagName : tagName;
        }
        const startIndex = i;
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result2.closeIndex;
          } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
            i = result2.closeIndex;
          } else {
            const result3 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if (!result3) throw new Error(`Unexpected end of ${rawTagName}`);
            i = result3.i;
            tagContent = result3.tagContent;
          }
          const childNode = new XmlNode(tagName);
          if (tagName !== tagExp && attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, childNode, jPath, startIndex);
        } else {
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            const childNode = new XmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new XmlNode(tagName);
            this.tagsNodeStack.push(currentNode);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    } else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath, startIndex) {
  if (!this.options.captureMetaData) startIndex = void 0;
  const result2 = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result2 === false) {
  } else if (typeof result2 === "string") {
    childNode.tagname = result2;
    currentNode.addChild(childNode, startIndex);
  } else {
    currentNode.addChild(childNode, startIndex);
  }
}
var replaceEntitiesValue = function(val) {
  if (this.options.processEntities) {
    for (let entityName in this.docTypeEntities) {
      const entity = this.docTypeEntities[entityName];
      val = val.replace(entity.regx, entity.val);
    }
    for (let entityName in this.lastEntities) {
      const entity = this.lastEntities[entityName];
      val = val.replace(entity.regex, entity.val);
    }
    if (this.options.htmlEntities) {
      for (let entityName in this.htmlEntities) {
        const entity = this.htmlEntities[entityName];
        val = val.replace(entity.regex, entity.val);
      }
    }
    val = val.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode2) {
  if (textData) {
    if (isLeafNode2 === void 0) isLeafNode2 = currentNode.child.length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode2
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodes, jPath, currentTagName) {
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
  }
  return false;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
      if (ch === attrBoundary) attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index
          };
        }
      } else {
        return {
          data: tagExp,
          index
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result2 = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result2) return;
  let tagExp = result2.data;
  const closeIndex = result2.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result2.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i) {
  const startIndex = i;
  let openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === "string") {
    const newval = val.trim();
    if (newval === "true") return true;
    else if (newval === "false") return false;
    else return toNumber(val, options);
  } else {
    if (isExist(val)) {
      return val;
    } else {
      return "";
    }
  }
}

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var METADATA_SYMBOL2 = XmlNode.getMetaDataSymbol();
function prettify(node, options) {
  return compress(node, options);
}
function compress(arr, options, jPath) {
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property2 = propName(tagObj);
    let newJpath = "";
    if (jPath === void 0) newJpath = property2;
    else newJpath = jPath + "." + property2;
    if (property2 === options.textNodeName) {
      if (text === void 0) text = tagObj[property2];
      else text += "" + tagObj[property2];
    } else if (property2 === void 0) {
      continue;
    } else if (tagObj[property2]) {
      let val = compress(tagObj[property2], options, newJpath);
      const isLeaf = isLeafTag(val, options);
      if (tagObj[METADATA_SYMBOL2] !== void 0) {
        val[METADATA_SYMBOL2] = tagObj[METADATA_SYMBOL2];
      }
      if (tagObj[":@"]) {
        assignAttributes(val, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
        val = val[options.textNodeName];
      } else if (Object.keys(val).length === 0) {
        if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }
      if (compressedObj[property2] !== void 0 && compressedObj.hasOwnProperty(property2)) {
        if (!Array.isArray(compressedObj[property2])) {
          compressedObj[property2] = [compressedObj[property2]];
        }
        compressedObj[property2].push(val);
      } else {
        if (options.isArray(property2, newJpath, isLeaf)) {
          compressedObj[property2] = [val];
        } else {
          compressedObj[property2] = val;
        }
      }
    }
  }
  if (typeof text === "string") {
    if (text.length > 0) compressedObj[options.textNodeName] = text;
  } else if (text !== void 0) compressedObj[options.textNodeName] = text;
  return compressedObj;
}
function propName(obj) {
  const keys3 = Object.keys(obj);
  for (let i = 0; i < keys3.length; i++) {
    const key = keys3[i];
    if (key !== ":@") return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    const keys3 = Object.keys(attrMap);
    const len = keys3.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys3[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var XMLParser = class {
  constructor(options) {
    this.externalEntities = {};
    this.options = buildOptions(options);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(xmlData, validationOption) {
    if (typeof xmlData === "string") {
    } else if (xmlData.toString) {
      xmlData = xmlData.toString();
    } else {
      throw new Error("XML data is accepted in String or Bytes[] form.");
    }
    if (validationOption) {
      if (validationOption === true) validationOption = {};
      const result2 = validate(xmlData, validationOption);
      if (result2 !== true) {
        throw Error(`${result2.err.msg}:${result2.err.line}:${result2.err.col}`);
      }
    }
    const orderedObjParser = new OrderedObjParser(this.options);
    orderedObjParser.addExternalEntities(this.externalEntities);
    const orderedResult = orderedObjParser.parseXml(xmlData);
    if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
    else return prettify(orderedResult, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(key, value) {
    if (value.indexOf("&") !== -1) {
      throw new Error("Entity value can't have '&'");
    } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    } else if (value === "&") {
      throw new Error("An entity with value '&' is not permitted");
    } else {
      this.externalEntities[key] = value;
    }
  }
  /**
   * Returns a Symbol that can be used to access the metadata
   * property on a node.
   * 
   * If Symbol is not available in the environment, an ordinary property is used
   * and the name of the property is here returned.
   * 
   * The XMLMetaData property is only present when `captureMetaData`
   * is true in the options.
   */
  static getMetaDataSymbol() {
    return XmlNode.getMetaDataSymbol();
  }
};

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var EOL = "\n";
function toXml(jArray, options) {
  let indentation = "";
  if (options.format && options.indentBy.length > 0) {
    indentation = EOL;
  }
  return arrToStr(jArray, options, "", indentation);
}
function arrToStr(arr, options, jPath, indentation) {
  let xmlStr = "";
  let isPreviousElementTag = false;
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const tagName = propName2(tagObj);
    if (tagName === void 0) continue;
    let newJPath = "";
    if (jPath.length === 0) newJPath = tagName;
    else newJPath = `${jPath}.${tagName}`;
    if (tagName === options.textNodeName) {
      let tagText = tagObj[tagName];
      if (!isStopNode(newJPath, options)) {
        tagText = options.tagValueProcessor(tagName, tagText);
        tagText = replaceEntitiesValue2(tagText, options);
      }
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += tagText;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.cdataPropName) {
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.commentPropName) {
      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
      isPreviousElementTag = true;
      continue;
    } else if (tagName[0] === "?") {
      const attStr2 = attr_to_str(tagObj[":@"], options);
      const tempInd = tagName === "?xml" ? "" : indentation;
      let piTextNodeName = tagObj[tagName][0][options.textNodeName];
      piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
      isPreviousElementTag = true;
      continue;
    }
    let newIdentation = indentation;
    if (newIdentation !== "") {
      newIdentation += options.indentBy;
    }
    const attStr = attr_to_str(tagObj[":@"], options);
    const tagStart = indentation + `<${tagName}${attStr}`;
    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
    if (options.unpairedTags.indexOf(tagName) !== -1) {
      if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
      else xmlStr += tagStart + "/>";
    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
      xmlStr += tagStart + "/>";
    } else if (tagValue && tagValue.endsWith(">")) {
      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
    } else {
      xmlStr += tagStart + ">";
      if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
        xmlStr += indentation + options.indentBy + tagValue + indentation;
      } else {
        xmlStr += tagValue;
      }
      xmlStr += `</${tagName}>`;
    }
    isPreviousElementTag = true;
  }
  return xmlStr;
}
function propName2(obj) {
  const keys3 = Object.keys(obj);
  for (let i = 0; i < keys3.length; i++) {
    const key = keys3[i];
    if (!obj.hasOwnProperty(key)) continue;
    if (key !== ":@") return key;
  }
}
function attr_to_str(attrMap, options) {
  let attrStr = "";
  if (attrMap && !options.ignoreAttributes) {
    for (let attr in attrMap) {
      if (!attrMap.hasOwnProperty(attr)) continue;
      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
      attrVal = replaceEntitiesValue2(attrVal, options);
      if (attrVal === true && options.suppressBooleanAttributes) {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
      } else {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
      }
    }
  }
  return attrStr;
}
function isStopNode(jPath, options) {
  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
  let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
  for (let index in options.stopNodes) {
    if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
  }
  return false;
}
function replaceEntitiesValue2(textValue, options) {
  if (textValue && textValue.length > 0 && options.processEntities) {
    for (let i = 0; i < options.entities.length; i++) {
      const entity = options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var defaultOptions3 = {
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: "  ",
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function Builder(options) {
  this.options = Object.assign({}, defaultOptions3, options);
  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
    this.isAttribute = function() {
      return false;
    };
  } else {
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }
  this.processTextOrObjNode = processTextOrObjNode;
  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = ">\n";
    this.newLine = "\n";
  } else {
    this.indentate = function() {
      return "";
    };
    this.tagEndChar = ">";
    this.newLine = "";
  }
}
Builder.prototype.build = function(jObj) {
  if (this.options.preserveOrder) {
    return toXml(jObj, this.options);
  } else {
    if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
      jObj = {
        [this.options.arrayNodeName]: jObj
      };
    }
    return this.j2x(jObj, 0, []).val;
  }
};
Builder.prototype.j2x = function(jObj, level, ajPath) {
  let attrStr = "";
  let val = "";
  const jPath = ajPath.join(".");
  for (let key in jObj) {
    if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
    if (typeof jObj[key] === "undefined") {
      if (this.isAttribute(key)) {
        val += "";
      }
    } else if (jObj[key] === null) {
      if (this.isAttribute(key)) {
        val += "";
      } else if (key === this.options.cdataPropName) {
        val += "";
      } else if (key[0] === "?") {
        val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
      } else {
        val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
      }
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, "", level);
    } else if (typeof jObj[key] !== "object") {
      const attr = this.isAttribute(key);
      if (attr && !this.ignoreAttributesFn(attr, jPath)) {
        attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
      } else if (!attr) {
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, "", level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      const arrLen = jObj[key].length;
      let listTagVal = "";
      let listTagAttr = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === "undefined") {
        } else if (item === null) {
          if (key[0] === "?") val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (typeof item === "object") {
          if (this.options.oneListGroup) {
            const result2 = this.j2x(item, level + 1, ajPath.concat(key));
            listTagVal += result2.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result2.attrStr;
            }
          } else {
            listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
          }
        } else {
          if (this.options.oneListGroup) {
            let textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, "", level);
          }
        }
      }
      if (this.options.oneListGroup) {
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val += listTagVal;
    } else {
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
      }
    }
  }
  return { attrStr, val };
};
Builder.prototype.buildAttrPairStr = function(attrName, val) {
  val = this.options.attributeValueProcessor(attrName, "" + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return " " + attrName;
  } else return " " + attrName + '="' + val + '"';
};
function processTextOrObjNode(object2, key, level, ajPath) {
  const result2 = this.j2x(object2, level + 1, ajPath.concat(key));
  if (object2[this.options.textNodeName] !== void 0 && Object.keys(object2).length === 1) {
    return this.buildTextValNode(object2[this.options.textNodeName], key, result2.attrStr, level);
  } else {
    return this.buildObjectNode(result2.val, key, result2.attrStr, level);
  }
}
Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if (val === "") {
    if (key[0] === "?") return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    else {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  } else {
    let tagEndExp = "</" + key + this.tagEndChar;
    let piClosingChar = "";
    if (key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
    if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    } else {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
    }
  }
};
Builder.prototype.closeTag = function(key) {
  let closeTag = "";
  if (this.options.unpairedTags.indexOf(key) !== -1) {
    if (!this.options.suppressUnpairedNode) closeTag = "/";
  } else if (this.options.suppressEmptyNode) {
    closeTag = "/";
  } else {
    closeTag = `></${key}`;
  }
  return closeTag;
};
Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
  } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` + this.newLine;
  } else if (key[0] === "?") {
    return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
  } else {
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
    if (textValue === "") {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    } else {
      return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
    }
  }
};
Builder.prototype.replaceEntitiesValue = function(textValue) {
  if (textValue && textValue.length > 0 && this.options.processEntities) {
    for (let i = 0; i < this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
};
function indentate(level) {
  return this.options.indentBy.repeat(level);
}
function isAttribute(name) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

// node_modules/phylotree/src/formats/nexml.js
var nexml_parser = function(xml_string, options) {
  const parser = new XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    parseAttributeValue: true
  });
  const xml = parser.parse(xml_string);
  var trees = xml["nex:nexml"].trees.tree.map(function(nexml_tree) {
    var node_list = nexml_tree.node.map((d) => d), node_hash = node_list.reduce(function(a, b) {
      b.edges = [];
      b.name = b.id;
      a[b.id] = b;
      return a;
    }, {}), roots = node_list.filter((d) => d.root), root_id = roots > 0 ? roots[0].id : node_list[0].id;
    node_hash[root_id].name = "root";
    nexml_tree.edge.map((d) => d).forEach(function(edge) {
      node_hash[edge.source].edges.push(edge);
    });
    function parseNexml(node, index) {
      if (node.edges) {
        var targets = pluck(node.edges, "target");
        node.children = values(pick_default(node_hash, targets));
        node.children.forEach(function(child, i) {
          child.attribute = node.edges[i].length || "";
        });
        node.children.forEach(parseNexml);
        node.annotation = "";
      }
    }
    parseNexml(node_hash[root_id]);
    return node_hash[root_id];
  });
  return trees;
};
var nexml_default = nexml_parser;

// node_modules/phylotree/src/nodes.js
var nodes_exports = {};
__export(nodes_exports, {
  addChild: () => addChild2,
  assignAttributes: () => assignAttributes2,
  clearInternalNodes: () => clearInternalNodes,
  createNode: () => createNode,
  deleteANode: () => deleteANode,
  getInternals: () => getInternals,
  getNodeByName: () => getNodeByName,
  getNodes: () => getNodes,
  getRootNode: () => getRootNode,
  getTips: () => getTips,
  graftANode: () => graftANode,
  isLeafNode: () => isLeafNode,
  selectAllDescendants: () => selectAllDescendants,
  updateKeyName: () => updateKeyName
});
function graftANode(graftAt, newChild, newParent, lengths) {
  let nodes = this.nodes.descendants();
  if (graftAt.parent) {
    let nodeIndex = nodes.indexOf(graftAt);
    if (nodeIndex >= 0) {
      let parentIndex = graftAt.parent.children.indexOf(graftAt);
      let newSplit = {
        name: newParent,
        parent: graftAt.parent,
        attribute: lengths ? lengths[2] : null,
        original_child_order: graftAt["original_child_order"]
      }, newNode = {
        name: newChild,
        parent: newSplit,
        attribute: lengths ? lengths[1] : null,
        original_child_order: 2
      };
      newSplit["children"] = [graftAt, newNode];
      graftAt["parent"].children[parentIndex] = newSplit;
      graftAt.parent = newSplit;
      graftAt["attribute"] = lengths ? lengths[0] : null;
      graftAt["original_child_order"] = 1;
    }
  }
  return this;
}
function addChild2(parent, child) {
  if (parent.children) {
    parent.children.push(child);
  } else {
    parent["children"] = [child];
  }
  return parent;
}
function createNode(name, lengths) {
  return {
    data: {
      name,
      attribute: lengths ? lengths[1] : null
    },
    parent: ""
  };
}
function deleteANode(index) {
  let nodes = this.nodes.descendants();
  if (typeof index != "number") {
    return this.deleteANode(nodes.indexOf(index));
  }
  if (index > 0 && index < nodes.length) {
    let node = nodes[index];
    if (node.parent) {
      let delete_me_idx = node.parent.children.indexOf(node);
      if (delete_me_idx >= 0) {
        nodes.splice(index, 1);
        if (node.children) {
          node.children.forEach(function(d) {
            d["original_child_order"] = node.parent.children.length;
            node.parent.children.push(d);
            d.parent = node.parent;
          });
        }
        if (node.parent.children.length > 2) {
          node.parent.children.splice(delete_me_idx, 1);
        } else {
          if (node.parent.parent) {
            node.parent.parent.children[node.parent.parent.children.indexOf(node.parent)] = node.parent.children[1 - delete_me_idx];
            node.parent.children[1 - delete_me_idx].parent = node.parent.parent;
            nodes.splice(nodes.indexOf(node.parent), 1);
          } else {
            nodes.splice(0, 1);
            nodes.parent = null;
            delete nodes.data["attribute"];
            delete nodes.data["annotation"];
            delete nodes.data["original_child_order"];
            nodes.name = "root";
            nodes.data.name = "root";
          }
        }
      }
    }
  }
  return this;
}
function getTips() {
  return filter(this.nodes.descendants(), (n) => {
    return !has2(n, "children");
  });
}
function getInternals() {
  return filter(this.nodes.descendants(), (n) => {
    return has2(n, "children");
  });
}
function getRootNode() {
  return this.nodes;
}
function getNodes() {
  return this.nodes;
}
function getNodeByName(name) {
  return filter(this.nodes.descendants(), (d) => {
    return d.data.name == name;
  })[0];
}
function assignAttributes2(attributes) {
  each(this.nodes.descendants(), function(d) {
    if (d.data && d.data.name in attributes) {
      d["annotations"] = attributes[d.data.name];
    }
  });
}
function isLeafNode(node) {
  return !has2(node, "children");
}
function updateKeyName(old_key, new_key) {
  this.nodes.each(function(n) {
    if (old_key in n) {
      if (new_key) {
        n[new_key] = n[old_key];
      }
      delete n[old_key];
    }
  });
  return this;
}
function clearInternalNodes(respect) {
  if (!respect) {
    this.nodes.each((d) => {
      if (!isLeafNode(d)) {
        d[this.selection_attribute_name] = false;
        if (!d.data.traits) {
          d.data.traits = {};
        }
        d.data.traits[this.selection_attribute_name] = d[this.selection_attribute_name];
      }
    });
  }
}
function selectAllDescendants(node, terminal, internal) {
  let selection = [];
  function sel(d) {
    if (isLeafNode(d)) {
      if (terminal) {
        if (d != node) selection.push(d);
      }
    } else {
      if (internal) {
        if (d != node) selection.push(d);
      }
      d.children.forEach(sel);
    }
  }
  sel(node);
  return selection;
}

// node_modules/phylotree/src/formats/newick.js
function newickParser(nwk_str, options = {}) {
  const bootstrap_values = true, int_or_float = /^-?\d+(\.\d+)?$/;
  let left_delimiter = options.left_delimiter || "{", right_delimiter = options.right_delimiter || "}";
  let clade_stack = [];
  function addNewTreeLevel() {
    let new_level = {
      name: null
    };
    let the_parent = clade_stack[clade_stack.length - 1];
    if (!("children" in the_parent)) {
      the_parent["children"] = [];
    }
    clade_stack.push(new_level);
    the_parent["children"].push(clade_stack[clade_stack.length - 1]);
    clade_stack[clade_stack.length - 1]["original_child_order"] = the_parent["children"].length;
  }
  function finishNodeDefinition() {
    let this_node = clade_stack.pop();
    this_node["name"] = current_node_name;
    if (bootstrap_values && "children" in this_node) {
      this_node["bootstrap_values"] = current_node_name;
    } else {
      this_node["name"] = current_node_name;
    }
    this_node["attribute"] = current_node_attribute;
    if (left_delimiter == "[" && current_node_annotation.includes("&&NHX")) {
      current_node_annotation.split(":").slice(1).forEach((annotation) => {
        const [key, value] = annotation.split("=");
        this_node[key] = int_or_float.test(value) ? +value : value;
      });
    } else {
      this_node["annotation"] = current_node_annotation;
    }
    current_node_name = "";
    current_node_attribute = "";
    current_node_annotation = "";
  }
  function generateError(location) {
    return {
      json: null,
      error: "Unexpected '" + nwk_str[location] + "' in '" + nwk_str.substring(location - 20, location + 1) + "[ERROR HERE]" + nwk_str.substring(location + 1, location + 20) + "'"
    };
  }
  let automaton_state = 0;
  let current_node_name = "";
  let current_node_attribute = "";
  let current_node_annotation = "";
  let quote_delimiter = null;
  let name_quotes = {
    "'": 1,
    '"': 1
  };
  let tree_json = {
    name: "root"
  };
  clade_stack.push(tree_json);
  var space = /\s/;
  for (var char_index = 0; char_index < nwk_str.length; char_index++) {
    try {
      var current_char = nwk_str[char_index];
      switch (automaton_state) {
        case 0: {
          if (current_char == "(") {
            addNewTreeLevel();
            automaton_state = 1;
          }
          break;
        }
        case 1:
        case 3: {
          if (current_char == ":") {
            automaton_state = 3;
          } else if (current_char == "," || current_char == ")") {
            try {
              finishNodeDefinition();
              automaton_state = 1;
              if (current_char == ",") {
                addNewTreeLevel();
              }
            } catch (e) {
              return generateError(char_index);
            }
          } else if (current_char == "(") {
            if (current_node_name.length > 0) {
              return generateError(char_index);
            } else {
              addNewTreeLevel();
            }
          } else if (current_char in name_quotes) {
            if (automaton_state == 1 && current_node_name.length === 0 && current_node_attribute.length === 0 && current_node_annotation.length === 0) {
              automaton_state = 2;
              quote_delimiter = current_char;
              continue;
            }
            return generateError(char_index);
          } else {
            if (current_char == left_delimiter) {
              if (current_node_annotation.length) {
                return generateError(char_index);
              } else {
                automaton_state = 4;
              }
            } else {
              if (automaton_state == 3) {
                current_node_attribute += current_char;
              } else {
                if (space.test(current_char)) {
                  continue;
                }
                if (current_char == ";") {
                  char_index = nwk_str.length;
                  break;
                }
                current_node_name += current_char;
              }
            }
          }
          break;
        }
        case 2: {
          if (current_char == quote_delimiter) {
            if (char_index < nwk_str.length - 1) {
              if (nwk_str[char_index + 1] == quote_delimiter) {
                char_index++;
                current_node_name += quote_delimiter;
                continue;
              }
            }
            quote_delimiter = 0;
            automaton_state = 1;
            continue;
          } else {
            current_node_name += current_char;
          }
          break;
        }
        case 4: {
          if (current_char == right_delimiter) {
            automaton_state = 3;
          } else {
            if (current_char == left_delimiter) {
              return generateError(char_index);
            }
            current_node_annotation += current_char;
          }
          break;
        }
      }
    } catch (e) {
      return generateError(char_index);
    }
  }
  if (clade_stack.length != 1) {
    return generateError(nwk_str.length - 1);
  }
  return {
    json: tree_json,
    error: null
  };
}
function getNewick(annotator, root2) {
  let self2 = this;
  if (!annotator) annotator = (d) => "";
  function nodeDisplay(n) {
    if (n.notshown) return;
    if (!isLeafNode(n)) {
      element_array.push("(");
      n.children.forEach(function(d, i) {
        if (i) {
          element_array.push(",");
        }
        nodeDisplay(d);
      });
      element_array.push(")");
    }
    if (n.data.name !== "root") {
      const node_label = n.data.name.replaceAll("'", "''");
      if (/\W/.test(node_label)) {
        element_array.push("'" + node_label + "'");
      } else {
        element_array.push(node_label);
      }
    }
    element_array.push(annotator(n));
    let bl = self2.branch_length_accessor(n);
    if (bl !== void 0) {
      element_array.push(":" + bl);
    }
  }
  let element_array = [];
  annotator = annotator || "";
  nodeDisplay(root2 || this.nodes);
  return element_array.join("") + ";";
}
var newick_default = newickParser;

// node_modules/phylotree/src/formats/nexus.js
var nexus_exports = {};
__export(nexus_exports, {
  default: () => loadTree,
  loadAnnotations: () => loadAnnotations,
  parseAnnotations: () => parseAnnotations
});
function parseAnnotations(buf) {
  let str = buf;
  let index = str.toUpperCase().indexOf("BEGIN DATA;");
  let data = str.slice(index);
  if (data.length < 2) {
    return "";
  }
  index = data.toUpperCase().indexOf("END;");
  let data_str = data.slice(0, index);
  data = map(data_str.split(";"), (d) => {
    return d.trim();
  });
  let dimensions = filter(data, (d) => {
    return d.toUpperCase().startsWith("DIMENSION");
  });
  dimensions = dimensions[0].split(" ");
  dimensions = object(map(rest(dimensions), (d) => {
    return d.split("=");
  }));
  let format2 = filter(data, (d) => {
    return d.toUpperCase().startsWith("FORMAT");
  });
  format2 = format2[0].split(" ");
  format2 = object(map(rest(format2), (d) => {
    return d.split("=");
  }));
  format2.symbols = reject(format2.symbols.split(""), (d) => d == '"');
  let matrix = filter(data, (d) => {
    return d.toUpperCase().startsWith("MATRIX");
  });
  matrix = matrix[0].split("\n");
  matrix = object(map(rest(matrix), (d) => {
    return compact(d.split(" "));
  }));
  matrix = mapObject(matrix, (v, k) => {
    if (v == "?") {
      return format2.symbols;
    } else {
      return Array(v);
    }
  });
  return { "dimensions": dimensions, "format": format2, "matrix": matrix };
}
function loadAnnotations(tree, label, annotations) {
  each(tree.getTips(), (d) => {
    d.data["test"] = annotations.matrix[d.data.name];
  });
}
function loadTree(buf) {
  let str = buf;
  let index = str.toUpperCase().indexOf("BEGIN TREES;");
  let split3 = str.slice(index);
  if (split3.length < 2) {
    return "";
  }
  index = split3.toUpperCase().indexOf("END;");
  let tree_str = split3.slice(0, index);
  let trees = tree_str.split("\n");
  trees = filter(trees, (d) => {
    return d.trim().toUpperCase().startsWith("TREE");
  });
  return newick_default(trees[0]);
}

// node_modules/phylotree/src/formats/phyloxml.js
function xmlToJson(xml) {
  var obj = {};
  if (xml.nodeType == 1) {
    if (xml.attributes.length > 0) {
      obj["@attributes"] = {};
      for (var j = 0; j < xml.attributes.length; j++) {
        var attribute = xml.attributes.item(j);
        obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
      }
    }
  } else if (xml.nodeType == 3) {
    obj = xml.nodeValue;
  }
  if (xml.hasChildNodes() && xml.childNodes.length === 1 && xml.childNodes[0].nodeType === 3) {
    obj = xml.childNodes[0].nodeValue;
  } else if (xml.hasChildNodes()) {
    for (var i = 0; i < xml.childNodes.length; i++) {
      var item = xml.childNodes.item(i);
      var nodeName = item.nodeName;
      if (typeof obj[nodeName] == "undefined") {
        obj[nodeName] = xmlToJson(item);
      } else {
        if (typeof obj[nodeName].push == "undefined") {
          var old = obj[nodeName];
          obj[nodeName] = [];
          obj[nodeName].push(old);
        }
        obj[nodeName].push(xmlToJson(item));
      }
    }
  }
  return obj;
}
var phyloxml_parser = function(xml, options) {
  function parsePhyloxml(node, index) {
    if (node.clade) {
      if (!Array.isArray(node.clade)) {
        node.clade = [node.clade];
      }
      node.clade.forEach(parsePhyloxml);
      node.children = node.clade;
      delete node.clade;
    }
    node.annotation = 1;
    node.attribute = "0.01";
    if (node.branch_length) {
      node.attribute = node.branch_length;
    }
    if (node.taxonomy) {
      node.name = node.taxonomy.scientific_name;
    }
    node.annotation = "";
  }
  var tree_json;
  if (typeof xml === "string") {
    if (DOMParser) {
      const parser = new DOMParser();
      xml = parser.parseFromString(xml, "text/xml");
    } else {
      const parser = new XMLParser();
      xml = parser.parse(xml);
    }
  }
  xml = xmlToJson(xml);
  var phylogeny = xml.phyloxml.phylogeny;
  if (Array.isArray(phylogeny)) {
    phylogeny = phylogeny[0];
    console.warn("PhyloXML files with multiple phylogenies are not currently supported. Only the first phylogeny will be loaded.");
  }
  tree_json = phylogeny.clade;
  tree_json.name = "root";
  parsePhyloxml(tree_json, 0);
  return {
    json: tree_json,
    error: null
  };
};
var phyloxml_default = phyloxml_parser;

// node_modules/phylotree/src/formats/beast.js
function beast_default(newick, options) {
  options.left_delimiter = "[";
  options.right_delimiter = "]";
  const parsed_newick = newick_default(newick, options);
  function parseBeastNode(node) {
    if (node.annotation) {
      node.beast = {};
      const tokens = node.annotation.split(/=|,|{|}/).filter((token) => token);
      for (var i = 0; i < tokens.length; i += 2) {
        let key = tokens[i].replace(/&|%/g, "");
        if (/[a-df-zA-DF-Z]+/.test(tokens[i + 2])) {
          node.beast[key] = +tokens[i + 1];
        } else {
          node.beast[key] = [+tokens[i + 1], +tokens[i + 2]];
          i++;
        }
      }
    }
    node.annotation = void 0;
    if (node.children) {
      node.children.forEach(parseBeastNode);
    }
  }
  parseBeastNode(parsed_newick.json);
  return parsed_newick;
}

// node_modules/phylotree/src/formats/registry.js
var format_registry = {
  nexml: nexml_default,
  phyloxml: phyloxml_default,
  nexus: loadTree,
  nwk: newick_default,
  nhx: newick_default,
  beast: beast_default
};
var registry_default = format_registry;

// node_modules/phylotree/src/export.js
function getTipLengths() {
  let self2 = this;
  let tips = self2.getTips();
  let toExport = map(tips, (d) => {
    return { "name": d.data.name, "length": parseFloat(d.data.attribute) };
  });
  toExport = sortBy(toExport, (d) => -d.length);
  return toExport;
}

// node_modules/phylotree/src/max-parsimony.js
function maxParsimony(respect_existing, attr_name) {
  function populateMpMatrix(attr_name2, d) {
    d.mp = [
      [0, 0],
      // score for parent selected / not selected
      [false, false]
    ];
    if (isLeafNode(d)) {
      d.mp[1][0] = d.mp[1][1] = d[attr_name2] || false;
      d.mp[0][0] = d.mp[1][0] ? 1 : 0;
      d.mp[0][1] = 1 - d.mp[0][0];
    } else {
      d.children.forEach(pop_mp_mat);
      var s0 = d.children.reduce(function(p, n) {
        return n.mp[0][0] + p;
      }, 0);
      var s1 = d.children.reduce(function(p, n) {
        return n.mp[0][1] + p;
      }, 0);
      if (d[attr_name2]) {
        d.mp[0][0] = s1 + 1;
        d.mp[1][0] = true;
        d.mp[0][1] = s1;
        d.mp[1][1] = true;
      } else {
        if (s0 < s1 + 1) {
          d.mp[0][0] = s0;
          d.mp[1][0] = false;
        } else {
          d.mp[0][0] = s1 + 1;
          d.mp[1][0] = true;
        }
        if (s1 < s0 + 1) {
          d.mp[0][1] = s1;
          d.mp[1][1] = true;
        } else {
          d.mp[0][1] = s0 + 1;
          d.mp[1][1] = false;
        }
      }
    }
  }
  const pop_mp_mat = partial_default(populateMpMatrix, attr_name);
  pop_mp_mat(this.nodes);
  this.nodes.each((d) => {
    if (d.parent) {
      d.mp = d.mp[1][d.parent.mp ? 1 : 0];
    } else {
      d.mp = d.mp[1][d.mp[0][0] < d.mp[0][1] ? 0 : 1];
    }
  });
  this.display.modifySelection((d, callback) => {
    if (isLeafNode(d.target)) {
      return d.target[attr_name];
    }
    return d.target.mp;
  });
}

// node_modules/phylotree/src/traversal.js
var _3 = __toESM(require_lodash());
function postOrder(node, callback, backtrack) {
  let nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    if (!(backtrack && backtrack(node))) {
      next.push(node), children = node.children;
      if (children)
        for (i = 0, n = children.length; i < n; ++i) {
          nodes.push(children[i]);
        }
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return node;
}
function preOrder(node, callback, backtrack) {
  let nodes = [node], children, i;
  while (node = nodes.pop()) {
    if (!(backtrack && backtrack(node))) {
      callback(node), children = node.children;
      if (children)
        for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
    }
  }
  return node;
}
function inOrder(node, callback, backtrack) {
  let current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      if (!(backtrack && backtrack(node))) {
        callback(node), children = node.children;
        if (children)
          for (i = 0, n = children.length; i < n; ++i) {
            next.push(children[i]);
          }
      }
    }
  } while (next.length);
  return node;
}
function leftChildRightSibling(root2) {
  let declareTrueParent = function(n) {
    if (n.children) {
      n.children[0].data.multiway_parent = n;
      n.children[1].data.multiway_parent = n.parent;
    }
  };
  postOrder(root2, declareTrueParent);
  let edge_list = _3.map(root2.descendants(), (n) => {
    let source = n.data.multiway_parent;
    let name = "unknown";
    if (source) {
      name = source.data.name;
    }
    return { "source": n.data.multiway_parent, "target": n, "name": name };
  });
  return edge_list;
}

// node_modules/phylotree/src/branches.js
function hasBranchLengths() {
  let bl = this.branch_length;
  if (bl) {
    return every(this.nodes.descendants(), function(node) {
      return !node.parent || !isUndefined(bl(node));
    });
  }
  return false;
}
function getBranchLengths() {
  let bl = this.branch_length;
  return map(this.nodes.descendants(), (node) => {
    return bl(node);
  });
}
function defBranchLengthAccessor(_node, new_length) {
  let _node_data = _node.data;
  if ("attribute" in _node_data && _node_data["attribute"] && _node_data["attribute"].length) {
    if (new_length > 0) {
      _node_data["attribute"] = String(new_length);
    }
    let bl = parseFloat(_node_data["attribute"]);
    if (!isNaN(bl)) {
      return Math.max(0, bl);
    }
  }
  if (_node_data.name == "root") {
    return 0;
  }
  console.warn("Undefined branch length at " + _node_data.name + "!");
  return void 0;
}
function setBranchLength(attr) {
  if (!arguments.length) return this.branch_length_accessor;
  this.branch_length_accessor = attr ? attr : defBranchLengthAccessor;
  return this;
}
function normalize(attr) {
  let bl = this.branch_length;
  let branch_lengths = map(this.nodes.descendants(), function(node) {
    if (bl(node)) {
      return bl(node);
    } else {
      return null;
    }
  });
  const max_bl = max2(branch_lengths);
  const min_bl = min(branch_lengths);
  let scaler = function(x) {
    return (x - min_bl) / (max_bl - min_bl);
  };
  each(this.nodes.descendants(), (node) => {
    let len = bl(node);
    if (len) {
      bl(node, scaler(len));
    }
  });
  return this;
}
function scale(scale_by) {
  let bl = this.branch_length;
  each(this.nodes.descendants(), (node) => {
    let len = bl(node);
    if (len) {
      bl(node, scale_by(len));
    }
  });
  return this;
}
function branchName(attr) {
  if (!arguments.length) return this.nodeLabel;
  this.nodeLabel = attr;
  return this;
}

// node_modules/phylotree/src/rooting.js
var rooting_exports = {};
__export(rooting_exports, {
  pathToRoot: () => pathToRoot,
  reroot: () => reroot,
  rootpath: () => rootpath
});
function reroot(node, fraction) {
  if (!(node instanceof hierarchy)) {
    throw new Error("node needs to be an instance of a d3.hierarchy node!");
  }
  let nodes = this.nodes.copy();
  fraction = fraction !== void 0 ? fraction : 0.5;
  if (node.parent) {
    var new_json = hierarchy({
      name: "new_root"
    });
    new_json.children = [node.copy()];
    new_json.data.__mapped_bl = void 0;
    nodes.each((n) => {
      n.data.__mapped_bl = this.branch_length_accessor(n);
    });
    this.setBranchLength((n) => {
      return n.data.__mapped_bl;
    });
    let remove_me = node, current_node = node.parent, stashed_bl = noop();
    let apportioned_bl = node.data.__mapped_bl === void 0 ? void 0 : node.data.__mapped_bl * fraction;
    stashed_bl = current_node.data.__mapped_bl;
    current_node.data.__mapped_bl = node.data.__mapped_bl === void 0 ? void 0 : node.data.__mapped_bl - apportioned_bl;
    node.data.__mapped_bl = apportioned_bl;
    var remove_idx;
    if (current_node.parent) {
      new_json.children.push(current_node);
      while (current_node.parent) {
        remove_idx = current_node.children.indexOf(remove_me);
        if (current_node.parent.parent) {
          current_node.children.splice(remove_idx, 1, current_node.parent);
        } else {
          current_node.children.splice(remove_idx, 1);
        }
        let t = current_node.parent.data.__mapped_bl;
        if (t !== void 0) {
          current_node.parent.data.__mapped_bl = stashed_bl;
          stashed_bl = t;
        }
        remove_me = current_node;
        current_node = current_node.parent;
      }
      remove_idx = current_node.children.indexOf(remove_me);
      current_node.children.splice(remove_idx, 1);
    } else {
      remove_idx = current_node.children.indexOf(remove_me);
      current_node.children.splice(remove_idx, 1);
      stashed_bl = current_node.data.__mapped_bl;
      remove_me = new_json;
    }
    if (current_node.children.length == 1) {
      if (stashed_bl) {
        current_node.children[0].data.__mapped_bl += stashed_bl;
      }
      remove_me.children = remove_me.children.concat(current_node.children);
    } else {
      let new_node = new hierarchy({ name: "__reroot_top_clade", __mapped_bl: stashed_bl });
      extendOwn_default(new_json.children[0], node);
      new_node.data.__mapped_bl = stashed_bl;
      new_node.children = current_node.children.map(function(n) {
        n.parent = new_node;
        return n;
      });
      new_node.parent = remove_me;
      remove_me.children.push(new_node);
    }
  }
  this.update(new_json);
  this.traverse_and_compute((n) => {
    each(n.children, (c) => {
      c.parent = n;
    });
  }, "pre-order");
  if (!isUndefined(this.display)) {
    let options = this.display.options;
    select_default(this.display.container).select("svg").remove();
    let selectionName = this.display.selection_attribute_name;
    delete this.display;
    let rendered_tree = this.render(options);
    rendered_tree.selectionLabel(selectionName);
    rendered_tree.update();
    select_default(rendered_tree.container).node().appendChild(rendered_tree.show());
    select_default(this.display.container).dispatch("reroot");
  }
  return this;
}
function rootpath(attr_name, store_name) {
  attr_name = attr_name || "attribute";
  store_name = store_name || "y_scaled";
  if ("parent" in this) {
    let my_value = parseFloat(this[attr_name]);
    this[store_name] = this.parent[store_name] + (isNaN(my_value) ? 0.1 : my_value);
  } else {
    this[store_name] = 0;
  }
  return this[store_name];
}
function pathToRoot(node) {
  let selection = [];
  while (node) {
    selection.push(node);
    node = node.parent;
  }
  return selection;
}

// node_modules/phylotree/src/render/coordinates.js
function xCoord(d) {
  return d.y;
}
function yCoord(d) {
  return d.x;
}

// node_modules/phylotree/src/render/radial.js
function radialMapper(r, a, radial_center) {
  return {
    x: radial_center + r * Math.sin(a),
    y: radial_center + r * Math.cos(a)
  };
}
function cartesianToPolar(node, radius, radial_root_offset, radial_center, scales, size2) {
  node.radius = radius * (node.radius + radial_root_offset);
  node.angle = 2 * Math.PI * node.x * scales[0] / size2[0];
  let radial2 = radialMapper(node.radius, node.angle, radial_center);
  node.x = radial2.x;
  node.y = radial2.y;
  return node;
}
function drawArc(radial_center, points) {
  var start = radialMapper(points[0].radius, points[0].angle, radial_center), end = radialMapper(points[0].radius, points[1].angle, radial_center);
  return "M " + xCoord(start) + "," + yCoord(start) + " A " + points[0].radius + "," + points[0].radius + " 0,0, " + (points[1].angle > points[0].angle ? 1 : 0) + " " + xCoord(end) + "," + yCoord(end) + " L " + xCoord(points[1]) + "," + yCoord(points[1]);
}
function arcSegmentPlacer(edge, where2, radial_center) {
  var r = radialMapper(
    edge.target.radius + (edge.source.radius - edge.target.radius) * where2,
    edge.target.angle,
    radial_center
  );
  return { x: xCoord(r), y: yCoord(r) };
}

// node_modules/phylotree/src/render/cartesian.js
var draw_line = line_default().x(function(d) {
  return xCoord(d);
}).y(function(d) {
  return yCoord(d);
}).curve(stepBefore);
function lineSegmentPlacer(edge, where2) {
  return {
    x: xCoord(edge.target) + (xCoord(edge.source) - xCoord(edge.target)) * where2,
    y: yCoord(edge.target)
  };
}
var cartesian_default = draw_line;

// node_modules/phylotree/src/render/clades.js
var clades_exports = {};
__export(clades_exports, {
  cladeCssSelectors: () => cladeCssSelectors,
  updateCollapsedClades: () => updateCollapsedClades
});

// node_modules/phylotree/src/render/nodes.js
var nodes_exports2 = {};
__export(nodes_exports2, {
  defNodeLabel: () => defNodeLabel,
  drawNode: () => drawNode,
  hasHiddenNodes: () => hasHiddenNodes,
  internalLabel: () => internalLabel,
  isNodeCollapsed: () => isNodeCollapsed,
  nodeCssSelectors: () => nodeCssSelectors,
  nodeLabel: () => nodeLabel,
  nodeNotshown: () => nodeNotshown,
  nodeSpan: () => nodeSpan2,
  nodeVisible: () => nodeVisible,
  reclassNode: () => reclassNode,
  shiftTip: () => shiftTip2,
  showInternalName: () => showInternalName,
  updateHasHiddenNodes: () => updateHasHiddenNodes
});

// node_modules/phylotree/src/render/helpers.js
function itemTagged(item) {
  return item.tag || false;
}
function itemSelected(item, tag) {
  return item[tag] || false;
}

// node_modules/phylotree/src/render/options.js
var options_exports = {};
__export(options_exports, {
  alignTips: () => alignTips,
  css_classes: () => css_classes,
  initializeCssClasses: () => initializeCssClasses,
  internalNames: () => internalNames,
  layoutHandler: () => layoutHandler,
  nodeBubbleSize: () => nodeBubbleSize,
  nodeSpan: () => nodeSpan,
  predefined_selecters: () => predefined_selecters,
  radial: () => radial,
  selectionCallback: () => selectionCallback,
  selectionLabel: () => selectionLabel,
  shiftTip: () => shiftTip
});
var css_classes = {
  "tree-container": "phylotree-container",
  "tree-scale-bar": "tree-scale-bar",
  node: "node",
  "internal-node": "internal-node",
  "tagged-node": "node-tagged",
  "selected-node": "node-selected",
  "collapsed-node": "node-collapsed",
  "root-node": "root-node",
  branch: "branch",
  "selected-branch": "branch-selected",
  "tagged-branch": "branch-tagged",
  "tree-selection-brush": "tree-selection-brush",
  "branch-tracer": "branch-tracer",
  clade: "clade",
  node_text: "phylotree-node-text"
};
function initializeCssClasses(classes = {}) {
  Object.keys(classes).forEach((key) => {
    css_classes[key] = classes[key];
  });
}
function internalNames(attr) {
  if (!arguments.length) return this.options["internal-names"];
  this.options["internal-names"] = attr;
  return this;
}
function radial(attr) {
  if (!arguments.length) return this.options["is-radial"];
  this.options["is-radial"] = attr;
  return this;
}
function alignTips(attr) {
  if (!arguments.length) return this.options["align-tips"];
  this.options["align-tips"] = attr;
  return this;
}
function nodeBubbleSize(node) {
  if (this.options["draw-size-bubbles"] && this.options["bubble-styler"]) {
    return this.options["bubble-styler"](node);
  } else {
    return this.options["draw-size-bubbles"] ? this.relative_nodeSpan(node) * this.scales[0] * 0.25 : 0;
  }
}
function shiftTip(d) {
  if (this.options["is-radial"]) {
    return [
      (d.text_align == "end" ? -1 : 1) * (this.radius_pad_for_bubbles - d.radius),
      0
    ];
  }
  if (this.options["right-to-left"]) {
    return [this.right_most_leaf - d.screen_x, 0];
  }
  return [this.right_most_leaf - d.screen_x, 0];
}
function layoutHandler(attr) {
  if (!arguments.length) return this.layout_listener_handler;
  this.layout_listener_handler = attr;
  return this;
}
function selectionLabel(attr) {
  if (!arguments.length) return this.selection_attribute_name;
  this.selection_attribute_name = attr;
  this.syncEdgeLabels();
  return this;
}
function nodeSpan(attr) {
  if (!arguments.length) return nodeSpan;
  if (typeof attr == "string" && attr == "equal") {
    nodeSpan = function(d) {
      return 1;
    };
  } else {
    nodeSpan = attr;
  }
  return this;
}
var predefined_selecters = {
  all: (d) => {
    return true;
  },
  none: (d) => {
    return false;
  },
  "all-leaf-nodes": (d) => {
    return isLeafNode(d.target);
  },
  "all-internal-nodes": (d) => {
    return !isLeafNode(d.target);
  }
};
function selectionCallback(callback) {
  if (!callback) return this._selectionCallback;
  this._selectionCallback = callback;
  return this;
}

// node_modules/phylotree/src/render/nodes.js
function shiftTip2(d) {
  if (this.radial()) {
    return [
      (d.text_align == "end" ? -1 : 1) * (this.radius_pad_for_bubbles - d.radius),
      0
    ];
  }
  if (this.options["right-to-left"]) {
    return [this.right_most_leaf - d.screen_x, 0];
  }
  return [this.right_most_leaf - d.screen_x, 0];
}
function drawNode(container, node, transitions) {
  container = select_default(container);
  var is_leaf = isLeafNode(node);
  if (is_leaf) {
    container = container.attr("data-node-name", node.data.name);
  }
  var labels = container.selectAll("text").data([node]), tracers = container.selectAll("line");
  if (is_leaf || this.showInternalName(node) && !isNodeCollapsed(node)) {
    labels = labels.enter().append("text").classed(this.css_classes["node_text"], true).merge(labels).on("click", (d) => {
      this.handle_node_click(node, d);
    }).attr("dy", (d) => {
      return this.shown_font_size * 0.33;
    }).text((d) => {
      return this.options["show-labels"] ? this._nodeLabel(d) : "";
    }).style("font-size", (d) => {
      return this.ensure_size_is_in_px(this.shown_font_size);
    });
    if (this.radial()) {
      labels = labels.attr("transform", (d) => {
        return this.d3PhylotreeSvgRotate(d.text_angle) + this.d3PhylotreeSvgTranslate(
          this.alignTips() ? this.shiftTip(d) : null
        );
      }).attr("text-anchor", (d) => {
        return d.text_align;
      });
    } else {
      labels = labels.attr("text-anchor", "start").attr("transform", (d) => {
        if (this.options["layout"] == "right-to-left") {
          return this.d3PhylotreeSvgTranslate([-20, 0]);
        }
        return this.d3PhylotreeSvgTranslate(
          this.alignTips() ? this.shiftTip(d) : null
        );
      });
    }
    if (this.alignTips()) {
      tracers = tracers.data([node]);
      if (transitions) {
        tracers = tracers.enter().append("line").classed(this.css_classes["branch-tracer"], true).merge(tracers).attr("x1", (d) => {
          return (d.text_align == "end" ? -1 : 1) * this.nodeBubbleSize(node);
        }).attr("x2", 0).attr("y1", 0).attr("y2", 0).attr("x2", (d) => {
          if (this.options["layout"] == "right-to-left") {
            return d.screen_x;
          }
          return this.shiftTip(d)[0];
        }).attr("transform", (d) => {
          return this.d3PhylotreeSvgRotate(d.text_angle);
        }).attr("x2", (d) => {
          if (this.options["layout"] == "right-to-left") {
            return d.screen_x;
          }
          return this.shiftTip(d)[0];
        }).attr("transform", (d) => {
          return this.d3PhylotreeSvgRotate(d.text_angle);
        });
      } else {
        tracers = tracers.enter().append("line").classed(this.css_classes["branch-tracer"], true).merge(tracers).attr("x1", (d) => {
          return (d.text_align == "end" ? -1 : 1) * this.nodeBubbleSize(node);
        }).attr("y2", 0).attr("y1", 0).attr("x2", (d) => {
          return this.shiftTip(d)[0];
        });
        tracers.attr("transform", (d) => {
          return this.d3PhylotreeSvgRotate(d.text_angle);
        });
      }
    } else {
      tracers.remove();
    }
    if (this.options["draw-size-bubbles"]) {
      var shift = this.nodeBubbleSize(node);
      let circles = container.selectAll("circle").data([shift]).enter().append("circle");
      circles.attr("r", function(d) {
        return d;
      });
      if (this.shown_font_size >= 5) {
        labels = labels.attr("dx", (d) => {
          return (d.text_align == "end" ? -1 : 1) * ((this.alignTips() ? 0 : shift) + this.shown_font_size * 0.33);
        });
      }
    } else {
      if (this.shown_font_size >= 5) {
        labels = labels.attr("dx", (d) => {
          return (d.text_align == "end" ? -1 : 1) * this.shown_font_size * 0.33;
        });
      }
    }
  }
  if (!is_leaf) {
    let circles = container.selectAll("circle").data([node]).enter().append("circle"), radius = this.node_circle_size()(node);
    if (radius > 0) {
      circles.merge(circles).attr("r", (d) => {
        return Math.min(this.shown_font_size * 0.75, radius);
      }).on("click", (d) => {
        this.handle_node_click(node, d);
      });
    } else {
      circles.remove();
    }
  }
  if (this.node_styler) {
    this.node_styler(container, node);
  }
  return node;
}
function updateHasHiddenNodes() {
  let nodes = this.phylotree.nodes.descendants();
  for (let k = nodes.length - 1; k >= 0; k -= 1) {
    if (isLeafNode(nodes[k])) {
      nodes[k].hasHiddenNodes = nodes[k].notshown;
    } else {
      nodes[k].hasHiddenNodes = nodes[k].children.reduce(function(p, c) {
        return c.notshown || p;
      }, false);
    }
  }
  return this;
}
function showInternalName(node) {
  const i_names = this.internalNames();
  if (i_names) {
    if (typeof i_names === "function") {
      return i_names(node);
    }
    return i_names;
  }
  return false;
}
function nodeSpan2(attr) {
  if (!arguments.length) return this.nodeSpan;
  if (typeof attr == "string" && attr == "equal") {
    this.nodeSpan = function(d) {
      return 1;
    };
  } else {
    this.nodeSpan = attr;
  }
  return this;
}
function reclassNode(node) {
  let class_var = css_classes[isLeafNode(node) ? "node" : "internal-node"];
  if (itemTagged(node)) {
    class_var += " " + css_classes["tagged-node"];
  }
  if (itemSelected(node, this.selection_attribute_name)) {
    class_var += " " + css_classes["selected-node"];
  }
  if (!node["parent"]) {
    class_var += " " + css_classes["root-node"];
  }
  if (isNodeCollapsed(node) || hasHiddenNodes(node)) {
    class_var += " " + css_classes["collapsed-node"];
  }
  return class_var;
}
function nodeVisible(node) {
  return !(node.hidden || node.notshown || false);
}
function nodeNotshown(node) {
  return node.notshown;
}
function hasHiddenNodes(node) {
  return node.hasHiddenNodes || false;
}
function isNodeCollapsed(node) {
  return node.collapsed || false;
}
function nodeCssSelectors(css_classes2) {
  return [
    css_classes2["node"],
    css_classes2["internal-node"],
    css_classes2["collapsed-node"],
    css_classes2["tagged-node"],
    css_classes2["root-node"]
  ].reduce(function(p, c, i, a) {
    return p += "g." + c + (i < a.length - 1 ? "," : "");
  }, "");
}
function internalLabel(callback, respect_existing) {
  this.phylotree.clearInternalNodes(respect_existing);
  for (var i = this.phylotree.nodes.descendants().length - 1; i >= 0; i--) {
    var d = this.phylotree.nodes.descendants()[i];
    if (!(isLeafNode(d) || itemSelected(d, this.selection_attribute_name))) {
      d[this.selection_attribute_name] = callback(d.children);
    }
  }
  this.modifySelection((d2, callback2) => {
    if (isLeafNode(d2.target)) {
      return d2.target[this.selection_attribute_name];
    }
    return d2.target[this.selection_attribute_name];
  });
}
function defNodeLabel(_node) {
  _node = _node.data;
  if (isLeafNode(_node)) {
    return _node.name || "";
  }
  if (this.showInternalName(_node)) {
    return _node.name;
  }
  return "";
}
function nodeLabel(attr) {
  if (!arguments.length) return this._nodeLabel;
  this._nodeLabel = attr ? attr : defNodeLabel;
  this.update();
  return this;
}

// node_modules/phylotree/src/render/clades.js
function cladeCssSelectors(css_classes2) {
  return [css_classes2["clade"]].reduce(function(p, c, i, a) {
    return p += "path." + c + (i < a.length - 1 ? "," : "");
  }, "");
}
function updateCollapsedClades(transitions) {
  let enclosure = this.svg.selectAll("." + this.css_classes["tree-container"]);
  var node_id = 0;
  let collapsed_clades = enclosure.selectAll(cladeCssSelectors(this.css_classes)).data(
    this.phylotree.nodes.descendants().filter(isNodeCollapsed),
    function(d) {
      return d.id || (d.id = ++node_id);
    }
  );
  let spline = function() {
  };
  let spline_f = noop();
  if (this.radial()) {
    spline = line_default().curve(basis_default).y(function(d) {
      return d[0];
    }).x(function(d) {
      return d[1];
    });
    spline_f = function(coord, i, d, init_0, init_1) {
      if (i) {
        return [
          d.screen_y + (coord[0] - init_0) / 50,
          d.screen_x + (coord[1] - init_1) / 50
        ];
      } else {
        return [d.screen_y, d.screen_x];
      }
    };
  } else {
    spline = line_default().y(function(d) {
      return d[0];
    }).x(function(d) {
      return d[1];
    }).curve(basis_default);
    spline_f = function(coord, i, d, init_0, init_1) {
      if (i) {
        return [
          d.screen_y + (coord[0] - init_0) / 50,
          d.screen_x + (coord[1] - init_1) / 50
        ];
      } else {
        return [d.screen_y, d.screen_x];
      }
    };
  }
  collapsed_clades.exit().each(function(d) {
    d.collapsed_clade = null;
  }).remove();
  if (transitions) {
    collapsed_clades.enter().insert("path", ":first-child").attr("class", this.css_classes["clade"]).merge(collapsed_clades).attr("d", function(d) {
      if (d.collapsed_clade) {
        return d.collapsed_clade;
      }
      let init_0 = d.collapsed[0][0];
      let init_1 = d.collapsed[0][1];
      return spline(
        d.collapsed.map(function(coord, i) {
          return spline_f(coord, i, d, init_0, init_1);
        })
      );
    }).attr("d", function(d) {
      return d.collapsed_clade = spline(d.collapsed);
    });
  } else {
    collapsed_clades.enter().insert("path", ":first-child").attr("class", this.css_classes["clade"]).merge(collapsed_clades).attr("d", function(d) {
      return d.collapsed_clade ? d.collapsed_clade : d.collapsed_clade = spline(d.collapsed);
    });
  }
}

// node_modules/phylotree/src/render/edges.js
var edges_exports = {};
__export(edges_exports, {
  drawEdge: () => drawEdge,
  edgeCssSelectors: () => edgeCssSelectors,
  edgeVisible: () => edgeVisible,
  initializeEdgeLabels: () => initializeEdgeLabels,
  placeAlongAnEdge: () => placeAlongAnEdge,
  reclassEdge: () => reclassEdge,
  syncEdgeLabels: () => syncEdgeLabels
});
function drawEdge(container, edge, transition) {
  container = select_default(container);
  container = container.attr("class", (d) => {
    return this.reclassEdge(d);
  }).on("click", (d) => {
    this.modifySelection([edge.target], this.selection_attribute_name);
    this.update();
  });
  let new_branch_path = this.draw_branch([edge.source, edge.target]);
  if (transition) {
    if (container.datum().existing_path) {
      container = container.attr("d", function(d) {
        return d.existing_path;
      });
    }
    container = container.attr("d", new_branch_path);
  } else {
    container = container.attr("d", new_branch_path);
  }
  edge.existing_path = new_branch_path;
  var bl = this.phylotree.branch_length_accessor(edge.target);
  if (bl !== void 0) {
    var haz_title = container.selectAll("title");
    if (haz_title.empty()) {
      haz_title = container.append("title");
    }
    haz_title.text("Length = " + bl);
  } else {
    container.selectAll("title").remove();
  }
  if (this.edge_styler) {
    this.edge_styler(container, edge, transition);
  }
  return this.phylotree;
}
function reclassEdge(edge) {
  let class_var = css_classes["branch"];
  if (itemTagged(edge)) {
    class_var += " " + css_classes["tagged-branch"];
  }
  if (itemSelected(edge, this.selection_attribute_name)) {
    class_var += " " + css_classes["selected-branch"];
  }
  return class_var;
}
function initializeEdgeLabels() {
  this.links.forEach((d) => {
    if (d.target.data.annotation) {
      d.target[d.target.data.annotation] = d.target.data.annotation;
    }
  });
}
function syncEdgeLabels() {
  this.links.forEach((d) => {
    d[this.selection_attribute_name] = d.target[this.selection_attribute_name] || false;
    d.tag = d.target.tag || false;
  });
  if (this.countHandler()) {
    let counts = {};
    counts[this.selection_attribute_name] = this.links.reduce((p, c) => {
      return p + (c[this.selection_attribute_name] ? 1 : 0);
    }, 0);
    counts["tagged"] = this.links.reduce(function(p, c) {
      return p + (itemTagged(c) ? 1 : 0);
    }, 0);
    this.countUpdate(this, counts, this.countHandler());
  }
}
function edgeVisible(edge) {
  return !(edge.target.hidden || edge.target.notshown || false);
}
function edgeCssSelectors(css_classes2) {
  return [
    css_classes2["branch"],
    css_classes2["selected-branch"],
    css_classes2["tagged-branch"]
  ].reduce(function(p, c, i, a) {
    return p += "path." + c + (i < a.length - 1 ? "," : "");
  }, "");
}
function placeAlongAnEdge(e, where2) {
  return this.edge_placer(e, where2);
}

// node_modules/phylotree/src/render/events.js
var events_exports = {};
__export(events_exports, {
  countUpdate: () => countUpdate,
  d3PhylotreeAddEventListener: () => d3PhylotreeAddEventListener,
  d3PhylotreeEventListener: () => d3PhylotreeEventListener,
  d3PhylotreeSvgRotate: () => d3PhylotreeSvgRotate,
  d3PhylotreeSvgTranslate: () => d3PhylotreeSvgTranslate,
  d3PhylotreeTriggerLayout: () => d3PhylotreeTriggerLayout,
  rescale: () => rescale,
  resizeSvg: () => resizeSvg,
  toggleCollapse: () => toggleCollapse,
  triggerRefresh: () => triggerRefresh
});
var d3_layout_phylotree_event_id = "phylotree.event";
function toggleCollapse(node) {
  if (node.collapsed) {
    node.collapsed = false;
    let unhide = function(n) {
      if (!isLeafNode(n)) {
        if (!n.collapsed) {
          n.children.forEach(unhide);
        }
      }
      n.hidden = false;
    };
    unhide(node);
  } else {
    node.collapsed = true;
  }
  this.placenodes();
  return this;
}
function resizeSvg(tree, svg, tr) {
  let sizes = this.size;
  if (this.radial()) {
    let pad_radius = this.pad_width(), vertical_offset = this.options["top-bottom-spacing"] != "fit-to-size" ? this.pad_height() : 0;
    sizes = [
      sizes[1] + 2 * pad_radius,
      sizes[0] + 2 * pad_radius + vertical_offset
    ];
    if (svg) {
      svg.selectAll("." + css_classes["tree-container"]).attr(
        "transform",
        "translate (" + pad_radius + "," + (pad_radius + vertical_offset) + ")"
      );
    }
  } else {
    sizes = [
      sizes[0] + (this.options["top-bottom-spacing"] != "fit-to-size" ? this.pad_height() : 0),
      sizes[1] + (this.options["left-right-spacing"] != "fit-to-size" ? this.pad_width() : 0)
    ];
  }
  if (svg) {
    if (tr) {
      svg = svg.transition(100);
    }
    svg.attr("height", sizes[0]).attr("width", sizes[1]);
  }
  this.size = sizes;
  return sizes;
}
function rescale(scale2, attr_name) {
  attr_name = attr_name || "y_scaled";
  if (attr_name in this) {
    this[attr_name] *= scale2;
  }
}
function triggerRefresh(tree) {
  var event = new CustomEvent(d3_layout_phylotree_event_id, {
    detail: ["refresh", tree]
  });
  document.dispatchEvent(event);
}
function countUpdate(tree, counts) {
  var event = new CustomEvent(d3_layout_phylotree_event_id, {
    detail: ["countUpdate", counts, tree.countHandler()]
  });
  document.dispatchEvent(event);
}
function d3PhylotreeTriggerLayout(tree) {
  var event = new CustomEvent(d3_layout_phylotree_event_id, {
    detail: ["layout", tree, tree.layoutHandler()]
  });
  document.dispatchEvent(event);
}
function d3PhylotreeEventListener(event) {
  switch (event.detail[0]) {
    case "refresh":
      event.detail[1].refresh();
      break;
    case "countUpdate":
      event.detail[2](event.detail[1]);
      break;
    case "layout":
      event.detail[2](event.detail[1]);
  }
  return true;
}
function d3PhylotreeAddEventListener() {
  document.addEventListener(
    d3_layout_phylotree_event_id,
    d3PhylotreeEventListener,
    false
  );
}
function d3PhylotreeSvgTranslate(x) {
  if (x && (x[0] !== null || x[1] !== null))
    return "translate (" + (x[0] !== null ? x[0] : 0) + "," + (x[1] !== null ? x[1] : 0) + ") ";
  return "";
}
function d3PhylotreeSvgRotate(a) {
  if (a !== null) {
    return "rotate (" + a + ") ";
  }
  return "";
}

// node_modules/phylotree/src/render/menus.js
var menus_exports = {};
__export(menus_exports, {
  addCustomMenu: () => addCustomMenu,
  getSelection: () => getSelection,
  modifySelection: () => modifySelection,
  nodeDropdownMenu: () => nodeDropdownMenu,
  selectAllDescendants: () => selectAllDescendants2,
  selectionCallback: () => selectionCallback2
});
var d3_layout_phylotree_context_menu_id = "d3_layout_phylotree_context_menu";
function nodeDropdownMenu(node, container, phylotree, options, event) {
  let menu_object = select_default(container).select("#" + d3_layout_phylotree_context_menu_id);
  if (menu_object.empty()) {
    menu_object = select_default(container).append("div").attr("id", d3_layout_phylotree_context_menu_id).attr("class", "dropdown-menu").attr("role", "menu");
  }
  menu_object.selectAll("a").remove();
  menu_object.selectAll("h6").remove();
  menu_object.selectAll("div").remove();
  if (node) {
    if (!some([
      Boolean(node.menu_items),
      options["hide"],
      options["selectable"],
      options["collapsible"]
    ]) || !options["show-menu"])
      return;
    if (!isLeafNode(node)) {
      if (options["collapsible"]) {
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text(isNodeCollapsed(node) ? "Expand Subtree" : "Collapse Subtree").on("click", (d) => {
          menu_object.style("display", "none");
          this.toggleCollapse(node).update();
        });
        if (options["selectable"]) {
          menu_object.append("div").attr("class", "dropdown-divider");
          menu_object.append("h6").attr("class", "dropdown-header").text("Toggle selection");
        }
      }
      if (options["selectable"]) {
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("All descendant branches").on("click", function(d) {
          menu_object.style("display", "none");
          phylotree.modifySelection(
            phylotree.selectAllDescendants(node, true, true)
          );
        });
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("All terminal branches").on("click", function(d) {
          menu_object.style("display", "none");
          phylotree.modifySelection(
            phylotree.selectAllDescendants(node, true, false)
          );
        });
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("All internal branches").on("click", function(d) {
          menu_object.style("display", "none");
          phylotree.modifySelection(
            phylotree.selectAllDescendants(node, false, true)
          );
        });
      }
    }
    if (node.parent) {
      if (options["selectable"]) {
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("Incident branch").on("click", function(d) {
          menu_object.style("display", "none");
          phylotree.modifySelection([node]);
        });
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("Path to root").on("click", (d) => {
          menu_object.style("display", "none");
          this.modifySelection(this.phylotree.pathToRoot(node));
        });
        if (options["reroot"] || options["hide"]) {
          menu_object.append("div").attr("class", "dropdown-divider");
        }
      }
      if (options["reroot"]) {
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("Reroot on this node").on("click", (d) => {
          menu_object.style("display", "none");
          this.phylotree.reroot(node);
          this.update();
        });
      }
      if (options["hide"]) {
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("Hide this " + (isLeafNode(node) ? "node" : "subtree")).on("click", (d) => {
          menu_object.style("display", "none");
          this.modifySelection([node], "notshown", true, true).updateHasHiddenNodes().update();
        });
      }
    }
    if (hasHiddenNodes(node)) {
      menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text("Show all descendant nodes").on("click", function(d) {
        menu_object.style("display", "none");
        phylotree.modifySelection(
          phylotree.selectAllDescendants(node, true, true),
          "notshown",
          true,
          true,
          "false"
        ).updateHasHiddenNodes().update();
      });
    }
    var has_user_elements = [];
    if ("menu_items" in node && typeof node["menu_items"] === "object") {
      node["menu_items"].forEach(function(d) {
        if (d.length == 3) {
          if (!d[2] || d[2](node)) {
            has_user_elements.push([d[0], d[1]]);
          }
        }
      });
    }
    if (has_user_elements.length) {
      const show_divider_options = [
        options["hide"],
        options["selectable"],
        options["collapsible"]
      ];
      if (some(show_divider_options)) {
        menu_object.append("div").attr("class", "dropdown-divider");
      }
      has_user_elements.forEach(function(d) {
        menu_object.append("a").attr("class", "dropdown-item").attr("tabindex", "-1").text(d[0](node)).on("click", partial_default(d[1], node));
      });
    }
    let tree_container = document.querySelector(container);
    let rect = tree_container.getBoundingClientRect();
    menu_object.style("position", "absolute").style("left", "" + (event.clientX - rect.x + 12) + "px").style("top", "" + (event.clientY - rect.y) + "px").style("display", "block");
  } else {
    menu_object.style("display", "none");
  }
}
function addCustomMenu(node, name, callback, condition) {
  if (!("menu_items" in node)) {
    node["menu_items"] = [];
  }
  if (!node["menu_items"].some(function(d) {
    return d[0] == name && d[1] == callback && d[2] == condition;
  })) {
    node["menu_items"].push([name, callback, condition]);
  }
}
function modifySelection(node_selecter, attr, place, skip_refresh, mode) {
  attr = attr || this.selection_attribute_name;
  mode = mode || "toggle";
  if (this.options["restricted-selectable"].length) {
    if (contains(keys(predefined_selecters), node_selecter)) {
      node_selecter = predefined_selecters[node_selecter];
    } else {
      return;
    }
  }
  if ((this.options["restricted-selectable"] || this.options["selectable"]) && !this.options["binary-selectable"]) {
    var do_refresh = false;
    if (typeof node_selecter === "function") {
      this.links.forEach(function(d) {
        let select_me = node_selecter(d);
        d[attr] = d[attr] || false;
        if (d[attr] != select_me) {
          d[attr] = select_me;
          do_refresh = true;
          d.target[attr] = select_me;
        }
      });
    } else {
      node_selecter.forEach(function(d) {
        var new_value;
        switch (mode) {
          case "true":
            new_value = true;
            break;
          case "false":
            new_value = false;
            break;
          default:
            new_value = !d[attr];
            break;
        }
        if (d[attr] != new_value) {
          d[attr] = new_value;
          do_refresh = true;
        }
      });
      this.links.forEach(function(d) {
        d[attr] = d.target[attr];
      });
    }
    var counts;
    if (do_refresh) {
      if (!skip_refresh) {
        triggerRefresh(this);
      }
      if (this.countHandler) {
        counts = {};
        counts[attr] = this.links.reduce(function(p, c) {
          return p + (c[attr] ? 1 : 0);
        }, 0);
        countUpdate(this, counts, this.countHandler);
      }
      if (place) {
        this.placenodes();
      }
    }
  } else if (this.options["binary-selectable"]) {
    if (typeof node_selecter === "function") {
      this.links.forEach(function(d) {
        var select_me = node_selecter(d);
        d[attr] = d[attr] || false;
        if (d[attr] != select_me) {
          d[attr] = select_me;
          do_refresh = true;
          d.target[attr] = select_me;
        }
        this.options["attribute-list"].forEach(function(type) {
          if (type != attr && d[attr] === true) {
            d[type] = false;
            d.target[type] = false;
          }
        });
      });
    } else {
      node_selecter.forEach(function(d) {
        var new_value;
        new_value = !d[attr];
        if (d[attr] != new_value) {
          d[attr] = new_value;
          do_refresh = true;
        }
      });
      this.links.forEach(function(d) {
        d[attr] = d.target[attr];
        this.options["attribute-list"].forEach(function(type) {
          if (type != attr && d[attr] !== true) {
            d[type] = false;
            d.target[type] = false;
          }
        });
      });
    }
    if (do_refresh) {
      if (!skip_refresh) {
        triggerRefresh(this);
      }
      if (this.countHandler()) {
        counts = {};
        counts[attr] = this.links.reduce(function(p, c) {
          return p + (c[attr] ? 1 : 0);
        }, 0);
        this.countUpdate(this, counts, this.countHandler());
      }
      if (place) {
        this.placenodes();
      }
    }
  }
  if (this._selectionCallback && attr != "tag") {
    this._selectionCallback(this.getSelection());
  }
  this.refresh();
  this.update();
  return this;
}
function getSelection() {
  return selectAllDescendants2(this.phylotree.getRootNode(), true, true).filter((d) => {
    return d[this.selection_attribute_name];
  });
}
function selectAllDescendants2(node, terminal, internal) {
  let selection = [];
  function sel(d) {
    if (isLeafNode(d)) {
      if (terminal) {
        if (d != node) selection.push(d);
      }
    } else {
      if (internal) {
        if (d != node) selection.push(d);
      }
      d.children.forEach(sel);
    }
  }
  sel(node);
  return selection;
}
function selectionCallback2(callback) {
  if (!callback) return this._selectionCallback;
  this._selectionCallback = callback;
  return this;
}

// node_modules/phylotree/src/render/draw.js
function constant2(x) {
  return function() {
    return x;
  };
}
var TreeRender = class {
  constructor(phylotree, options = {}) {
    initializeCssClasses(options["css-classes"]);
    this.css_classes = css_classes;
    this.phylotree = phylotree;
    this.container = options.container;
    this.separation = function(_node, _previous) {
      return 0;
    };
    this._nodeLabel = this.defNodeLabel;
    this.svg = null;
    this._selectionCallback = null;
    this.scales = [1, 1];
    this.size = [1, 1];
    this.fixed_width = [14, 30];
    this.scale_bar_font_size = 12;
    this.draw_branch = cartesian_default;
    this.draw_scale_bar = null;
    this.edge_placer = lineSegmentPlacer;
    this.count_listener_handler = function() {
    };
    this.layout_listener_handler = function() {
    };
    this.node_styler = void 0;
    this.edge_styler = void 0;
    this.selection_attribute_name = "selected";
    this.right_most_leaf = 0;
    this.label_width = 0;
    this.radial_center = 0;
    this.radius = 1;
    this.radius_pad_for_bubbles = 0;
    this.rescale_nodeSpan = 1;
    this.relative_nodeSpan = function(_node) {
      return this.nodeSpan(_node) / this.rescale_nodeSpan;
    };
    let default_options = {
      layout: "left-to-right",
      logger: console,
      branches: "step",
      scaling: true,
      bootstrap: false,
      "color-fill": true,
      "font-size": 14,
      "internal-names": false,
      selectable: true,
      // restricted-selectable can take an array of predetermined
      // selecters that are defined in phylotree.predefined_selecters
      // only the defined functions will be allowed when selecting
      // branches
      "restricted-selectable": false,
      collapsible: true,
      "left-right-spacing": "fixed-step",
      //'fit-to-size',
      "top-bottom-spacing": "fixed-step",
      "left-offset": 0,
      "show-scale": "top",
      // currently not implemented to support any other positioning
      "draw-size-bubbles": false,
      "bubble-styler": this.radius_pad_for_bubbles,
      "binary-selectable": false,
      "is-radial": false,
      "attribute-list": [],
      "max-radius": 768,
      "annular-limit": 0.38196601125010515,
      compression: 0.2,
      "align-tips": false,
      "maximum-per-node-spacing": 100,
      "minimum-per-node-spacing": 2,
      "maximum-per-level-spacing": 100,
      "minimum-per-level-spacing": 10,
      node_circle_size: constant2(3),
      transitions: null,
      brush: true,
      reroot: true,
      hide: true,
      "label-nodes-with-name": false,
      zoom: false,
      "show-menu": true,
      "show-labels": true,
      "node-styler": null,
      "edge-styler": null,
      "node-span": null
    };
    this.ensure_size_is_in_px = function(value) {
      return typeof value === "number" ? value + "px" : value;
    };
    this.options = defaults_default(options, default_options);
    this.font_size = this.options["font-size"];
    this.offsets = [0, this.font_size / 2];
    this.shown_font_size = this.font_size;
    this.width = this.options.width || 800;
    this.height = this.options.height || 600;
    this.node_styler = this.options["node-styler"];
    this.edge_styler = this.options["edge-styler"];
    this.nodeSpan = this.options["node-span"];
    if (!this.nodeSpan) {
      this.nodeSpan = function(_node) {
        return 1;
      };
    }
    this.rescale_nodeSpan = this.phylotree.nodes.children.map((d) => {
      if (isLeafNode(d) || this.showInternalName(d))
        return this.nodeSpan(d);
    }).reduce(function(p, c) {
      return Math.min(c, p || 1e200);
    }, null) || 1;
    this.initialize_svg(this.container);
    this.links = this.phylotree.nodes.links();
    this.initializeEdgeLabels();
    this.update();
    d3PhylotreeAddEventListener();
  }
  pad_height() {
    if (this.draw_scale_bar) {
      return this.scale_bar_font_size + 25;
    }
    return 0;
  }
  pad_width() {
    this.label_width = this._label_width(this.shown_font_size);
    const _label_width = this.options["show-labels"] ? this.label_width : 0;
    return this.offsets[1] + this.options["left-offset"] + _label_width;
  }
  /**
   * Collapses a given node.
   *
   * @param {Node} node A node to be collapsed.
   */
  collapse_node(n) {
    if (!isNodeCollapsed(n)) {
      n.collapsed = true;
    }
  }
  /**
   * Get or set the size of tree in pixels.
   *
   * @param {Array} attr (optional) An array of the form ``[height, width]``.
   * @returns {Phylotree} The current ``size`` array if getting, or the current ``phylotree``
   * if setting.
   */
  set_size(attr) {
    if (!arguments.length) {
      return this.size;
    }
    let phylo_attr = attr;
    if (this.options["top-bottom-spacing"] != "fixed-step") {
      this.size[0] = phylo_attr[0];
    }
    if (this.options["left-right-spacing"] != "fixed-step") {
      this.size[1] = phylo_attr[1];
    }
    return this;
  }
  /**
   * Getter/setter for the SVG element for the Phylotree to be rendered in.
   *
   * @param {d3-selection} svg_element (Optional) SVG element to render within, selected by D3.
   * @returns The selected SVG element if getting, or the current ``phylotree`` if setting.`
   */
  initialize_svg(svg_element) {
    if (this.svg !== svg_element) {
      select_default(svg_element).select("svg").remove();
      this.svg = create_default("svg").attr("width", this.width).attr("height", this.height);
      this.set_size([this.height, this.width]);
      if (this.css_classes["tree-container"] == "phylotree-container") {
        this.svg.selectAll("*").remove();
        this.svg.append("defs");
      }
      select_default(this.container).on(
        "click",
        (d) => {
          this.handle_node_click(null);
        },
        true
      );
    }
    return this;
  }
  update_layout(new_json, do_hierarchy) {
    if (do_hierarchy) {
      this.nodes = hierarchy(new_json);
      this.nodes.each(function(d) {
        d.id = null;
      });
    }
    this.update();
    this.syncEdgeLabels();
  }
  /**
   * Update the current phylotree, i.e., alter the svg
   * elements.
   *
   * @param {Boolean} transitions (Optional) Toggle whether transitions should be shown.
   * @returns The current ``phylotree``.
   */
  update(transitions) {
    var self2 = this;
    this.placenodes();
    transitions = this.transitions(transitions);
    let node_id = 0;
    let enclosure = this.svg.selectAll("." + css_classes["tree-container"]).data([0]);
    enclosure = enclosure.enter().append("g").attr("class", css_classes["tree-container"]).merge(enclosure).attr("transform", (d) => {
      return this.d3PhylotreeSvgTranslate([
        this.offsets[1] + this.options["left-offset"],
        this.pad_height()
      ]);
    });
    if (this.draw_scale_bar) {
      let scale_bar = this.svg.selectAll("." + css_classes["tree-scale-bar"]).data([0]);
      scale_bar.enter().append("g").attr("class", css_classes["tree-scale-bar"]).style("font-size", this.ensure_size_is_in_px(this.scale_bar_font_size)).merge(scale_bar).attr("transform", (d) => {
        return this.d3PhylotreeSvgTranslate([
          this.offsets[1] + this.options["left-offset"],
          this.pad_height() - 10
        ]);
      }).call(this.draw_scale_bar);
      scale_bar.selectAll("text").style("text-anchor", "end");
    } else {
      this.svg.selectAll("." + css_classes["tree-scale-bar"]).remove();
    }
    enclosure = this.svg.selectAll("." + css_classes["tree-container"]).data([0]);
    this.updateCollapsedClades(transitions);
    let drawn_links = enclosure.selectAll(edgeCssSelectors(css_classes)).data(this.links.filter(edgeVisible), (d) => {
      return d.target.id || (d.target.id = ++node_id);
    });
    if (transitions) {
      drawn_links.exit().remove();
    } else {
      drawn_links.exit().remove();
    }
    drawn_links = drawn_links.enter().insert("path", ":first-child").merge(drawn_links).each(function(d) {
      self2.drawEdge(this, d, transitions);
    });
    let drawn_nodes = enclosure.selectAll(nodeCssSelectors(css_classes)).data(
      this.phylotree.nodes.descendants().filter(nodeVisible),
      (d) => {
        return d.id || (d.id = ++node_id);
      }
    );
    drawn_nodes.exit().remove();
    drawn_nodes = drawn_nodes.enter().append("g").attr("class", this.reclassNode).merge(drawn_nodes).attr("transform", (d) => {
      const should_shift = this.options["layout"] == "right-to-left" && isLeafNode(d);
      d.screen_x = xCoord(d);
      d.screen_y = yCoord(d);
      return this.d3PhylotreeSvgTranslate([
        should_shift ? 0 : d.screen_x,
        d.screen_y
      ]);
    }).each(function(d) {
      self2.drawNode(this, d, transitions);
    }).attr("transform", (d) => {
      if (!isUndefined(d.screen_x) && !isUndefined(d.screen_y)) {
        return "translate(" + d.screen_x + "," + d.screen_y + ")";
      }
    });
    if (this.options["label-nodes-with-name"]) {
      drawn_nodes = drawn_nodes.attr("id", (d) => {
        return "node-" + d.name;
      });
    }
    this.resizeSvg(this.phylotree, this.svg, transitions);
    if (this.options["brush"]) {
      var brush = enclosure.selectAll("." + css_classes["tree-selection-brush"]).data([0]).enter().insert("g", ":first-child").attr("class", css_classes["tree-selection-brush"]);
      var brush_object = brush_default().on("brush", (event, d) => {
        var extent = event.selection, shown_links = this.links.filter(edgeVisible);
        var selected_links = shown_links.filter((d2, i) => {
          return d2.source.screen_x >= extent[0][0] && d2.source.screen_x <= extent[1][0] && d2.source.screen_y >= extent[0][1] && d2.source.screen_y <= extent[1][1] && d2.target.screen_x >= extent[0][0] && d2.target.screen_x <= extent[1][0] && d2.target.screen_y >= extent[0][1] && d2.target.screen_y <= extent[1][1];
        }).map((d2) => {
          return d2.target;
        });
        this.modifySelection(
          this.phylotree.links.map((d2) => {
            return d2.target;
          }),
          "tag",
          false,
          selected_links.length > 0,
          "false"
        );
        this.modifySelection(selected_links, "tag", false, false, "true");
      }).on("end", () => {
      });
      brush.call(brush_object);
    }
    this.syncEdgeLabels();
    if (this.options["zoom"]) {
      let zoom = zoom_default().scaleExtent([0.1, 10]).on("zoom", (event) => {
        select_default("." + css_classes["tree-container"]).attr("transform", (d) => {
          let toTransform = event.transform;
          return toTransform;
        });
        select_default("." + css_classes["tree-scale-bar"]).attr("transform", (d) => {
          let toTransform = event.transform;
          toTransform.y -= 10;
          return toTransform;
        });
      });
      this.svg.call(zoom);
    }
    return this;
  }
  _handle_single_node_layout(a_node) {
    let _nodeSpan = this.nodeSpan(a_node) / this.rescale_nodeSpan;
    this.x = a_node.x = this.x + this.separation(this.last_node, a_node) + (this.last_span + _nodeSpan) * 0.5;
    this._extents[1][1] = Math.max(this._extents[1][1], a_node.y);
    this._extents[1][0] = Math.min(
      this._extents[1][0],
      a_node.y - _nodeSpan * 0.5
    );
    if (this.is_under_collapsed_parent) {
      this._extents[0][1] = Math.max(
        this._extents[0][1],
        this.save_x + (a_node.x - this.save_x) * this.options["compression"] + this.save_span + (_nodeSpan * 0.5 + this.separation(this.last_node, a_node)) * this.options["compression"]
      );
    } else {
      this._extents[0][1] = Math.max(
        this._extents[0][1],
        this.x + _nodeSpan * 0.5 + this.separation(this.last_node, a_node)
      );
    }
    this.last_node = a_node;
    this.last_span = _nodeSpan;
  }
  tree_layout(a_node) {
    if (nodeNotshown(a_node)) {
      return void 0;
    }
    let is_leaf = isLeafNode(a_node);
    a_node.text_angle = null;
    a_node.text_align = null;
    a_node.radius = null;
    a_node.angle = null;
    let undef_BL = false;
    if (a_node["parent"]) {
      if (this.do_scaling) {
        if (undef_BL) {
          return 0;
        }
        a_node.y = this.phylotree.branch_length_accessor(a_node);
        if (typeof a_node.y === "undefined") {
          undef_BL = true;
          return 0;
        }
        a_node.y += a_node.parent.y;
      } else {
        a_node.y = is_leaf ? this.max_depth : a_node.depth;
      }
    } else {
      this.x = 0;
      a_node.y = 0;
      this.last_node = null;
      this.last_span = 0;
      this._extents = [[0, 0], [0, 0]];
    }
    if (is_leaf) {
      this._handle_single_node_layout(
        a_node
      );
    }
    if (!is_leaf) {
      if (isNodeCollapsed(a_node) && !this.is_under_collapsed_parent) {
        this.save_x = this.x;
        this.save_span = this.last_span * 0.5;
        this.is_under_collapsed_parent = true;
        this.process_internal_node(a_node);
        this.is_under_collapsed_parent = false;
        if (typeof a_node.x === "number") {
          a_node.x = this.save_x + (a_node.x - this.save_x) * this.options["compression"] + this.save_span;
          a_node.collapsed = [[a_node.x, a_node.y]];
          var map_me = (n) => {
            n.hidden = true;
            if (isLeafNode(n)) {
              this.x = n.x = this.save_x + (n.x - this.save_x) * this.options["compression"] + this.save_span;
              a_node.collapsed.push([n.x, n.y]);
            } else {
              n.children.map(map_me);
            }
          };
          this.x = this.save_x;
          map_me(a_node);
          a_node.collapsed.splice(1, 0, [this.save_x, a_node.y]);
          a_node.collapsed.push([this.x, a_node.y]);
          a_node.collapsed.push([a_node.x, a_node.y]);
          a_node.hidden = false;
        }
      } else {
        this.process_internal_node(a_node);
      }
    }
    return a_node.x;
  }
  process_internal_node(a_node) {
    let count_undefined = 0;
    if (this.showInternalName(a_node)) {
      let half_way = a_node.children.length / 2 >> 0;
      let displayed_children = 0;
      let managed_to_display = false;
      for (let child_id = 0; child_id < a_node.children.length; child_id++) {
        let child_x = this.tree_layout(a_node.children[child_id]);
        if (typeof child_x == "number") {
          displayed_children++;
        }
        if (displayed_children >= half_way && !managed_to_display) {
          this._handle_single_node_layout(a_node);
          managed_to_display = true;
        }
      }
      if (displayed_children == 0) {
        a_node.notshown = true;
        a_node.x = void 0;
      } else {
        if (!managed_to_display) {
          this._handle_single_node_layout(a_node);
        }
      }
    } else {
      a_node.x = a_node.children.map(this.tree_layout.bind(this)).reduce((a, b) => {
        if (typeof b == "number") return a + b;
        count_undefined += 1;
        return a;
      }, 0);
      if (count_undefined == a_node.children.length) {
        a_node.notshown = true;
        a_node.x = void 0;
      } else {
        a_node.x /= a_node.children.length - count_undefined;
      }
    }
  }
  do_lr(at_least_one_dimension_fixed) {
    if (this.radial() && at_least_one_dimension_fixed) {
      this.offsets[1] = 0;
    }
    if (this.options["left-right-spacing"] == "fixed-step") {
      this.size[1] = this.max_depth * this.fixed_width[1];
      this.scales[1] = (this.size[1] - this.offsets[1] - this.options["left-offset"]) / this._extents[1][1];
      this.label_width = this._label_width(this.shown_font_size);
      if (this.radial()) {
        this.label_width *= 2;
      }
    } else {
      this.label_width = this._label_width(this.shown_font_size);
      at_least_one_dimension_fixed = true;
      let available_width = this.size[1] - this.offsets[1] - this.options["left-offset"];
      if (available_width * 0.5 < this.label_width) {
        this.shown_font_size *= available_width * 0.5 / this.label_width;
        this.label_width = available_width * 0.5;
      }
      this.scales[1] = (this.size[1] - this.offsets[1] - this.options["left-offset"] - this.label_width) / this._extents[1][1];
    }
  }
  /**
   * Place the current nodes, i.e., determine their coordinates based
   * on current settings.
   *
   * @returns The current ``phylotree``.
   */
  placenodes() {
    this._extents = [
      [0, 0],
      [0, 0]
    ];
    this.x = 0;
    this.last_span = 0;
    this.last_node = null;
    this.last_span = 0;
    this.save_x = this.x, this.save_span = this.last_span * 0.5;
    this.do_scaling = this.options["scaling"];
    let undef_BL = false;
    this.is_under_collapsed_parent = false;
    this.max_depth = 1;
    this.phylotree.nodes.x = this.tree_layout(
      this.phylotree.nodes,
      this.do_scaling
    );
    this.max_depth = max(this.phylotree.nodes.descendants(), (n) => {
      return n.depth;
    });
    if (this.do_scaling && undef_BL) {
      this.do_scaling = false;
      this.phylotree.nodes.x = this.tree_layout(this.phylotree.nodes);
    }
    let at_least_one_dimension_fixed = false;
    this.draw_scale_bar = this.options["show-scale"] && this.do_scaling;
    this.offsets[1] = Math.max(
      this.font_size,
      -this._extents[1][0] * this.fixed_width[0]
    );
    if (this.options["top-bottom-spacing"] == "fixed-step") {
      this.size[0] = this._extents[0][1] * this.fixed_width[0];
      this.scales[0] = this.fixed_width[0];
    } else {
      this.scales[0] = (this.size[0] - this.pad_height()) / this._extents[0][1];
      at_least_one_dimension_fixed = true;
    }
    this.shown_font_size = Math.min(this.font_size, this.scales[0]);
    if (this.radial()) {
      this.draw_branch = partial_default(drawArc, this.radial_center);
      this.edge_placer = arcSegmentPlacer;
      let last_child_angle = null, last_circ_position = null, last_child_radius = null, min_radius = 0, effective_span = this._extents[0][1] * this.scales[0];
      let compute_distance = function(r1, r2, a1, a2, annular_shift2) {
        annular_shift2 = annular_shift2 || 0;
        return Math.sqrt(
          (r2 - r1) * (r2 - r1) + 2 * (r1 + annular_shift2) * (r2 + annular_shift2) * (1 - Math.cos(a1 - a2))
        );
      };
      let max_r = 0;
      this.phylotree.nodes.each((d) => {
        let my_circ_position = d.x * this.scales[0];
        d.angle = 2 * Math.PI * my_circ_position / effective_span;
        d.text_angle = d.angle - Math.PI / 2;
        d.text_angle = d.text_angle > 0 && d.text_angle < Math.PI;
        d.text_align = d.text_angle ? "end" : "start";
        d.text_angle = (d.text_angle ? 180 : 0) + d.angle * 180 / Math.PI;
      });
      this.do_lr(at_least_one_dimension_fixed);
      this.phylotree.nodes.each((d) => {
        d.radius = d.y * this.scales[1] / this.size[1];
        max_r = Math.max(d.radius, max_r);
      });
      let annular_shift = 0;
      this.phylotree.nodes.each((d) => {
        if (!d.children) {
          let my_circ_position = d.x * this.scales[0];
          if (last_child_angle !== null) {
            let required_spacing = my_circ_position - last_circ_position, radial_dist = compute_distance(
              d.radius,
              last_child_radius,
              d.angle,
              last_child_angle,
              annular_shift
            );
            let local_mr = radial_dist > 0 ? required_spacing / radial_dist : 10 * this.options["max-radius"];
            if (local_mr > this.options["max-radius"]) {
              let dd = required_spacing / this.options["max-radius"], b = d.radius + last_child_radius, c = d.radius * last_child_radius - (dd * dd - (last_child_radius - d.radius) * (last_child_radius - d.radius)) / 2 / (1 - Math.cos(last_child_angle - d.angle)), st = Math.sqrt(b * b - 4 * c);
              annular_shift = Math.min(
                this.options["annular-limit"] * max_r,
                (-b + st) / 2
              );
              min_radius = this.options["max-radius"];
            } else {
              min_radius = Math.max(min_radius, local_mr);
            }
          }
          last_child_angle = d.angle;
          last_circ_position = my_circ_position;
          last_child_radius = d.radius;
        }
      });
      this.radius = Math.min(
        this.options["max-radius"],
        Math.max(effective_span / 2 / Math.PI, min_radius)
      );
      if (at_least_one_dimension_fixed) {
        this.radius = Math.min(
          this.radius,
          (Math.min(effective_span, this._extents[1][1] * this.scales[1]) - this.label_width) * 0.5 - this.radius * annular_shift
        );
      }
      this.radial_center = this.radius_pad_for_bubbles = this.radius;
      this.draw_branch = partial_default(drawArc, this.radial_center);
      let scaler = 1;
      if (annular_shift) {
        scaler = max_r / (max_r + annular_shift);
        this.radius *= scaler;
      }
      this.phylotree.nodes.each((d) => {
        cartesianToPolar(
          d,
          this.radius,
          annular_shift,
          this.radial_center,
          this.scales,
          this.size
        );
        max_r = Math.max(max_r, d.radius);
        if (this.options["draw-size-bubbles"]) {
          this.radius_pad_for_bubbles = Math.max(
            this.radius_pad_for_bubbles,
            d.radius + this.nodeBubbleSize(d)
          );
        } else {
          this.radius_pad_for_bubbles = Math.max(
            this.radius_pad_for_bubbles,
            d.radius
          );
        }
        if (d.collapsed) {
          d.collapsed = d.collapsed.map((p) => {
            let z = {};
            z.x = p[0];
            z.y = p[1];
            z = cartesianToPolar(
              z,
              this.radius,
              annular_shift,
              this.radial_center,
              this.scales,
              this.size
            );
            return [z.x, z.y];
          });
          let last_point = d.collapsed[1];
          d.collapsed = d.collapsed.filter(function(p, i) {
            if (i < 3 || i > d.collapsed.length - 4) return true;
            if (Math.sqrt(
              Math.pow(p[0] - last_point[0], 2) + Math.pow(p[1] - last_point[1], 2)
            ) > 3) {
              last_point = p;
              return true;
            }
            return false;
          });
        }
      });
      this.size[0] = this.radial_center + this.radius / scaler;
      this.size[1] = this.radial_center + this.radius / scaler;
    } else {
      this.do_lr();
      this.draw_branch = cartesian_default;
      this.edge_placer = lineSegmentPlacer;
      this.right_most_leaf = 0;
      this.phylotree.nodes.each((d) => {
        d.x *= this.scales[0];
        d.y *= this.scales[1] * 0.8;
        if (this.options["layout"] == "right-to-left") {
          d.y = this._extents[1][1] * this.scales[1] - d.y;
        }
        if (isLeafNode(d)) {
          this.right_most_leaf = Math.max(
            this.right_most_leaf,
            d.y + this.nodeBubbleSize(d)
          );
        }
        if (d.collapsed) {
          d.collapsed.forEach((p) => {
            p[0] *= this.scales[0];
            p[1] *= this.scales[1] * 0.8;
          });
          let last_x = d.collapsed[1][0];
          d.collapsed = d.collapsed.filter(function(p, i) {
            if (i < 3 || i > d.collapsed.length - 4) return true;
            if (p[0] - last_x > 3) {
              last_x = p[0];
              return true;
            }
            return false;
          });
        }
      });
    }
    if (this.draw_scale_bar) {
      let domain_limit, range_limit;
      if (this.radial()) {
        range_limit = Math.min(this.radius / 5, 50);
        domain_limit = Math.pow(
          10,
          Math.ceil(
            Math.log(this._extents[1][1] * range_limit / this.radius) / Math.log(10)
          )
        );
        range_limit = domain_limit * (this.radius / this._extents[1][1]);
        if (range_limit < 30) {
          let stretch = Math.ceil(30 / range_limit);
          range_limit *= stretch;
          domain_limit *= stretch;
        }
      } else {
        domain_limit = this._extents[1][1];
        range_limit = this.size[1] - this.offsets[1] - this.options["left-offset"] - this.shown_font_size;
      }
      let scale2 = linear().domain([0, domain_limit]).range([0, range_limit]), scaleTickFormatter = format(".2f");
      this.draw_scale_bar = axisTop().scale(scale2).tickFormat(function(d) {
        if (d === 0) {
          return "";
        }
        return scaleTickFormatter(d);
      });
      if (this.radial()) {
        this.draw_scale_bar.tickValues([domain_limit]);
      } else {
        let round = function(x, n) {
          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        };
        let my_ticks = scale2.ticks();
        my_ticks = my_ticks.length > 1 ? my_ticks[1] : my_ticks[0];
        this.draw_scale_bar.ticks(
          Math.min(
            10,
            round(
              range_limit / (this.shown_font_size * scaleTickFormatter(my_ticks).length * 2),
              0
            )
          )
        );
      }
    } else {
      this.draw_scale_bar = null;
    }
    return this;
  }
  /**
   * Get or set spacing in the x-direction.
   *
   * @param {Number} attr (Optional), the new spacing value if setting.
   * @param {Boolean} skip_render (Optional), whether or not a refresh should be performed.
   * @returns The current ``spacing_x`` value if getting, or the current ``phylotree`` if setting.
   */
  spacing_x(attr, skip_render) {
    if (!arguments.length) return this.fixed_width[0];
    if (this.fixed_width[0] != attr && attr >= this.options["minimum-per-node-spacing"] && attr <= this.options["maximum-per-node-spacing"]) {
      this.fixed_width[0] = attr;
      if (!skip_render) {
        this.placenodes();
      }
    }
    return this;
  }
  /**
   * Get or set spacing in the y-direction.
   *
   * @param {Number} attr (Optional), the new spacing value if setting.
   * @param {Boolean} skip_render (Optional), whether or not a refresh should be performed.
   * @returns The current ``spacing_y`` value if getting, or the current ``phylotree`` if setting.
   */
  spacing_y(attr, skip_render) {
    if (!arguments.length) return this.fixed_width[1];
    if (this.fixed_width[1] != attr && attr >= this.options["minimum-per-level-spacing"] && attr <= this.options["maximum-per-level-spacing"]) {
      this.fixed_width[1] = attr;
      if (!skip_render) {
        this.placenodes();
      }
    }
    return this;
  }
  _label_width(_font_size) {
    _font_size = _font_size || this.shown_font_size;
    let width = 0;
    this.phylotree.nodes.descendants().filter(nodeVisible).forEach((node) => {
      let node_width = 12 + this._nodeLabel(node).length * _font_size * 0.8;
      if (node.angle !== null) {
        node_width *= Math.max(
          Math.abs(Math.cos(node.angle)),
          Math.abs(Math.sin(node.angle))
        );
      }
      width = Math.max(node_width, width);
    });
    return width;
  }
  /**
   * Get or set font size.
   *
   * @param {Function} attr Empty if getting, or new font size if setting.
   * @returns The current ``font_size`` accessor if getting, or the current ``phylotree`` if setting.
   */
  font_size(attr) {
    if (!arguments.length) return this.font_size;
    this.font_size = attr === void 0 ? 12 : attr;
    return this;
  }
  scale_bar_font_size(attr) {
    if (!arguments.length) return this.scale_bar_font_size;
    this.scale_bar_font_size = attr === void 0 ? 12 : attr;
    return this;
  }
  node_circle_size(attr, attr2) {
    if (!arguments.length) return this.options["node_circle_size"];
    this.options["node_circle_size"] = constant2(attr === void 0 ? 3 : attr);
    return this;
  }
  css(opt) {
    if (arguments.length === 0) return this.css_classes;
    if (arguments.length > 2) {
      var arg = {};
      arg[opt[0]] = opt[1];
      return this.css(arg);
    }
    for (var key in css_classes) {
      if (key in opt && opt[key] != css_classes[key]) {
        css_classes[key] = opt[key];
      }
    }
    return this;
  }
  transitions(arg) {
    if (arg !== void 0) {
      return arg;
    }
    if (this.options["transitions"] !== null) {
      return this.options["transitions"];
    }
    return this.phylotree.nodes.descendants().length <= 300;
  }
  /**
   * Get or set CSS classes.
   *
   * @param {Object} opt Keys are the CSS class to toggle and values are
   * the parameters for that CSS class.
   * @param {Boolean} run_update (optional) Whether or not the tree should update.
   * @returns The current ``phylotree``.
   */
  css_classes(opt, run_update) {
    if (!arguments.length) return this.css_classes;
    let do_update = false;
    for (var key in css_classes) {
      if (key in opt && opt[key] != this.css_classes[key]) {
        do_update = true;
        this.css_classes[key] = opt[key];
      }
    }
    if (run_update && do_update) {
      this.layout();
    }
    return this;
  }
  /**
   * Lay out the tree within the SVG.
   *
   * @param {Boolean} transitions Specify whether or not transitions should occur.
   * @returns The current ``phylotree``.
   */
  layout(transitions) {
    if (this.svg) {
      this.svg.selectAll(
        "." + this.css_classes["tree-container"] + ",." + this.css_classes["tree-scale-bar"] + ",." + this.css_classes["tree-selection-brush"]
      );
      this.d3PhylotreeTriggerLayout(this);
      return this.update();
    }
    this.d3PhylotreeTriggerLayout(this);
    return this;
  }
  handle_node_click(node, event) {
    this.nodeDropdownMenu(node, this.container, this, this.options, event);
  }
  refresh() {
    if (this.svg) {
      let enclosure = this.svg.selectAll(
        "." + this.css_classes["tree-container"]
      );
      let edges = enclosure.selectAll(edgeCssSelectors(this.css_classes)).attr("class", this.reclassEdge.bind(this));
      if (this.edge_styler) {
        edges.each((d) => {
          this.edge_styler(select_default(this), d);
        });
      }
    }
    return this;
  }
  countHandler(attr) {
    if (!arguments.length) return this.count_listener_handler;
    this.count_listener_handler = attr;
    return this;
  }
  /**
   * Get or set node styler. If setting, pass a function of two arguments,
   * ``element`` and ``data``. ``data`` exposes the underlying node so that
   * its attributes can be referenced. These can be used to apply styles to
   * ``element``, which will be a D3 selection corresponding to the SVG element
   * that makes up the current node.
   * ``transition`` is the third argument which indicates that there is an ongoing
   * d3 transition in progress
   *
   * @param {Function} attr - Optional; if setting, the node styler function to be set.
   * @returns The ``node_styler`` function if getting, or the current ``phylotree`` if setting.
   */
  style_nodes(attr) {
    if (!arguments.length) return this.node_styler;
    this.node_styler = attr;
    return this;
  }
  /**
   * Get or set edge styler. If setting, pass a function of two arguments,
   * ``element`` and ``data``. ``data`` exposes the underlying edge so that
   * its attributes can be referenced. These can be used to apply styles to
   * ``element``, which will be a D3 selection corresponding to the SVG element
   * that makes up the current edge.
   *
   * Note that, in accordance with the D3 hierarchy layout, edges will have
   * a ``source`` and ``target`` field, corresponding to the nodes that make up
   * up the associated branch.
   *
   * @param {Function} attr - Optional; if setting, the node styler function to be set.
   * @returns The ``edge_styler`` function if getting, or the current ``phylotree`` if setting.
   */
  style_edges(attr) {
    if (!arguments.length) return this.edge_styler;
    this.edge_styler = attr.bind(this);
    return this;
  }
  itemSelected(item, tag) {
    return item[tag] || false;
  }
  show() {
    return this.svg.node();
  }
};
extend_default(TreeRender.prototype, clades_exports);
extend_default(TreeRender.prototype, nodes_exports2);
extend_default(TreeRender.prototype, edges_exports);
extend_default(TreeRender.prototype, events_exports);
extend_default(TreeRender.prototype, menus_exports);
extend_default(TreeRender.prototype, options_exports);
var draw_default = TreeRender;

// node_modules/phylotree/src/main.js
function resortChildren(comparator, start_node, filter3) {
  this.nodes.sum(function(d) {
    return d.value;
  }).sort(comparator);
  if (this.display) {
    this.display.update_layout(this.nodes);
    this.display.update();
  }
  return this;
}
function mrca(mrca_nodes) {
  var mrca2;
  mrca_nodes = mrca_nodes.map(function(mrca_node) {
    return typeof mrca_node == "string" ? mrca_node : mrca_node.data.name;
  });
  this.traverse_and_compute(function(node) {
    if (!node.children) {
      node.data.mrca = intersection([node.data.name], mrca_nodes);
    } else if (!node.parent) {
      if (!mrca2) {
        mrca2 = node;
      }
    } else {
      node.data.mrca = union_default(
        ...node.descendants().map((child) => child.data.mrca)
      );
      if (!mrca2 && node.data.mrca.length == mrca_nodes.length) {
        mrca2 = node;
      }
    }
  });
  return mrca2;
}
var Phylotree = class {
  constructor(nwk, options = {}) {
    this.newick_string = "";
    this.nodes = [];
    this.links = [];
    this.parsed_tags = [];
    this.partitions = [];
    this.branch_length_accessor = defBranchLengthAccessor;
    this.branch_length = defBranchLengthAccessor;
    this.logger = options.logger || console;
    this.selection_attribute_name = "selected";
    var type = options.type || void 0, _node_data = [], self2 = this;
    if (isString_default(type)) {
      if (type in registry_default) {
        _node_data = registry_default[type](nwk, options);
      } else {
        self2.logger.error(
          "type " + type + " not in registry! Available types are " + keys(registry_default)
        );
      }
    } else if (isFunction_default(type)) {
      try {
        _node_data = type(nwk, options);
      } catch (e) {
        self2.logger.error("Could not parse custom format!");
      }
    } else {
      if (nwk.name == "root") {
        _node_data = { json: nwk, error: null };
      } else if (typeof nwk != "string") {
        _node_data = nwk;
      } else if (nwk.contentType == "application/xml") {
        _node_data = phyloxml_default(nwk);
      } else {
        this.newick_string = nwk;
        _node_data = newick_default(nwk, options);
      }
    }
    if (!_node_data["json"]) {
      self2.nodes = [];
    } else {
      self2.nodes = hierarchy(_node_data.json);
      let _parsed_tags = {};
      self2.nodes.each((node) => {
        if (node.data.annotation) {
          _parsed_tags[node.data.annotation] = true;
        }
      });
      self2.parsed_tags = Object.keys(_parsed_tags);
    }
    self2.links = self2.nodes.links();
    if (!this.hasBranchLengths()) {
      console.warn(
        "Phylotree User Warning : NO BRANCH LENGTHS DETECTED, SETTING ALL LENGTHS TO 1"
      );
      this.setBranchLength((x) => 1);
    }
    return self2;
  }
  /*
      Export the nodes of the tree with all local keys to JSON
      The return will be an array of nodes in the specified traversal_type
      ('post-order' : default, 'pre-order', or 'in-order')
      with parents and children referring to indices in that array
  
    */
  json(traversal_type) {
    var index = 0;
    this.traverse_and_compute(function(n) {
      n.json_export_index = index++;
    }, traversal_type);
    var node_array = new Array(index);
    index = 0;
    this.traverse_and_compute(function(n) {
      let node_copy = clone(n);
      delete node_copy.json_export_index;
      if (n.parent) {
        node_copy.parent = n.parent.json_export_index;
      }
      if (n.children) {
        node_copy.children = map(n.children, function(c) {
          return c.json_export_index;
        });
      }
      node_array[index++] = node_copy;
    }, traversal_type);
    this.traverse_and_compute(function(n) {
      delete n.json_export_index;
    }, traversal_type);
    return JSON.stringify(node_array);
  }
  /*
   * Traverse the tree in a prescribed order, and compute a value at each node.
   *
   * @param {Function} callback A function to be called on each node.
   * @param {String} traversal_type Either ``"pre-order"`` or ``"post-order"`` or ``"in-order"``.
   * @param {Node} root_node start traversal here, if provided, otherwise start at root
   * @param {Function} backtrack ; if provided, then at each node n, backtrack (n) will be called,
                                   and if it returns TRUE, traversal will NOT continue past into this
                                   node and its children
   */
  traverse_and_compute(callback, traversal_type, root_node, backtrack) {
    traversal_type = traversal_type || "post-order";
    function post_order(node) {
      if (isUndefined(node)) {
        return;
      }
      postOrder(node, callback, backtrack);
    }
    function pre_order(node) {
      preOrder(node, callback, backtrack);
    }
    function in_order(node) {
      inOrder(node, callback, backtrack);
    }
    if (traversal_type == "pre-order") {
      traversal_type = pre_order;
    } else {
      if (traversal_type == "in-order") {
        traversal_type = in_order;
      } else {
        traversal_type = post_order;
      }
    }
    traversal_type(root_node ? root_node : this.nodes);
    return this;
  }
  get_parsed_tags() {
    return this.parsed_tags;
  }
  update(json) {
    this.nodes = json;
  }
  // Warning : Requires DOM!
  render(options) {
    this.display = new draw_default(this, options);
    return this.display;
  }
};
Phylotree.prototype.isLeafNode = isLeafNode;
Phylotree.prototype.selectAllDescendants = selectAllDescendants;
Phylotree.prototype.mrca = mrca;
Phylotree.prototype.hasBranchLengths = hasBranchLengths;
Phylotree.prototype.getBranchLengths = getBranchLengths;
Phylotree.prototype.branchName = branchName;
Phylotree.prototype.normalizeBranchLengths = normalize;
Phylotree.prototype.scaleBranchLengths = scale;
Phylotree.prototype.getNewick = getNewick;
Phylotree.prototype.resortChildren = resortChildren;
Phylotree.prototype.setBranchLength = setBranchLength;
Phylotree.prototype.maxParsimony = maxParsimony;
Phylotree.prototype.getTipLengths = getTipLengths;
Phylotree.prototype.leftChildRightSibling = leftChildRightSibling;
extend_default(Phylotree.prototype, nodes_exports);
extend_default(Phylotree.prototype, rooting_exports);
extend_default(Phylotree.prototype, nexus_exports);
var main_default = Phylotree;

// node_modules/phylotree/src/metrics/pairwise-distances.js
function computePairwiseDistances(tree) {
  var bl = tree.branch_length_accessor;
  if (!bl) {
    throw "A non-null branch lengths accessor function is required for this operation";
  }
  var leaf_count = 0;
  tree.traverse_and_compute(function(n) {
    n.cot_computed_length = bl(n);
    if (n.parent && isUndefined(n.cot_computed_length)) {
      throw "Non-null branch lengths are required for this operation: missing branch length at node " + n.data.name;
    }
    if (tree.isLeafNode(n)) {
      n.cot_leaf_index = leaf_count++;
      n.cot_path_to_leaves_below = {};
      n.cot_path_to_leaves_below[n.cot_leaf_index] = 0;
      n.cot_path_to_leaves_above = {};
    } else {
      n.cot_path_to_leaves_below = {};
      n.cot_path_to_leaves_above = {};
    }
  });
  tree.traverse_and_compute(function(n) {
    if (n.parent) {
      each(n.cot_path_to_leaves_below, function(length_so_far, leaf_index) {
        n.parent.cot_path_to_leaves_below[leaf_index] = length_so_far + n.cot_computed_length;
      });
    }
  });
  var root_node = tree.getRootNode();
  function CopyFromSiblings(a_node) {
    for (var this_node = 0; this_node < a_node.children.length; this_node++) {
      for (var other_node = 0; other_node < a_node.children.length; other_node++) {
        if (this_node != other_node) {
          each(a_node.children[other_node].cot_path_to_leaves_below, function(length, index) {
            if (a_node.children[this_node].cot_path_to_leaves_above) {
              a_node.children[this_node].cot_path_to_leaves_above[index] = length + a_node.children[other_node].cot_computed_length;
            }
          });
        }
      }
    }
  }
  CopyFromSiblings(root_node);
  tree.traverse_and_compute(function(n) {
    if (n.parent) {
      each(n.parent.cot_path_to_leaves_above, function(length_so_far, leaf_index) {
        n.cot_path_to_leaves_above[leaf_index] = length_so_far + n.parent.cot_computed_length;
      });
      if (!tree.isLeafNode(n)) {
        CopyFromSiblings(n);
      }
    }
  }, "pre-order");
  return leaf_count;
}
var pairwise_distances_default = computePairwiseDistances;

// node_modules/phylotree/src/metrics/sackins.js
function sackin(tree) {
  let tips = tree.getTips();
  let depths = map(tips, (d) => {
    return d.depth;
  });
  return reduce_default(depths, function(memo, num) {
    return memo + num;
  }, 0);
}

// node_modules/phylotree/src/metrics/center-of-tree.js
function centerOfTree(tree, power) {
  power = power || 2;
  var leaf_count = pairwise_distances_default(tree);
  var current_min = Number.MAX_VALUE, current_split = 0, current_location = null;
  if (power == 2) {
    tree.traverse_and_compute(function(n) {
      if (n.parent) {
        var sum_below = 0, sum_below_squared = 0, sum_above = 0, sum_above_squared = 0;
        var count_below = 0;
        each(n.cot_path_to_leaves_below, function(l) {
          sum_below += l;
          sum_below_squared += l * l;
          count_below++;
        });
        each(n.cot_path_to_leaves_above, function(l) {
          sum_above += l;
          sum_above_squared += l * l;
        });
        var count_above = leaf_count - count_below;
        var tt = (sum_above - sum_below + n.cot_computed_length * count_above) / leaf_count;
        if (tt < 0) {
          tt = 0;
        } else if (tt > n.cot_computed_length) {
          tt = n.cot_computed_length;
        }
        var score = sum_above_squared + sum_below_squared + 2 * (sum_above * (n.cot_computed_length - tt) + sum_below * tt) + count_below * tt * tt + (n.cot_computed_length - tt) * (n.cot_computed_length - tt) * count_above;
        if (score < current_min) {
          current_location = n;
          current_split = tt / n.cot_computed_length;
          current_min = score;
        }
        delete n.cot_computed_length;
        delete n.cot_path_to_leaves_below;
        delete n.cot_path_to_leaves_above;
        delete n.cot_leaf_index;
      }
    });
  } else {
    tree.traverse_and_compute(function(n) {
      if (n.parent) {
        var optimization_step = n.cot_computed_length > 0 ? n.cot_computed_length * 0.05 : 0.1, current_t = 0;
        while (current_t < n.cot_computed_length) {
          var score = 0;
          each(n.cot_path_to_leaves_below, function(l) {
            score += Math.pow(l + current_t, power);
          });
          each(n.cot_path_to_leaves_above, function(l) {
            score += Math.pow(l + (n.cot_computed_length - current_t), power);
          });
          if (score < current_min) {
            current_location = n;
            current_split = current_t / n.cot_computed_length;
            current_min = score;
          }
          current_t += optimization_step;
        }
      }
    });
  }
  return {
    location: current_location,
    breakpoint: current_split,
    distance: current_min
  };
}

// node_modules/phylotree/src/metrics/compute-midpoint.js
function computeMidpoint(tree) {
  if (!tree.hasBranchLengths()) {
    throw "Center of tree calculation cannot be performed on trees that do not have fully specified branch lengths";
  }
  var bl = tree.branch_length;
  tree.traverse_and_compute(function(node) {
    if (node.parent) {
      var my_longest_path_length = bl(node);
      var my_longest_path_terminus;
      if (tree.isLeafNode(node)) {
        my_longest_path_terminus = node;
        node.max_path = 0;
        node.max_path_terminus = node;
      } else {
        my_longest_path_length += node.max_path;
        my_longest_path_terminus = node.max_path_terminus;
      }
      if (!node.parent.max_path || node.parent.max_path < my_longest_path_length) {
        node.parent.max_path = my_longest_path_length;
        node.parent.max_path_terminus = my_longest_path_terminus;
      }
    }
  });
  var root_node = tree.getRootNode();
  var longest_path_length = 0;
  root_node.children.forEach(function(root_child) {
    if (root_child.max_path_terminus !== root_node.max_path_terminus) {
      var pl = root_child.max_path + bl(root_child);
      if (pl >= longest_path_length) {
        longest_path_length = pl;
      }
    }
  });
  if (root_node.max_path > longest_path_length) {
    longest_path_length = (longest_path_length + root_node.max_path) * 0.5;
    var root_on = root_node.max_path_terminus;
    while (true) {
      var current_bl = bl(root_on);
      if (current_bl <= longest_path_length) {
        longest_path_length -= current_bl;
        root_on = root_on.parent;
      } else {
        return {
          location: root_on,
          breakpoint: longest_path_length / current_bl
        };
      }
    }
  }
  return { location: root_node, breakpoint: 0 };
}

// node_modules/phylotree/src/metrics/root-to-tip.js
function annotateCopyNumber(tree) {
  tree.traverse_and_compute(function(node) {
    if (tree.isLeafNode(node)) {
      node.data.copy_number = 1;
    }
  });
}
function computeRootToTipOtherRoot(tree, node, coming_from, shared_distance, distance_to_new_root) {
  var my_bl = tree.branch_length(node);
  var go_up = false;
  if (!coming_from) {
    shared_distance = node.data.rootToTip;
    distance_to_new_root = 0;
    go_up = true;
  }
  if (node.children) {
    for (var c = 0; c < node.children.length; c++) {
      if (node.children[c] != coming_from) {
        computeRootToTipOtherRoot(
          tree,
          node.children[c],
          node,
          shared_distance,
          distance_to_new_root
        );
      } else {
        go_up = true;
      }
    }
  }
  node.data.rtta = node.data.rootToTip - shared_distance + distance_to_new_root;
  if (go_up) {
    shared_distance -= my_bl;
    distance_to_new_root += my_bl;
  }
  if (node.parent && go_up) {
    computeRootToTipOtherRoot(
      tree,
      node.parent,
      node,
      shared_distance,
      distance_to_new_root
    );
  }
}
function fitRootToTip(tree) {
  var linear_data = [], max_r2 = 0, best_node = 0;
  annotateCopyNumber(tree);
  rootToTip(tree);
  tree.traverse_and_compute(function(node) {
    if (tree.isLeafNode(node) && !isNull(node.data.decimal_date_value)) {
      linear_data.push([node.data.decimal_date_value, node.data.rtta, node.data.copy_number]);
    }
  });
  let best_fit = linearFit(linear_data);
  tree.traverse_and_compute(function(node) {
    if (tree.isLeafNode(node) && !isNull(node.data.decimal_date_value)) {
      computeRootToTipOtherRoot(tree, node, null, 0, 0);
      linear_data = [];
      tree.traverse_and_compute(function(node2) {
        if (tree.isLeafNode(node2) && !isNull(node2.data.decimal_date_value)) {
          linear_data.push([
            node2.data.decimal_date_value,
            node2.data.rtta,
            node2.data.copy_number
          ]);
        }
      });
      var fit = linearFit(linear_data), r2 = fit["r2"];
      if (r2 > max_r2) {
        max_r2 = r2;
        best_node = node;
        best_fit = fit;
      }
    }
  });
  return { root: best_node, fit: best_fit };
}
function linearFit(data) {
  var ss = data.reduce(function(p, c) {
    return c[2] + p;
  }, 0), sx = data.reduce(function(p, c) {
    return c[2] * c[0] + p;
  }, 0), sy = data.reduce(function(p, c) {
    return c[2] * c[1] + p;
  }, 0), sxoss = sx / ss, syoss = sy / ss;
  var fitB = 0, st2 = 0, vary = 0;
  data.forEach(function(point) {
    var t = point[0] - sxoss;
    st2 += point[2] * t * t;
    fitB += point[2] * t * point[1];
    vary += point[2] * (point[1] - syoss) * (point[1] - syoss);
  });
  fitB /= st2;
  var a = (sy - sx * fitB) / ss;
  var varres = 0;
  data.forEach(function(point) {
    var t = point[1] - a - fitB * point[0];
    varres += point[2] * t * t;
  });
  return {
    intercept: a,
    slope: fitB,
    r2: 1 - varres / vary,
    "var (intercept)": Math.sqrt((1 + sx * sx / (ss * st2)) / ss),
    "var (slope)": Math.sqrt(1 / st2)
  };
}
function rootToTip(tree) {
  var bl = tree.branch_length_accessor, index = 0;
  tree.traverse_and_compute((n) => {
    if (n.parent) {
      n.data._computed_length = bl(n);
      if (!isNumber_default(n.data._computed_length)) {
        throw "rootToTip cannot be run on trees with missing branch lengths";
      }
    }
    if (tree.isLeafNode(n)) {
      n.data.leaf_index = index++;
    }
    if ("r2t" in n.data) {
      delete n.data.r2t;
    }
  });
  tree.traverse_and_compute((n) => {
    if (n.parent) {
      if (!("r2t" in n.parent.data)) {
        n.parent.data.r2t = {};
      }
      if (tree.isLeafNode(n)) {
        n.parent.data.r2t[n.data.leaf_index] = n.data._computed_length;
      } else {
        each(n.data.r2t, function(v, idx) {
          n.parent.data.r2t[idx] = v + n.data._computed_length;
        });
        delete n.data.r2t;
      }
      delete n.data._computed_length;
    }
  });
  var r2t = tree.getRootNode().data.r2t;
  tree.traverse_and_compute((n) => {
    if (tree.isLeafNode(n)) {
      n.data.rootToTip = r2t[n.data.leaf_index] || 0;
      delete n.data.leaf_index;
    }
  });
  delete tree.getRootNode().data.r2t;
  return tree;
}

// node_modules/phylotree/src/extract-dates.js
var default_date_converter = timeParse("%Y%m%d");
var default_regexp = /([0-9]{4}).?([0-9]{2}).?([0-9]{2})$/g;
var default_date_getter = function(node) {
  if (isLeafNode(node)) {
    if ("name" in node) {
      let location = default_regexp.exec(node.name);
      if (location) {
        return location[1] + location[2] + location[3];
      }
    }
  }
  return null;
};
var extract_dates = function(tree, date_getter, date_converter = default_date_converter) {
  date_getter = date_getter || default_date_getter;
  tree.traverse_and_compute(function(n) {
    var d_string = date_getter(n);
    if (d_string) {
      try {
        n.data.date_value = date_converter(d_string);
        var full_year = n.data.date_value.getFullYear();
        var year_start = new Date(full_year, 0, 1), year_start_p1 = new Date(full_year + 1, 0, 1);
        n.data.decimal_date_value = full_year + (n.data.date_value - year_start) / (year_start_p1 - year_start);
        return;
      } catch (e) {
      }
    }
    n.data.date_value = null;
    n.data.decimal_date_value = null;
  });
  return tree;
};
var extract_dates_default = extract_dates;

// node_modules/phylotree/src/clustering/cluster-picker.js
function clusterPicker(tree, bootstrap_threshold, diameter_threshold, root_node, missing_bootstrap_value) {
  root_node = root_node || tree.getRootNode();
  missing_bootstrap_value = isNumber_default(missing_bootstrap_value) ? missing_bootstrap_value : 1;
  let bl = tree.branch_length;
  tree.traverse_and_compute(function(n) {
    if (n.parent) {
      n._computed_length = bl(n);
      if (!isNumber_default(n._computed_length)) {
        throw "clusterPicker cannot be run on trees with missing branch lengths";
      }
      n.max_path_length = 0;
    }
  });
  tree.traverse_and_compute(function(n) {
    if (n.parent) {
      n.parent.max_path_length = Math.max(
        n.parent.max_path_length,
        n.max_path_length + n._computed_length
      );
    }
  });
  var clusters = [];
  tree.traverse_and_compute(noop, "pre-order", root_node, function(n) {
    if (!tree.isLeafNode(n)) {
      var bs = isString_default(n.data.bootstrap_values) ? +n.data.bootstrap_values : missing_bootstrap_value;
      if (bs >= bootstrap_threshold) {
        var my_diameter = reduce_default(
          n.children,
          function(c, n2) {
            return n2.max_path_length + n2._computed_length + c;
          },
          0
        );
        if (my_diameter <= diameter_threshold) {
          clusters.push({ root: n, diameter: my_diameter, bootstrap: bs });
          return true;
        }
      }
    }
    return false;
  });
  tree.traverse_and_compute(
    function(n) {
      if (n.parent) {
        delete n._computed_length;
        delete n.max_path_length;
      }
    },
    "post-order",
    root_node
  );
  each(clusters, function(cluster) {
    cluster["members"] = [];
    tree.traverse_and_compute(
      function(n) {
        if (tree.isLeafNode(n)) {
          cluster["members"].push(n);
        }
      },
      "post-order",
      cluster["root"]
    );
  });
  return clusters;
}
var cluster_picker_default = clusterPicker;

// node_modules/phylotree/src/clustering/phylopart.js
function phylopart(tree, bootstrap_threshold, percentile_threshold, missing_bootstrap_value, resolution) {
  missing_bootstrap_value = isNumber_default(missing_bootstrap_value) ? missing_bootstrap_value : 1;
  var leaf_count = pairwise_distances_default(tree);
  var core_node = tree.getRootNode().children[0];
  var min_bl = Number.MAX_VALUE, min_bl2 = Number.MAX_VALUE;
  if (!(percentile_threshold > 0 && percentile_threshold < 1)) {
    throw "Invalid percentile threshold in perform_phylopart";
  }
  tree.traverse_and_compute(function(n) {
    if (tree.isLeafNode(n)) {
      if (n.cot_computed_length < min_bl) {
        if (min_bl < min_bl2) {
          min_bl2 = min_bl;
        }
        min_bl = n.cot_computed_length;
      } else {
        if (n.cot_computed_length < min_bl2) {
          min_bl2 = n.cot_computed_length;
        }
      }
    }
  });
  min_bl += min_bl2;
  var max_path_length = reduce_default(
    core_node.cot_path_to_leaves_below,
    function(c, n) {
      return n > c ? n : c;
    },
    0
  ) + reduce_default(
    core_node.cot_path_to_leaves_above,
    function(c, n) {
      return n > c ? n : c;
    },
    0
  ) + core_node.cot_computed_length;
  var domain = max_path_length - min_bl;
  if (isUndefined(resolution)) {
    resolution = Math.min(1e-3, domain / 100);
  }
  var number_of_bins = (domain / resolution >> 0) + 1;
  if (number_of_bins > 500) {
    number_of_bins = 500;
    resolution = domain / number_of_bins;
  }
  var root_node = tree.getRootNode();
  root_node.paths_to_leaves = new Array(leaf_count);
  each(root_node.children, function(cn) {
    each(root_node.cot_path_to_leaves_below, function(v, i) {
      root_node.paths_to_leaves[i] = v + cn.cot_computed_length;
    });
  });
  tree.traverse_and_compute(function(n) {
    if (!tree.isLeafNode(n)) {
      n.histogram = new Array(number_of_bins);
      for (var i = 0; i < number_of_bins; i++) {
        n.histogram[i] = 0;
      }
      if (n.parent) {
        var index = 0;
        n.paths_to_leaves = [];
        each(n.cot_path_to_leaves_below, function(v, i2) {
          n.paths_to_leaves[index++] = v;
        });
      }
    }
    delete n.cot_path_to_leaves_above;
    delete n.cot_path_to_leaves_below;
  });
  tree.traverse_and_compute(function(n) {
    if (!tree.isLeafNode(n)) {
      for (var n1 = 0; n1 < n.paths_to_leaves.length; n1++) {
        for (var n2 = n1 + 1; n2 < n.paths_to_leaves.length; n2++) {
          var sum2 = n.paths_to_leaves[n1] + n.paths_to_leaves[n2];
          n.histogram[(sum2 - min_bl) / resolution >> 0]++;
        }
      }
      n.leaf_count = n.paths_to_leaves.length;
      delete n.paths_to_leaves;
    }
  });
  var total_comparisons = (leaf_count - 1) * leaf_count / 2 * percentile_threshold;
  var bin_i = 0;
  for (; bin_i < number_of_bins - 1 && total_comparisons > root_node.histogram[bin_i]; bin_i++) {
    total_comparisons -= root_node.histogram[bin_i];
  }
  var median_threshold = min_bl + (bin_i + (root_node.histogram[bin_i] - total_comparisons) / root_node.histogram[bin_i]) * resolution;
  var clusters = [];
  tree.traverse_and_compute(noop, "pre-order", null, function(n) {
    if (!tree.isLeafNode(n)) {
      var bs = isString_default(n.data.bootstrap_values) ? +n.data.bootstrap_values : missing_bootstrap_value;
      if (bs >= bootstrap_threshold) {
        var total_comparisons2 = n.leaf_count * (n.leaf_count - 1) * 0.25;
        var bin_i2 = 0;
        for (; bin_i2 < number_of_bins - 1 && total_comparisons2 > n.histogram[bin_i2]; bin_i2++) {
          total_comparisons2 -= n.histogram[bin_i2];
        }
        var my_median = min_bl + (bin_i2 + (n.histogram[bin_i2] - total_comparisons2) / n.histogram[bin_i2]) * resolution;
        if (my_median <= median_threshold) {
          clusters.push({ root: n, median: my_median, bootstrap: bs });
          return true;
        }
      }
    }
    return false;
  });
  tree.traverse_and_compute(function(n) {
    if (!tree.isLeafNode(n)) {
      if ("histogram" in n) {
        delete n.histogram;
        delete n.leaf_count;
      }
    }
  });
  each(clusters, function(cluster) {
    cluster["members"] = [];
    tree.traverse_and_compute(
      function(n) {
        if (tree.isLeafNode(n)) {
          cluster["members"].push(n);
        }
      },
      "post-order",
      cluster["root"]
    );
  });
  return clusters;
}
var phylopart_default = phylopart;

// node_modules/phylotree/src/msa-parsers/fasta.js
var _4 = __toESM(require_lodash());
function parseFasta(fastaData) {
  let sfasta = _4.split(fastaData, "\n");
  let seqs = _4.chain(sfasta).map((d, i) => d.startsWith(">") ? i : -1).filter((d) => d != -1).map((d, i, c) => _4.slice(sfasta, c[i], c[i + 1])).keyBy((d) => _4.trim(d[0], ">")).mapValues((d) => _4.tail(d).join("")).value();
  return seqs;
}

// node_modules/phylotree/src/neighbor-join.js
var _5 = __toESM(require_lodash());
function remove2(i, D) {
  let dNew = [];
  for (let j of _5.range(D.length)) {
    if (j != i) {
      let dNewRow = [];
      for (let k of _5.range(D[j].length)) {
        if (k != i) {
          dNewRow.push(D[j][k]);
        }
      }
      dNew.push(dNewRow);
    }
  }
  return dNew;
}
function getDPrime(distanceMatrix, totalDistances, N) {
  let DPrime = _5.chunk(_5.fill(Array(N * N), 0), N);
  for (let i of _5.range(N)) {
    for (let j of _5.range(_5.parseInt(i) + 1, N)) {
      DPrime[i][j] = (N - 2) * distanceMatrix[i][j] - totalDistances[i] - totalDistances[j];
      DPrime[j][i] = DPrime[i][j];
    }
  }
  return DPrime;
}
function ijMinDPrime(dPrime, N) {
  let i = -1;
  let j = -1;
  let minD = Infinity;
  for (let ii of _5.range(N)) {
    for (let jj of _5.range(i, N)) {
      if (dPrime[ii][jj] < minD) {
        i = ii;
        j = jj;
        minD = dPrime[i][j];
      }
    }
  }
  return [i, j, minD];
}
function createDelta(totalDistances, N) {
  let deltaMatrix = _5.chunk(Array(N * N), N);
  for (let i of _5.range(N)) {
    for (let j of _5.range(parseInt(i) + 1, N)) {
      deltaMatrix[i][j] = (totalDistances[i] - totalDistances[j]) / (N - 2);
      deltaMatrix[j][i] = deltaMatrix[i][j];
    }
  }
  return deltaMatrix;
}
function getDistanceMatrix(seqs) {
  let initKey = _5.keys(seqs)[0];
  let seqLength = seqs[initKey].length;
  return _5.mapValues(
    seqs,
    (seq) => _5.map(
      seqs,
      (seq2) => _5.sum(
        _5.map(
          _5.range(seqLength),
          (i) => seq[i] != seq2[i] && seq[i] != "-" && seq2[i] != "-"
        )
      )
    )
  );
}
function getTotalDistances(distanceMatrix) {
  return _5.map(distanceMatrix, _5.sum);
}
function neighborJoining(distanceMatrixArr, n, nodeList) {
  if (n <= 2) {
    let tree = new main_default("");
    let newNode = tree.getNodes();
    let distance = distanceMatrixArr[0][1] / 2;
    let nodeA = tree.createNode(nodeList[0], [null, [distance]]);
    let nodeB = tree.createNode(nodeList[1], [null, [distance]]);
    tree.addChild(newNode, nodeA);
    tree.addChild(newNode, nodeB);
    return tree;
  } else {
    let N = n;
    let totalDistances = getTotalDistances(distanceMatrixArr);
    let dPrime = getDPrime(distanceMatrixArr, totalDistances, N);
    let [i, j, minD] = ijMinDPrime(dPrime, N);
    let deltaMatrix = createDelta(totalDistances, N);
    let limbLengthI = (distanceMatrixArr[i][j] + deltaMatrix[i][j]) / 2;
    let limbLengthJ = (distanceMatrixArr[i][j] - deltaMatrix[i][j]) / 2;
    let newRow = _5.concat(
      0,
      _5.filter(
        _5.map(_5.range(n), (k) => {
          if (k != i && k != j) {
            return 0.5 * (distanceMatrixArr[k][i] + distanceMatrixArr[k][j] - distanceMatrixArr[i][j]);
          }
        }),
        _5.isNumber
      )
    );
    let nodeI = nodeList[i];
    let nodeJ = nodeList[j];
    let m = "InternalNode0";
    let internalNodes = _5.filter(
      nodeList,
      (x) => _5.includes(x, "InternalNode")
    );
    if (internalNodes.length) {
      let highestNum = _5.max(
        _5.map(internalNodes, (label) => _5.split(label, "InternalNode")[1])
      );
      m = "InternalNode" + ++highestNum;
    }
    nodeList.unshift(m);
    distanceMatrixArr = remove2(_5.max([i, j]), distanceMatrixArr);
    distanceMatrixArr = remove2(_5.min([i, j]), distanceMatrixArr);
    distanceMatrixArr.unshift(newRow);
    _5.each(_5.range(1, n - 1), (l) => distanceMatrixArr[l].unshift(newRow[l]));
    _5.remove(nodeList, (n2) => n2 == nodeI || n2 == nodeJ);
    let tree = neighborJoining(distanceMatrixArr, N - 1, nodeList);
    let treeNodeI = tree.createNode(nodeI, [null, [limbLengthI]]);
    let treeNodeJ = tree.createNode(nodeJ, [null, [limbLengthJ]]);
    if (tree.getNodeByName(m)) {
      let internalNode = tree.getNodeByName(m);
      tree.addChild(internalNode, treeNodeI);
      tree.addChild(internalNode, treeNodeJ);
    } else {
      let newNode = tree.createNode(m, [null, [0]]);
      tree.addChild(tree.getNodes(), newNode);
      tree.addChild(newNode, treeNodeI);
      tree.addChild(newNode, treeNodeJ);
    }
    return tree;
  }
  return null;
}
export {
  centerOfTree,
  cluster_picker_default as clusterPicker,
  computeMidpoint,
  extract_dates_default as extract_dates,
  fitRootToTip,
  getDistanceMatrix,
  getNewick,
  inOrder,
  leftChildRightSibling,
  loadAnnotations,
  neighborJoining,
  newick_default as newickParser,
  pairwise_distances_default as pairwise_distances,
  parseAnnotations,
  parseFasta,
  phylopart_default as phylopart,
  main_default as phylotree,
  postOrder,
  preOrder,
  rootToTip,
  sackin
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=phylotree.js.map
